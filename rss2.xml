<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>zaynの博客</title>
    <link>http://zyanprocess.github.io/</link>
    
    <atom:link href="http://zyanprocess.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>从前追寻答案，现在相信过程</description>
    <pubDate>Wed, 12 Apr 2023 08:27:30 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>线程池复用</title>
      <link>http://zyanprocess.github.io/2023/04/12/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%8D%E7%94%A8/</link>
      <guid>http://zyanprocess.github.io/2023/04/12/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%8D%E7%94%A8/</guid>
      <pubDate>Wed, 12 Apr 2023 07:51:46 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;Worker执行任务模型&quot;&gt;&lt;a href=&quot;#Worker执行任务模型&quot; class=&quot;headerlink&quot; title=&quot;Worker执行任务模型&quot;&gt;&lt;/a&gt;Worker执行任务模型&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2023/04/12/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%8D%E7%94%A8/1.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;主要执行任务的三个角色&lt;/p&gt;
&lt;p&gt;Worker –&amp;gt; WorkQueue –&amp;gt; Thread&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="Worker执行任务模型"><a href="#Worker执行任务模型" class="headerlink" title="Worker执行任务模型"></a>Worker执行任务模型</h1><p><img src="/2023/04/12/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%8D%E7%94%A8/1.png"></p><p>主要执行任务的三个角色</p><p>Worker –&gt; WorkQueue –&gt; Thread</p><span id="more"></span><h1 id="Worker线程如何增加"><a href="#Worker线程如何增加" class="headerlink" title="Worker线程如何增加"></a>Worker线程如何增加</h1><p>涉及参数：</p><table><thead><tr><th>名称</th><th>含义</th></tr></thead><tbody><tr><td>core</td><td>如果为true，则与 corePoolSize 绑定。为false，则与 maximumPoolSize 绑定</td></tr><tr><td>firstTask</td><td>新线程首先要执行的任务，若没有则传null</td></tr></tbody></table><p>addWorker源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">addWorker</span><span class="params">(Runnable firstTask, <span class="type">boolean</span> core)</span> &#123;</span><br><span class="line">    retry:</span><br><span class="line">        <span class="comment">//检测当前线程池状态</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//包含线程池状态和线程中有效线程数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="comment">//通过高三位获取线程池状态</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程池不处于RUNNABLE状态且现在状态为关闭状态，未传入新任务，阻塞队列不为空 返回false</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//通过低29位计算线程池内有效线程的数量</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);</span><br><span class="line">            <span class="comment">//超过size，则返回false</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//增加工作线程数    </span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            <span class="comment">//再次获取线程池状态和线程中有效线程数量</span></span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerStarted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerAdded</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">Worker</span> <span class="variable">w</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个Worker对象，将新任务放入Worker</span></span><br><span class="line">        w = <span class="keyword">new</span> <span class="title class_">Worker</span>(firstTask);</span><br><span class="line">        <span class="comment">//实例化一个线程</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//加锁</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="comment">//再次检查线程池运行状态</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(ctl.get());</span><br><span class="line">                <span class="comment">//线程池运行状态为RUNNABLE 或者 为已关闭且无新任务</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="literal">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">//检测是否处于活动</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line">                    <span class="comment">//将新任务放入set数组中    </span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    <span class="comment">//添加任务工程    </span></span><br><span class="line">                    workerAdded = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//释放锁</span></span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//启动任务</span></span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//添加失败则加入失败队列</span></span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>addWorker总结：</strong></li></ul><ol><li>检查线程池状态</li><li>新建线程，使用Worker进行包装，放入HashSet数组中，最终真正执行任务的线程就放在Worker，所以新增一个addWorker就是新增一个线程。主要实现复用就是Worker类中的runWorker(this)</li><li>启动线程Start()</li><li>添加失败操作，移除Worker,减少WorkerCount</li></ol><ul><li><strong>worker源码</strong></li></ul><p>worker实际的实现也是Runnbale，通过继承AbstractQueuedSynchronizer,来获取独占锁，所以上面调用start(),实际上也是执行Worker中的run方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Worker</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">        <span class="built_in">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="built_in">this</span>.thread = getThreadFactory().newThread(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Delegates main run loop to outer runWorker  */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        runWorker(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><h1 id="Worker线程执行任务"><a href="#Worker线程执行任务" class="headerlink" title="Worker线程执行任务"></a>Worker线程执行任务</h1><p><img src="/2023/04/12/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%8D%E7%94%A8/2.png"></p><ol><li><strong>runWorker</strong>源码</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">runWorker</span><span class="params">(Worker w)</span> &#123;</span><br><span class="line">    <span class="comment">//获取当前的线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">wt</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">//从Worker中取出新任务</span></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> w.firstTask;</span><br><span class="line">    <span class="comment">//释放Worker</span></span><br><span class="line">    w.firstTask = <span class="literal">null</span>;</span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">completedAbruptly</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//任务不为空</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//上锁，避免被其他线程中断</span></span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="comment">//检查状态如果线程池状态处于中断，则中断线程</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                <span class="comment">//中断当前线程</span></span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//执行beforeExecute</span></span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                <span class="type">Throwable</span> <span class="variable">thrown</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//执行任务</span></span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="literal">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//worker回收</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使线程池复用的核心方法，getTask() 只要不返回null，就会一直执行</p><ol start="2"><li><strong>getTask</strong>源码</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Runnable <span class="title function_">getTask</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">timedOut</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//获取线程池运行状态和线程池内中有效线程池</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="comment">//获取运行状态</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="comment">// 线程不处于RUNNABLE 且（已关闭 或 worker队列为空）</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="comment">//减少工作线程数</span></span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取线程池内有效线程池数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="comment">// 1.allowCoreThreadTimeOut变量默认是false,核心线程即使空闲也不会被销毁</span></span><br><span class="line">        <span class="comment">// 如果为true,核心线程在keepAliveTime内仍空闲则会被销毁。</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">timed</span> <span class="operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">        <span class="comment">//如果运行线程数超过了最大线程数，但是缓存队列已经空了，这时递减worker数量。 </span></span><br><span class="line">　　　　 <span class="comment">// 如果有设置允许线程超时或者线程数量超过了核心线程数量，</span></span><br><span class="line">        <span class="comment">// 并且线程在规定时间内均未poll到任务且队列为空则递减worker数量</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//如果为true，则调用poll方法获取任务，超过keepAliveTime，则会返回null</span></span><br><span class="line">            <span class="comment">//如果为false，则直接调用take方法获取任务，workQueue.offer(command) ,当任务加入时，再被唤醒，返回任务</span></span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>addWorkerFailed源码</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//回滚创建</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addWorkerFailed</span><span class="params">(Worker w)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//新任务不为空</span></span><br><span class="line">        <span class="keyword">if</span> (w != <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">//移除新任务</span></span><br><span class="line">            workers.remove(w);</span><br><span class="line">       <span class="comment">//减少WorkerCount     </span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">        <span class="comment">//其他状态为Terminate</span></span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>tryTerminate源码</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">tryTerminate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//获取线程池状态和线程池中有效线程数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="comment">// 正在运行 或 任务都已经终止 或 处于关闭状态且池和队列不为空 提前退出</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) ||</span><br><span class="line">            runStateAtLeast(c, TIDYING) ||</span><br><span class="line">            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">//工作线程数不为0，则中断空闲的worker</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123; <span class="comment">// Eligible to terminate</span></span><br><span class="line">            interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//获取对象锁</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    terminated();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));</span><br><span class="line">                    termination.signalAll();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else retry on failed CAS</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="原理总结"><a href="#原理总结" class="headerlink" title="原理总结"></a>原理总结</h1><ol><li><p>线程池的优点就是提高对线程的管理，提高资源的利用率，控制线程的数量。</p></li><li><p>在线程池中，线程可以从阻塞队列 中不断 getTask() 新任务来执行，其核心原理在于线程池用Worker对Thread进行了封装，每调用一个 addWorker 就是等于新开一个线程，并不是每次执行任务都会调用 Thread.start() 来创建新线程，而是让每个线程去轮询，在这个轮询中，不停地检查是否还有任务等待被执行，如果有则直接去执行这个任务，也就是调用任务的 run() 方法，把 run() 方法当作和普通方法一样的地位去调用，相当于把每个任务的 run() 方法串联了起来，所以线程数量并不增加。</p></li></ol><ul><li>线程如何复用</li></ul><p>ThreadPoolExecutor 在创建线程时，会将线程封装成工作线程 Worker ,并放入工作线程组中，然后这个 Worker 反复从阻塞队列中拿任务去执行。</p><p>通过取 Worker 的 firstTask 或者通过 getTask 方法从 workQueue 中获取待执行的任务。<br>直接调用 task 的 run 方法来执行具体的任务（而不是新建线程）</p><ul><li>线程如何回收</li></ul><ol><li>获取不到任务时，回收自己</li><li>将worker移出线程池</li><li>线程池状态置为TERMINATED</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  processWorkerExit(w, completedAbruptly);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processWorkerExit</span><span class="params">(Worker w, <span class="type">boolean</span> completedAbruptly)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn&#x27;t adjusted</span></span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">...</span><br><span class="line">        <span class="comment">//将worker移出线程池</span></span><br><span class="line">            completedTaskCount += w.completedTasks;</span><br><span class="line">            workers.remove(w);</span><br><span class="line"><span class="comment">//修改线程池状态</span></span><br><span class="line">        tryTerminate();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">                <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                    min = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                    <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">            &#125;</span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://zyanprocess.github.io/categories/Java/">Java</category>
      
      
      <category domain="http://zyanprocess.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/">线程池</category>
      
      
      <comments>http://zyanprocess.github.io/2023/04/12/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%8D%E7%94%A8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>常用限流算法及其实现</title>
      <link>http://zyanprocess.github.io/2023/04/12/%E5%B8%B8%E7%94%A8%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/</link>
      <guid>http://zyanprocess.github.io/2023/04/12/%E5%B8%B8%E7%94%A8%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/</guid>
      <pubDate>Wed, 12 Apr 2023 06:08:28 GMT</pubDate>
      
      <description>&lt;p&gt;在分布式系统中，应对高并发访问时，缓存、限流、降级是保护系统正常运行的常用方法。当请求量突发暴涨时，如果不加以限制访问，则可能导致整个系统崩溃，服务不可用。同时有一些业务场景，比如短信验证码，或者其它第三方API调用，也需要提供必要的访问限制支持。&lt;/p&gt;
&lt;p&gt;常见的限流算法有令牌桶算法，漏桶算法，与计数器算法。本文主要对三个算法的基本原理及Google Guava包中令牌桶算法的实现&lt;code&gt;RateLimiter&lt;/code&gt;进行介绍，并实现以&lt;code&gt;RateLimiter&lt;/code&gt;为参考的分布式限流实现及计数器限流实现。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>在分布式系统中，应对高并发访问时，缓存、限流、降级是保护系统正常运行的常用方法。当请求量突发暴涨时，如果不加以限制访问，则可能导致整个系统崩溃，服务不可用。同时有一些业务场景，比如短信验证码，或者其它第三方API调用，也需要提供必要的访问限制支持。</p><p>常见的限流算法有令牌桶算法，漏桶算法，与计数器算法。本文主要对三个算法的基本原理及Google Guava包中令牌桶算法的实现<code>RateLimiter</code>进行介绍，并实现以<code>RateLimiter</code>为参考的分布式限流实现及计数器限流实现。</p><span id="more"></span><h1 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h1><p>令牌桶算法的原理就是以一个恒定的速度往桶里放入令牌，每一个请求的处理都需要从桶里先获取一个令牌，当桶里没有令牌时，则请求不会被处理，要么排队等待，要么降级处理，要么直接拒绝服务。当桶里令牌满时，新添加的令牌会被丢弃或拒绝。</p><p>令牌桶算法的处理示意图如下</p><p><img src="/2023/04/12/%E5%B8%B8%E7%94%A8%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/workSpace\Blog\source_posts\常用限流算法及其实现\v2-1118c1c9455d923d4b3c70291b689f7b_720w.png"></p><p>令牌桶算法主要是可以控制请求的平均处理速率，它允许预消费，即可以提前消费令牌，以应对突发请求，但是后面的请求需要为预消费买单（等待更长的时间），以满足请求处理的平均速率是一定的。</p><h1 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h1><p>漏桶算法的原理是水（请求）先进入漏桶中，漏桶以一定的速度出水（处理请求），当水流入速度大于流出速度导致水在桶内逐渐堆积直到桶满时，水会溢出（请求被拒绝）。</p><p>漏桶算法的处理示意图如下</p><p><img src="/2023/04/12/%E5%B8%B8%E7%94%A8%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/workSpace\Blog\source_posts\常用限流算法及其实现\v2-0736dde059726d7fb463c72afdc350e1_720w.png"></p><p>漏桶算法主要是控制请求的处理速率，平滑网络上的突发流量，请求可以以任意速度进入漏桶中，但请求的处理则以恒定的速度进行。</p><h1 id="计数器算法"><a href="#计数器算法" class="headerlink" title="计数器算法"></a>计数器算法</h1><p>计数器算法是限流算法中最简单的一种算法，限制在一个时间窗口内，至多处理多少个请求。比如每分钟最多处理10个请求，则从第一个请求进来的时间为起点，60s的时间窗口内只允许最多处理10个请求。下一个时间窗口又以前一时间窗口过后第一个请求进来的时间为起点。常见的比如一分钟内只能获取一次短信验证码的功能可以通过计数器算法来实现。</p><h1 id="Guava-RateLimiter解析"><a href="#Guava-RateLimiter解析" class="headerlink" title="Guava RateLimiter解析"></a>Guava RateLimiter解析</h1><p>Guava是Google开源的一个工具包，其中的<code>RateLimiter</code>是实现了令牌桶算法的一个限流工具类。在<code>pom.xml</code>中添加guava依赖，即可使用<code>RateLimiter</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>29.0-jre<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如下测试代码示例了<code>RateLimiter</code>的用法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">RateLimiter</span> <span class="variable">rateLimiter</span> <span class="operator">=</span> RateLimiter.create(<span class="number">1</span>); <span class="comment">//创建一个每秒产生一个令牌的令牌桶</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++) &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">waitTime</span> <span class="operator">=</span> rateLimiter.acquire(i); <span class="comment">//一次获取i个令牌</span></span><br><span class="line">        System.out.println(<span class="string">&quot;acquire:&quot;</span> + i + <span class="string">&quot; waitTime:&quot;</span> + waitTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后，输出如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">acquire:1 waitTime:0.0</span><br><span class="line">acquire:2 waitTime:0.997729</span><br><span class="line">acquire:3 waitTime:1.998076</span><br><span class="line">acquire:4 waitTime:3.000303</span><br><span class="line">acquire:5 waitTime:4.000223</span><br></pre></td></tr></table></figure><p>第一次获取一个令牌时，等待0s立即可获取到（这里之所以不需要等待是因为令牌桶的预消费特性），第二次获取两个令牌，等待时间1s，这个1s就是前面获取一个令牌时因为预消费没有等待延到这次来等待的时间，这次获取两个又是预消费，所以下一次获取（取3个时）就要等待这次预消费需要的2s了，依此类推。可见预消费不需要等待的时间都由下一次来买单，以保障一定的平均处理速率（上例为1s一次）。</p><p><code>RateLimiter</code>有两种实现：</p><ol><li>SmoothBursty： 令牌的生成速度恒定。使用 <code>RateLimiter.create(double permitsPerSecond)</code> 创建的是 SmoothBursty 实例。</li><li>SmoothWarmingUp：令牌的生成速度持续提升，直到达到一个稳定的值。WarmingUp，顾名思义就是有一个热身的过程。使用 <code>RateLimiter.create(double permitsPerSecond, long warmupPeriod, TimeUnit unit)</code> 时创建就是 SmoothWarmingUp 实例，其中 warmupPeriod 就是热身达到稳定速度的时间。</li></ol><p>关键属性及方法解析（以 SmoothBursty 为例）</p><ol><li>关键属性</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 桶中当前拥有的令牌数. */</span></span><br><span class="line"><span class="type">double</span> storedPermits;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 桶中最多可以保存多少秒存入的令牌数 */</span></span><br><span class="line"><span class="type">double</span> maxBurstSeconds;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 桶中能存储的最大令牌数，等于storedPermits*maxBurstSeconds. */</span></span><br><span class="line"><span class="type">double</span> maxPermits;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 放入令牌的时间间隔*/</span></span><br><span class="line"><span class="type">double</span> stableIntervalMicros;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 下次可获取令牌的时间点，可以是过去也可以是将来的时间点*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="variable">nextFreeTicketMicros</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br></pre></td></tr></table></figure><ol start="2"><li>关键方法</li></ol><p>调用 <code>RateLimiter.create(double permitsPerSecond)</code> 方法时，创建的是 SmoothBursty 实例，默认设置 maxBurstSeconds 为1s。SleepingStopwatch 是guava中的一个时钟类实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line"><span class="keyword">static</span> RateLimiter <span class="title function_">create</span><span class="params">(<span class="type">double</span> permitsPerSecond, SleepingStopwatch stopwatch)</span> &#123;</span><br><span class="line">        <span class="type">RateLimiter</span> <span class="variable">rateLimiter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmoothBursty</span>(stopwatch, <span class="number">1.0</span> <span class="comment">/* maxBurstSeconds */</span>);</span><br><span class="line">        rateLimiter.setRate(permitsPerSecond);</span><br><span class="line">        <span class="keyword">return</span> rateLimiter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SmoothBursty(SleepingStopwatch stopwatch, <span class="type">double</span> maxBurstSeconds) &#123;</span><br><span class="line">    <span class="built_in">super</span>(stopwatch);</span><br><span class="line">    <span class="built_in">this</span>.maxBurstSeconds = maxBurstSeconds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并通过调用 <code>SmoothBursty.doSetRate(double, long)</code> 方法进行初始化，该方法中:</p><ol><li>调用 <code>resync(nowMicros)</code> 对 storedPermits 与 nextFreeTicketMicros 进行了调整——如果当前时间晚于 nextFreeTicketMicros，则计算这段时间内产生的令牌数，累加到 storedPermits 上，并更新下次可获取令牌时间 nextFreeTicketMicros 为当前时间。</li><li>计算 stableIntervalMicros 的值，1/permitsPerSecond。</li><li>调用 <code>doSetRate(double, double)</code> 方法计算 maxPermits 值（maxBurstSeconds*permitsPerSecond），并根据旧的 maxPermits 值对 storedPermits 进行调整。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">doSetRate</span><span class="params">(<span class="type">double</span> permitsPerSecond, <span class="type">long</span> nowMicros)</span> &#123;</span><br><span class="line">        resync(nowMicros);</span><br><span class="line">        <span class="type">double</span> <span class="variable">stableIntervalMicros</span> <span class="operator">=</span> SECONDS.toMicros(<span class="number">1L</span>) / permitsPerSecond;</span><br><span class="line">        <span class="built_in">this</span>.stableIntervalMicros = stableIntervalMicros;</span><br><span class="line">        doSetRate(permitsPerSecond, stableIntervalMicros);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Updates &#123;<span class="doctag">@code</span> storedPermits&#125; and &#123;<span class="doctag">@code</span> nextFreeTicketMicros&#125; based on the current time. */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">resync</span><span class="params">(<span class="type">long</span> nowMicros)</span> &#123;</span><br><span class="line">        <span class="comment">// if nextFreeTicket is in the past, resync to now</span></span><br><span class="line">        <span class="keyword">if</span> (nowMicros &gt; nextFreeTicketMicros) &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">newPermits</span> <span class="operator">=</span> (nowMicros - nextFreeTicketMicros) / coolDownIntervalMicros();</span><br><span class="line">        storedPermits = min(maxPermits, storedPermits + newPermits);</span><br><span class="line">        nextFreeTicketMicros = nowMicros;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">doSetRate</span><span class="params">(<span class="type">double</span> permitsPerSecond, <span class="type">double</span> stableIntervalMicros)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">oldMaxPermits</span> <span class="operator">=</span> <span class="built_in">this</span>.maxPermits;</span><br><span class="line">        maxPermits = maxBurstSeconds * permitsPerSecond;</span><br><span class="line">        <span class="keyword">if</span> (oldMaxPermits == Double.POSITIVE_INFINITY) &#123;</span><br><span class="line">                <span class="comment">// if we don&#x27;t special-case this, we would get storedPermits == NaN, below</span></span><br><span class="line">                storedPermits = maxPermits;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                storedPermits =</span><br><span class="line">                        (oldMaxPermits == <span class="number">0.0</span>)</span><br><span class="line">                                ? <span class="number">0.0</span> <span class="comment">// initial state</span></span><br><span class="line">                                : storedPermits * maxPermits / oldMaxPermits;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 <code>acquire(int)</code> 方法获取指定数量的令牌时，</p><ol><li>调用 <code>reserve(int)</code> 方法，该方法最终调用 <code>reserveEarliestAvailable(int, long)</code> 来更新下次可取令牌时间点与当前存储的令牌数，并返回本次可取令牌的时间点，根据该时间点计算需要等待的时间</li><li>阻塞等待1中返回的等待时间</li><li>返回等待的时间（秒）</li></ol><p>源码如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 获取指定数量（permits）的令牌，阻塞直到获取到令牌，返回等待的时间*/</span></span><br><span class="line"><span class="meta">@CanIgnoreReturnValue</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">microsToWait</span> <span class="operator">=</span> reserve(<span class="keyword">permits</span>);</span><br><span class="line">        stopwatch.sleepMicrosUninterruptibly(microsToWait);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span> * microsToWait / SECONDS.toMicros(<span class="number">1L</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="title function_">reserve</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>)</span> &#123;</span><br><span class="line">        checkPermits(<span class="keyword">permits</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (mutex()) &#123;</span><br><span class="line">                <span class="keyword">return</span> reserveAndGetWaitLength(<span class="keyword">permits</span>, stopwatch.readMicros());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 返回需要等待的时间*/</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="title function_">reserveAndGetWaitLength</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>, <span class="type">long</span> nowMicros)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">momentAvailable</span> <span class="operator">=</span> reserveEarliestAvailable(<span class="keyword">permits</span>, nowMicros);</span><br><span class="line">        <span class="keyword">return</span> max(momentAvailable - nowMicros, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 针对此次需要获取的令牌数更新下次可取令牌时间点与存储的令牌数，返回本次可取令牌的时间点*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="title function_">reserveEarliestAvailable</span><span class="params">(<span class="type">int</span> requiredPermits, <span class="type">long</span> nowMicros)</span> &#123;</span><br><span class="line">        resync(nowMicros); <span class="comment">// 更新当前数据</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">returnValue</span> <span class="operator">=</span> nextFreeTicketMicros;</span><br><span class="line">        <span class="type">double</span> <span class="variable">storedPermitsToSpend</span> <span class="operator">=</span> min(requiredPermits, <span class="built_in">this</span>.storedPermits); <span class="comment">// 本次可消费的令牌数</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">freshPermits</span> <span class="operator">=</span> requiredPermits - storedPermitsToSpend; <span class="comment">// 需要新增的令牌数</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">waitMicros</span> <span class="operator">=</span></span><br><span class="line">                storedPermitsToWaitTime(<span class="built_in">this</span>.storedPermits, storedPermitsToSpend)</span><br><span class="line">                        + (<span class="type">long</span>) (freshPermits * stableIntervalMicros); <span class="comment">// 需要等待的时间</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.nextFreeTicketMicros = LongMath.saturatedAdd(nextFreeTicketMicros, waitMicros); <span class="comment">// 更新下次可取令牌的时间点</span></span><br><span class="line">        <span class="built_in">this</span>.storedPermits -= storedPermitsToSpend; <span class="comment">// 更新当前存储的令牌数</span></span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>acquire(int)</code> 方法是获取不到令牌时一直阻塞，直到获取到令牌，<code>tryAcquire(int,long,TimeUnit)</code> 方法则是在指定超时时间内尝试获取令牌，如果获取到或超时时间到则返回是否获取成功</p><ol><li>先判断是否能在指定超时时间内获取到令牌，通过 <code>nextFreeTicketMicros &lt;= timeoutMicros + nowMicros</code> 是否为true来判断，即可取令牌时间早于当前时间加超时时间则可取（预消费的特性），否则不可获取。</li><li>如果不可获取，立即返回false。</li><li>如果可获取，则调用 <code>reserveAndGetWaitLength(permits, nowMicros)</code> 来更新下次可取令牌时间点与当前存储的令牌数，返回等待时间（逻辑与前面相同），并阻塞等待相应的时间，返回true。</li></ol><p>源码如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>, <span class="type">long</span> timeout, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">timeoutMicros</span> <span class="operator">=</span> max(unit.toMicros(timeout), <span class="number">0</span>);</span><br><span class="line">        checkPermits(<span class="keyword">permits</span>);</span><br><span class="line">        <span class="type">long</span> microsToWait;</span><br><span class="line">        <span class="keyword">synchronized</span> (mutex()) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">nowMicros</span> <span class="operator">=</span> stopwatch.readMicros();</span><br><span class="line">                <span class="keyword">if</span> (!canAcquire(nowMicros, timeoutMicros)) &#123; <span class="comment">//判断是否能在超时时间内获取指定数量的令牌</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        microsToWait = reserveAndGetWaitLength(<span class="keyword">permits</span>, nowMicros);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stopwatch.sleepMicrosUninterruptibly(microsToWait);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">canAcquire</span><span class="params">(<span class="type">long</span> nowMicros, <span class="type">long</span> timeoutMicros)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queryEarliestAvailable(nowMicros) - timeoutMicros &lt;= nowMicros; <span class="comment">//只要可取时间小于当前时间+超时时间，则可获取（可预消费的特性！）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="title function_">queryEarliestAvailable</span><span class="params">(<span class="type">long</span> nowMicros)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nextFreeTicketMicros;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是 SmoothBursty 实现的基本处理流程。注意两点：</p><ol><li>RateLimiter 通过限制后面请求的等待时间，来支持一定程度的突发请求——预消费的特性。</li><li>RateLimiter 令牌桶的实现并不是起一个线程不断往桶里放令牌，而是以一种延迟计算的方式（参考<code>resync</code>函数），在每次获取令牌之前计算该段时间内可以产生多少令牌，将产生的令牌加入令牌桶中并更新数据来实现，比起一个线程来不断往桶里放令牌高效得多。（想想如果需要针对每个用户限制某个接口的访问，则针对每个用户都得创建一个RateLimiter，并起一个线程来控制令牌存放的话，如果在线用户数有几十上百万，起线程来控制是一件多么恐怖的事情）</li></ol><p>Guava 的 RateLimiter 是令牌桶算法的一种实现，但 RateLimiter 只适用于单机应用，在分布式环境下就不适用了。</p><h1 id="限速控制"><a href="#限速控制" class="headerlink" title="限速控制"></a>限速控制</h1><h2 id="令牌桶模型"><a href="#令牌桶模型" class="headerlink" title="令牌桶模型"></a>令牌桶模型</h2><p>首先定义令牌桶模型，与RateLimiter中类似，包括几个关键属性与关键方法。其中关键属性定义如下，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisPermits</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大存储令牌数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> maxPermits;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前存储令牌数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> storedPermits;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加令牌时间间隔/毫秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> intervalMillis;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下次请求可以获取令牌的时间，可以是过去（令牌积累）也可以是将来的时间（令牌预消费）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> nextFreeTicketMillis;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisPermits</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键方法定义与RateLimiter也大同小异</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建Redis令牌数据模型</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> permitsPerSecond     每秒放入的令牌数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maxBurstSeconds      maxPermits由此字段计算，最大存储maxBurstSeconds秒生成的令牌</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nextFreeTicketMillis 下次请求可以获取令牌的起始时间，默认当前系统时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">RedisPermits</span><span class="params">(<span class="type">double</span> permitsPerSecond, <span class="type">double</span> maxBurstSeconds, Long nextFreeTicketMillis)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.maxPermits = permitsPerSecond * maxBurstSeconds;</span><br><span class="line">    <span class="built_in">this</span>.storedPermits = maxPermits;</span><br><span class="line">    <span class="built_in">this</span>.intervalMillis = TimeUnit.SECONDS.toMillis(<span class="number">1</span>) / permitsPerSecond;</span><br><span class="line">    <span class="built_in">this</span>.nextFreeTicketMillis = nextFreeTicketMillis;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于当前时间，若当前时间晚于nextFreeTicketMicros，则计算该段时间内可以生成多少令牌，将生成的令牌加入令牌桶中并更新数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">resync</span><span class="params">(<span class="type">long</span> nowMillis)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nowMillis &gt; nextFreeTicketMillis) &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">newPermits</span> <span class="operator">=</span> (nowMillis - nextFreeTicketMillis) / intervalMillis;</span><br><span class="line">        storedPermits = Math.min(maxPermits, storedPermits + newPermits);</span><br><span class="line">        nextFreeTicketMillis = nowMillis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">reserveAndGetWaitLength</span><span class="params">(<span class="type">long</span> nowMillis, <span class="type">int</span> <span class="keyword">permits</span>)</span> &#123;</span><br><span class="line">    resync(nowMillis);</span><br><span class="line">    <span class="type">double</span> <span class="variable">storedPermitsToSpend</span> <span class="operator">=</span> Math.min(<span class="keyword">permits</span>, storedPermits); <span class="comment">// 可以消耗的令牌数</span></span><br><span class="line">    <span class="type">double</span> <span class="variable">freshPermits</span> <span class="operator">=</span> <span class="keyword">permits</span> - storedPermitsToSpend; <span class="comment">// 需要等待的令牌数</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">waitMillis</span> <span class="operator">=</span> (<span class="type">long</span>) (freshPermits * intervalMillis); <span class="comment">// 需要等待的时间</span></span><br><span class="line"></span><br><span class="line">    nextFreeTicketMillis = LongMath.saturatedAdd(nextFreeTicketMillis, waitMillis);</span><br><span class="line">    storedPermits -= storedPermitsToSpend;</span><br><span class="line">    <span class="keyword">return</span> waitMillis;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canAcquire</span><span class="params">(<span class="type">long</span> nowMillis, <span class="type">int</span> <span class="keyword">permits</span>, <span class="type">long</span> timeoutMillis)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> queryEarliestAvailable(nowMillis, <span class="keyword">permits</span>) &lt;= timeoutMillis;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定数量令牌数可用的等待时间</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> permits 需保留的令牌数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定数量令牌可用的等待时间，如果为0或负数，表述当前可用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="title function_">queryEarliestAvailable</span><span class="params">(<span class="type">long</span> nowMillis, <span class="type">int</span> <span class="keyword">permits</span>)</span> &#123;</span><br><span class="line">    resync(nowMillis);</span><br><span class="line">    <span class="type">double</span> <span class="variable">storedPermitsToSpend</span> <span class="operator">=</span> Math.min(<span class="keyword">permits</span>, storedPermits); <span class="comment">// 可以消耗的令牌数</span></span><br><span class="line">    <span class="type">double</span> <span class="variable">freshPermits</span> <span class="operator">=</span> <span class="keyword">permits</span> - storedPermitsToSpend; <span class="comment">// 需要等待的令牌数</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">waitMillis</span> <span class="operator">=</span> (<span class="type">long</span>) (freshPermits * intervalMillis); <span class="comment">// 需要等待的时间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> LongMath.saturatedAdd(nextFreeTicketMillis - nowMillis, waitMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="令牌控制类"><a href="#令牌控制类" class="headerlink" title="令牌控制类"></a>令牌控制类</h2><p>Guava RateLimiter中的控制都在RateLimiter及其子类中（如SmoothBursty），本处涉及到分布式环境下的同步，因此将其解耦，令牌桶模型存储于Redis中，对其同步操作的控制放置在如下控制类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 限速控制</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> ronwxy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/6/24 17:41</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisRateLimiter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOCK_KEY_SUFFIX</span> <span class="operator">=</span> <span class="string">&quot;:lock&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PermitsRedisTemplate permitsRedisTemplate;</span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="keyword">private</span> DistributedLock lock;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> permitsPerSecond;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> maxBurstSeconds;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> expire;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisRateLimiter</span><span class="params">(PermitsRedisTemplate permitsRedisTemplate, StringRedisTemplate stringRedisTemplate, DistributedLock lock, <span class="type">double</span> permitsPerSecond,</span></span><br><span class="line"><span class="params">                            <span class="type">double</span> maxBurstSeconds, <span class="type">long</span> expire)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.permitsRedisTemplate = permitsRedisTemplate;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">        <span class="built_in">this</span>.lock = lock;</span><br><span class="line">        <span class="built_in">this</span>.permitsPerSecond = permitsPerSecond;</span><br><span class="line">        <span class="built_in">this</span>.maxBurstSeconds = maxBurstSeconds;</span><br><span class="line">        <span class="built_in">this</span>.expire = expire;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取一个令牌，阻塞一直到获取令牌，返回阻塞等待时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> time 阻塞等待时间/毫秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">acquire</span><span class="params">(String key)</span> <span class="keyword">throws</span> IllegalArgumentException &#123;</span><br><span class="line">        <span class="keyword">return</span> acquire(key, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定数量的令牌，如果令牌数不够，则一直阻塞，返回阻塞等待的时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> permits 需要获取的令牌数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> time 等待的时间/毫秒</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException tokens值不能为负数或零</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">acquire</span><span class="params">(String key, <span class="type">int</span> <span class="keyword">permits</span>)</span> <span class="keyword">throws</span> IllegalArgumentException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">millisToWait</span> <span class="operator">=</span> reserve(key, <span class="keyword">permits</span>);</span><br><span class="line">        log.info(<span class="string">&quot;acquire &#123;&#125; permits for key[&#123;&#125;], waiting for &#123;&#125;ms&quot;</span>, <span class="keyword">permits</span>, key, millisToWait);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(millisToWait);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;Interrupted when trying to acquire &#123;&#125; permits for key[&#123;&#125;]&quot;</span>, <span class="keyword">permits</span>, key, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> millisToWait;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在指定时间内获取一个令牌，如果获取不到则一直阻塞，直到超时</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout 最大等待时间（超时时间），为0则不等待立即返回</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit    时间单元</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 获取到令牌则true，否则false</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(String key, <span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> IllegalArgumentException &#123;</span><br><span class="line">        <span class="keyword">return</span> tryAcquire(key, <span class="number">1</span>, timeout, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在指定时间内获取指定数量的令牌，如果在指定时间内获取不到指定数量的令牌，则直接返回false，</span></span><br><span class="line"><span class="comment">     * 否则阻塞直到能获取到指定数量的令牌</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> permits 需要获取的令牌数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout 最大等待时间（超时时间）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit    时间单元</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果在指定时间内能获取到指定令牌数，则true,否则false</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException tokens为负数或零，抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(String key, <span class="type">int</span> <span class="keyword">permits</span>, <span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> IllegalArgumentException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">timeoutMillis</span> <span class="operator">=</span> Math.max(unit.toMillis(timeout), <span class="number">0</span>);</span><br><span class="line">        checkPermits(<span class="keyword">permits</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> millisToWait;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">locked</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            locked = lock.lock(key + LOCK_KEY_SUFFIX, WebUtil.getRequestId(), <span class="number">60</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span> (locked) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">nowMillis</span> <span class="operator">=</span> getNowMillis();</span><br><span class="line">                <span class="type">RedisPermits</span> <span class="variable">permit</span> <span class="operator">=</span> getPermits(key, nowMillis);</span><br><span class="line">                <span class="keyword">if</span> (!permit.canAcquire(nowMillis, <span class="keyword">permits</span>, timeoutMillis)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    millisToWait = permit.reserveAndGetWaitLength(nowMillis, <span class="keyword">permits</span>);</span><br><span class="line">                    permitsRedisTemplate.opsForValue().set(key, permit, expire, TimeUnit.SECONDS);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//超时获取不到锁，也返回false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (locked) &#123;</span><br><span class="line">                lock.unLock(key + LOCK_KEY_SUFFIX, WebUtil.getRequestId());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (millisToWait &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(millisToWait);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保留指定的令牌数待用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> permits 需保留的令牌数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> time 令牌可用的等待时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException tokens不能为负数或零</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">reserve</span><span class="params">(String key, <span class="type">int</span> <span class="keyword">permits</span>)</span> <span class="keyword">throws</span> IllegalArgumentException &#123;</span><br><span class="line">        checkPermits(<span class="keyword">permits</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock(key + LOCK_KEY_SUFFIX, WebUtil.getRequestId(), <span class="number">60</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="type">long</span> <span class="variable">nowMillis</span> <span class="operator">=</span> getNowMillis();</span><br><span class="line">            <span class="type">RedisPermits</span> <span class="variable">permit</span> <span class="operator">=</span> getPermits(key, nowMillis);</span><br><span class="line">            <span class="type">long</span> <span class="variable">waitMillis</span> <span class="operator">=</span> permit.reserveAndGetWaitLength(nowMillis, <span class="keyword">permits</span>);</span><br><span class="line">            permitsRedisTemplate.opsForValue().set(key, permit, expire, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">return</span> waitMillis;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unLock(key + LOCK_KEY_SUFFIX, WebUtil.getRequestId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取令牌桶</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> RedisPermits <span class="title function_">getPermits</span><span class="params">(String key, <span class="type">long</span> nowMillis)</span> &#123;</span><br><span class="line">        <span class="type">RedisPermits</span> <span class="variable">permit</span> <span class="operator">=</span> permitsRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="keyword">if</span> (permit == <span class="literal">null</span>) &#123;</span><br><span class="line">            permit = <span class="keyword">new</span> <span class="title class_">RedisPermits</span>(permitsPerSecond, maxBurstSeconds, nowMillis);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> permit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取redis服务器时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">getNowMillis</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">luaScript</span> <span class="operator">=</span> <span class="string">&quot;return redis.call(&#x27;time&#x27;)&quot;</span>; <span class="comment">//&quot;TIME&quot;;</span></span><br><span class="line">        DefaultRedisScript&lt;List&gt; redisScript = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;(luaScript, List.class);</span><br><span class="line">        List&lt;String&gt; now = (List&lt;String&gt;)stringRedisTemplate.execute(redisScript, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span> now == <span class="literal">null</span> ? System.currentTimeMillis() : Long.valueOf(now.get(<span class="number">0</span>))*<span class="number">1000</span>+Long.valueOf(now.get(<span class="number">1</span>))/<span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(Locale.ROOT, <span class="string">&quot;RateLimiter[rate=%3.1fqps]&quot;</span>, permitsPerSecond);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkPermits</span><span class="params">(<span class="type">long</span> <span class="keyword">permits</span>)</span> <span class="keyword">throws</span> IllegalArgumentException &#123;</span><br><span class="line">        Preconditions.checkArgument(<span class="keyword">permits</span> &gt; <span class="number">0</span>, <span class="string">&quot;Requested permits (%s) must be positive: &quot;</span>, <span class="keyword">permits</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ol><li>acquire 是阻塞方法，如果没有可用的令牌，则一直阻塞直到获取到令牌。</li><li>tryAcquire 则是非阻塞方法，如果在指定超时时间内获取不到指定数量的令牌，则直接返回false，不阻塞等待。</li><li>getNowMillis 获取Redis服务器时间，避免业务服务器时间不一致导致的问题，如果业务服务器能保障时间同步，则可从本地获取提高效率。</li></ol><h2 id="令牌桶控制工厂类"><a href="#令牌桶控制工厂类" class="headerlink" title="令牌桶控制工厂类"></a>令牌桶控制工厂类</h2><p>工厂类负责管理令牌桶控制类，将其缓存在本地，这里使用了Guava中的Cache，一方面避免每次都新建控制类提高效率，另一方面通过控制缓存的最大容量来避免像用户粒度的限流占用过多的内存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisRateLimiterFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PermitsRedisTemplate permitsRedisTemplate;</span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="keyword">private</span> DistributedLock distributedLock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Cache&lt;String, RedisRateLimiter&gt; cache = CacheBuilder.newBuilder()</span><br><span class="line">            .initialCapacity(<span class="number">100</span>)  <span class="comment">//初始大小</span></span><br><span class="line">            .maximumSize(<span class="number">10000</span>) <span class="comment">// 缓存的最大容量</span></span><br><span class="line">            .expireAfterAccess(<span class="number">5</span>, TimeUnit.MINUTES) <span class="comment">// 缓存在最后一次访问多久之后失效</span></span><br><span class="line">            .concurrencyLevel(Runtime.getRuntime().availableProcessors()) <span class="comment">// 设置并发级别</span></span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisRateLimiterFactory</span><span class="params">(PermitsRedisTemplate permitsRedisTemplate, StringRedisTemplate stringRedisTemplate, DistributedLock distributedLock)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.permitsRedisTemplate = permitsRedisTemplate;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">        <span class="built_in">this</span>.distributedLock = distributedLock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建RateLimiter</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key              Redis key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> permitsPerSecond 每秒放入的令牌数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxBurstSeconds  最大存储maxBurstSeconds秒生成的令牌</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expire           该令牌桶的redis tty/秒</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> RateLimiter</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> RedisRateLimiter <span class="title function_">build</span><span class="params">(String key, <span class="type">double</span> permitsPerSecond, <span class="type">double</span> maxBurstSeconds, <span class="type">int</span> expire)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cache.getIfPresent(key) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cache.getIfPresent(key) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    cache.put(key, <span class="keyword">new</span> <span class="title class_">RedisRateLimiter</span>(permitsRedisTemplate, stringRedisTemplate, distributedLock, permitsPerSecond,</span><br><span class="line">                            maxBurstSeconds, expire));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cache.getIfPresent(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注解支持"><a href="#注解支持" class="headerlink" title="注解支持"></a>注解支持</h2><p>定义注解 @RateLimit 如下，表示以每秒rate的速率放置令牌，最多保留burst秒的令牌，取令牌的超时时间为timeout，limitType用于控制key类型，目前支持：</p><ol><li>IP, 根据客户端IP限流</li><li>USER, 根据用户限流，对于Spring Security可从SecurityContextHolder中获取当前用户信息，如userId</li><li>METHOD, 根据方法名全局限流，className.methodName，注意避免同时对同一个类中的同名方法做限流控制，否则需要修改获取key的逻辑</li><li>CUSTOM，自定义，支持表达式解析，如#{id}, #{user.id}</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RateLimit &#123;</span><br><span class="line">    String <span class="title function_">key</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    String <span class="title function_">prefix</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;rateLimit:&quot;</span>; <span class="comment">//key前缀</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">expire</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">60</span>; <span class="comment">// 表示令牌桶模型RedisPermits redis key的过期时间/秒</span></span><br><span class="line">    <span class="type">double</span> <span class="title function_">rate</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">1.0</span>; <span class="comment">// permitsPerSecond值</span></span><br><span class="line">    <span class="type">double</span> <span class="title function_">burst</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">1.0</span>; <span class="comment">// maxBurstSeconds值</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">timeout</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>; <span class="comment">// 超时时间/秒</span></span><br><span class="line">    LimitType <span class="title function_">limitType</span><span class="params">()</span> <span class="keyword">default</span> LimitType.METHOD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过切面的前置增强来为添加了 @RateLimit 注解的方法提供限流控制，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisLimitAspect</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LIMIT_MESSAGE</span> <span class="operator">=</span> <span class="string">&quot;您的访问过于频繁，请稍后重试&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RedisCountLimiter redisCountLimiter;</span><br><span class="line">    <span class="keyword">private</span> RedisRateLimiterFactory redisRateLimiterFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisLimitAspect</span><span class="params">(RedisCountLimiter redisCountLimiter, RedisRateLimiterFactory redisRateLimiterFactory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.redisCountLimiter = redisCountLimiter;</span><br><span class="line">        <span class="built_in">this</span>.redisRateLimiterFactory = redisRateLimiterFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(value = &quot;@annotation(rateLimit)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rateLimit</span><span class="params">(JoinPoint  point, RateLimit rateLimit)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> getKey(point, rateLimit.limitType(), rateLimit.key(), rateLimit.prefix());</span><br><span class="line">        <span class="type">RedisRateLimiter</span> <span class="variable">redisRateLimiter</span> <span class="operator">=</span> redisRateLimiterFactory.build(key, rateLimit.rate(), rateLimit.burst(), rateLimit.expire());</span><br><span class="line">        <span class="keyword">if</span>(!redisRateLimiter.tryAcquire(key, rateLimit.timeout(), TimeUnit.SECONDS))&#123;</span><br><span class="line">            ExceptionUtil.rethrowClientSideException(LIMIT_MESSAGE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getKey</span><span class="params">(JoinPoint  point, LimitType limitType, String originKey, String prefix)</span> &#123;</span><br><span class="line">        String key;</span><br><span class="line">        <span class="keyword">switch</span> (limitType) &#123;</span><br><span class="line">            <span class="keyword">case</span> IP:</span><br><span class="line">                key = WebUtil.getIP();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> USER:</span><br><span class="line">                <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> SecurityUtil.getUserId();</span><br><span class="line">                <span class="keyword">if</span>(userId == <span class="literal">null</span>) &#123;</span><br><span class="line">                    ExceptionUtil.rethrowClientSideException(<span class="string">&quot;获取不到用户信息&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                key = String.valueOf(userId);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> METHOD:</span><br><span class="line">                key = ((Class) point.getTarget()).getName() + <span class="string">&quot;:&quot;</span> + ((MethodSignature) point.getSignature()).getMethod().getName();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CUSTOM:</span><br><span class="line">                key = String.valueOf(resolve(point, originKey));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                key = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(key)) &#123;</span><br><span class="line">            ExceptionUtil.rethrowClientSideException(<span class="string">&quot;Key不能为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prefix + key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">resolve</span><span class="params">(JoinPoint joinPoint, String placeholder)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(placeholder)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (placeholder.matches(<span class="string">&quot;#\\&#123;\\D*\\&#125;&quot;</span>)) &#123;<span class="comment">// 匹配上#&#123;&#125;,则把内容当作变量</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">param</span> <span class="operator">=</span> placeholder.replaceAll(<span class="string">&quot;#\\&#123;&quot;</span>, <span class="string">&quot;&quot;</span>).replaceAll(<span class="string">&quot;\\&#125;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (param.contains(<span class="string">&quot;.&quot;</span>)) &#123; <span class="comment">// 多层引用</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    value = complexResolve(joinPoint, param);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;fail to resolve value for &#123;&#125;&quot;</span>, param, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                value = simpleResolve(joinPoint, param);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            value = placeholder;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 多层引用参数解析值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> placeholder</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object <span class="title function_">complexResolve</span><span class="params">(JoinPoint joinPoint, String placeholder)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">MethodSignature</span> <span class="variable">methodSignature</span> <span class="operator">=</span> (MethodSignature) joinPoint.getSignature();</span><br><span class="line">        String[] names = methodSignature.getParameterNames();</span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        String[] params = placeholder.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; names.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (params[<span class="number">0</span>].equals(names[i])) &#123;</span><br><span class="line">                <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> args[i];</span><br><span class="line">                <span class="type">Method</span> <span class="variable">getMethod</span> <span class="operator">=</span> obj.getClass().getDeclaredMethod(getMethodName(params[<span class="number">1</span>]), <span class="literal">null</span>);</span><br><span class="line">                <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> getMethod.invoke(args[i]);</span><br><span class="line">                <span class="keyword">return</span> getValue(value, <span class="number">1</span>, params);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 简单参数获取值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> placeholder</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object <span class="title function_">simpleResolve</span><span class="params">(JoinPoint joinPoint, String placeholder)</span> &#123;</span><br><span class="line">        <span class="type">MethodSignature</span> <span class="variable">methodSignature</span> <span class="operator">=</span> (MethodSignature) joinPoint.getSignature();</span><br><span class="line">        String[] names = methodSignature.getParameterNames();</span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; names.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (placeholder.equals(names[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> args[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object <span class="title function_">getValue</span><span class="params">(Object obj, <span class="type">int</span> index, String[] params)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="literal">null</span> &amp;&amp; index &lt; params.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> obj.getClass().getDeclaredMethod(getMethodName(params[index + <span class="number">1</span>]), <span class="literal">null</span>);</span><br><span class="line">            obj = method.invoke(obj);</span><br><span class="line">            getValue(obj, index + <span class="number">1</span>, params);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getMethodName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;get&quot;</span> + StringUtils.capitalize(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="限量控制"><a href="#限量控制" class="headerlink" title="限量控制"></a>限量控制</h1><h2 id="限量控制类"><a href="#限量控制类" class="headerlink" title="限量控制类"></a>限量控制类</h2><p>限制一个时间窗口内的访问量，可使用计数器算法，借助Lua脚本执行的原子性来实现。</p><p>Lua脚本逻辑：</p><ol><li>以需要控制的对象为key（如方法，用户ID，或IP等），当前访问次数为Value，时间窗口值为缓存的过期时间</li><li>如果key存在则将其增1，判断当前值是否大于访问量限制值，如果大于则返回0，表示该时间窗口内已达访问量上限，如果小于则返回1表示允许访问</li><li>如果key不存在，则将其初始化为1，并设置过期时间，返回1表示允许访问</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisCountLimiter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LUA_SCRIPT</span> <span class="operator">=</span> <span class="string">&quot;local c \nc = redis.call(&#x27;get&#x27;,KEYS[1]) \nif c and redis.call(&#x27;incr&#x27;,KEYS[1]) &gt; tonumber(ARGV[1]) then return 0 end&quot;</span></span><br><span class="line">            + <span class="string">&quot; \nif c then return 1 else \nredis.call(&#x27;set&#x27;, KEYS[1], 1) \nredis.call(&#x27;expire&#x27;, KEYS[1], tonumber(ARGV[2])) \nreturn 1 end&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SUCCESS_RESULT</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">FAIL_RESULT</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisCountLimiter</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否允许访问</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key redis key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> limit 限制次数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expire 时间段/秒</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 获取成功true，否则false</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(String key, <span class="type">int</span> limit, <span class="type">int</span> expire)</span> <span class="keyword">throws</span> IllegalArgumentException &#123;</span><br><span class="line">        RedisScript&lt;Number&gt; redisScript = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;(LUA_SCRIPT, Number.class);</span><br><span class="line">        <span class="type">Number</span> <span class="variable">result</span> <span class="operator">=</span> stringRedisTemplate.execute(redisScript, Collections.singletonList(key), String.valueOf(limit), String.valueOf(expire));</span><br><span class="line">        <span class="keyword">if</span>(result != <span class="literal">null</span> &amp;&amp; result.intValue() == SUCCESS_RESULT) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注解支持-1"><a href="#注解支持-1" class="headerlink" title="注解支持"></a>注解支持</h2><p>定义注解 @CountLimit 如下，表示在period时间窗口内，最多允许访问limit次，limitType用于控制key类型，取值与 @RateLimit 同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CountLimit &#123;</span><br><span class="line">    String <span class="title function_">key</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    String <span class="title function_">prefix</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;countLimit:&quot;</span>; <span class="comment">//key前缀</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">limit</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">1</span>;  <span class="comment">// expire时间段内限制访问次数</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">period</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">1</span>; <span class="comment">// 表示时间段/秒</span></span><br><span class="line">    LimitType <span class="title function_">limitType</span><span class="params">()</span> <span class="keyword">default</span> LimitType.METHOD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样采用前值增强来为添加了 @CountLimit 注解的方法提供限流控制，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(value = &quot;@annotation(countLimit)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countLimit</span><span class="params">(JoinPoint  point, CountLimit countLimit)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> getKey(point, countLimit.limitType(), countLimit.key(), countLimit.prefix());</span><br><span class="line">    <span class="keyword">if</span> (!redisCountLimiter.tryAcquire(key, countLimit.limit(), countLimit.period())) &#123;</span><br><span class="line">        ExceptionUtil.rethrowClientSideException(LIMIT_MESSAGE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://zyanprocess.github.io/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/">后端开发</category>
      
      
      <category domain="http://zyanprocess.github.io/tags/%E9%99%90%E6%B5%81/">限流</category>
      
      
      <comments>http://zyanprocess.github.io/2023/04/12/%E5%B8%B8%E7%94%A8%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Nginx</title>
      <link>http://zyanprocess.github.io/2023/04/10/Nginx/</link>
      <guid>http://zyanprocess.github.io/2023/04/10/Nginx/</guid>
      <pubDate>Mon, 10 Apr 2023 07:48:08 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;什么是Nginx&quot;&gt;&lt;a href=&quot;#什么是Nginx&quot; class=&quot;headerlink&quot; title=&quot;什么是Nginx&quot;&gt;&lt;/a&gt;什么是Nginx&lt;/h1&gt;&lt;p&gt;Nginx同Apache一样都是Web服务器，但是Nginx更加轻量级，它的内存占用少，启动快，并发能力强。Nginx可以作为反向代理服务器使用，支持IMAP/POP3/SMTP服务。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="什么是Nginx"><a href="#什么是Nginx" class="headerlink" title="什么是Nginx"></a>什么是Nginx</h1><p>Nginx同Apache一样都是Web服务器，但是Nginx更加轻量级，它的内存占用少，启动快，并发能力强。Nginx可以作为反向代理服务器使用，支持IMAP/POP3/SMTP服务。</p><span id="more"></span><h1 id="Nginx特点"><a href="#Nginx特点" class="headerlink" title="Nginx特点"></a>Nginx特点</h1><ol><li><strong>内存占用少</strong>：10000个非活跃的HTTP Keep-Alive连接在Nginx中仅损耗2.5MB内存。</li><li><strong>高并发</strong>：单机支持10万以上的并发连接。</li><li><strong>跨平台</strong></li><li><strong>扩展性好</strong></li><li><strong>安装使用简单</strong></li></ol><h1 id="Nginx的功能"><a href="#Nginx的功能" class="headerlink" title="Nginx的功能"></a>Nginx的功能</h1><h2 id="静态资源服务器"><a href="#静态资源服务器" class="headerlink" title="静态资源服务器"></a>静态资源服务器</h2><p>Nginx可以将服务器上的静态文件缓存下来，通过HTTP协议展现给客户端。因此，我们可以使用Nginx搭建静态资源服务器。使用gzip压缩静态资源减少网络传输。</p><p>当客户端第一次请求静态资源的时候，会从服务器直接返回，Nginx同时也会缓存一份静态资源。如果后续客户端请求同样的静态资源，只要对应的缓存未被清理并且没有过期，就可以直接从Nginx缓存中取出返回给客户端。</p><p><img src="/2023/04/10/Nginx/1.png"></p><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>客户端将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器，获取数据后再返回给客户端。对外暴露的是反向代理服务器地址，隐藏了真实服务器IP地址。反向代理的是目标服务器，这一过程对于客户端而言是透明的。</p><p>举例：公司内网部署了3台服务器，客户端请求直接经过代理服务器，由代理服务器将请求转发到内网服务器并最终决定哪一台服务器处理客户端请求。</p><p><img src="/2023/04/10/Nginx/2.png"></p><p>反向代理隐藏了真实的服务器，为服务器收发请求，使真实服务器对客户端不可见。一般在处理跨域请求的时候比较常用。</p><h2 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h2><p>客户端通过正向代理服务器访问目标服务器。正向代理客户端，目标服务器不知道客户端是谁，也就是说客户端对目标服务器的这次访问是透明的。</p><p>为了实现正向代理，客户端需要设置正向代理服务器的IP地址，以及代理程序的端口。</p><p>举例：我们无法直接访问外网，但是可以借助VPN来访问。VPN会把访问目标服务器的客户端请求代理到一个可以直接访问外网的代理服务器上。代理服务器会把外网服务器返回的内容再转发给客户端。</p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>如果一台服务器处理用户请求处理不过来，一个简单的办法就是增加多台服务器，部署相同的服务来处理用户请求。</p><p>Nginx可以将接收到的客户端请求以一定的规则均匀地分配到这个服务器集群中所有地服务器上。Nginx在其中充当的就是反向代理服务器地作用，负载均衡是Nginx作为反向代理服务器最常见的一个应用。</p><p>除此之外，Nginx还带有健康检查功能，会定期轮询向集群里所有地服务器发送健康检查请求，来检查集群中是否有服务器处于异常状态。</p><p><img src="/2023/04/10/Nginx/3.png"></p><h1 id="Nginx为什么适合做负载均衡"><a href="#Nginx为什么适合做负载均衡" class="headerlink" title="Nginx为什么适合做负载均衡"></a>Nginx为什么适合做负载均衡</h1><p>Nginx工作在网络地第七层（应用层），可以针对HTTP应用本身来做分流策略，支持HTTP、HTTPS协议地负载均衡。在工作中，我们通常可以使用Nginx来做七层负载均衡。</p><ul><li>Nginx属于软件负载均衡，相比于硬件负载均衡来说，价格非常低。</li><li>Nginx使用简单。</li><li>Nginx自带健康检查。</li><li>Nginx支持热部署。</li></ul><h1 id="Nginx负载均衡策略"><a href="#Nginx负载均衡策略" class="headerlink" title="Nginx负载均衡策略"></a>Nginx负载均衡策略</h1><h2 id="轮询（默认）"><a href="#轮询（默认）" class="headerlink" title="轮询（默认）"></a>轮询（默认）</h2><p>轮询为负载均衡中较为基础的算法，如果没有配置权重的话，每个请求就按时间顺序逐一分配到不同的服务器处理。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> backserver&#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">172.27.26.174:8099</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">172.27.26.175:8099</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">172.27.26.176:8099</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果配置权重的话，权重越高的服务器被访问的概率越大。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> backserver&#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">172.27.26.174:8099</span> weight=<span class="number">6</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">172.27.26.175:8099</span> weight=<span class="number">2</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">172.27.26.176:8099</span> weight=<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>未加权重的轮询算法适合于服务器性能相近的集群，其中每个服务器承载相同的负载。加权轮询算法适合于服务器性能不等的集群。</p><h2 id="IP哈希"><a href="#IP哈希" class="headerlink" title="IP哈希"></a>IP哈希</h2><p>根据发出请求的客户端IP的hash值来分配服务器，可以保证同IP发出来的请求映射到同一台服务器，或者具有相同hash值的不同IP映射到同一台服务器。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> backserver&#123;</span><br><span class="line">    ip_hash;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">172.27.26.174:8099</span> ;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">172.27.26.175:8099</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">172.27.26.176:8099</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和轮询一样，IP哈希也可以配置权重，如果有两个活动连接数相同的服务器，权重大的被访问的概率越大。</p><h2 id="最小连接数"><a href="#最小连接数" class="headerlink" title="最小连接数"></a>最小连接数</h2><p>当有新的请求出现时，遍历服务器节点列表，并选取其中活动连接数最小的一台服务器来响应当前请求。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> backserver&#123;</span><br><span class="line">    least_conn;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">172.27.26.174:8099</span> ;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">172.27.26.175:8099</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">172.27.26.176:8099</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Nginx-常用命令"><a href="#Nginx-常用命令" class="headerlink" title="Nginx 常用命令"></a>Nginx 常用命令</h1><ul><li><code>nginx</code>：启动</li><li><code>nignx -s stop</code>： 停止</li><li><code>./sbin/nginx -s reload</code>：重载配置（平滑重启） <code>service nginx reload</code></li><li><code>.nginx -c /usr/local/nginx/conf/nginx.conf</code>：重载指定配置文件</li><li><code>nginx -v</code>：查看nginx版本</li><li><code>nginx -t</code>：查看配置文件是否正确</li><li><code>nginx -h</code>：显示帮助信息</li></ul><h1 id="Nginx性能优化常见方式"><a href="#Nginx性能优化常见方式" class="headerlink" title="Nginx性能优化常见方式"></a>Nginx性能优化常见方式</h1><ul><li><strong>设置Nginx运行工作进程个数</strong>：Cpu的核心数或者核心数x2</li><li><strong>开启Gzip压缩</strong></li><li><strong>设置单个worker进程允许客户端最大连接数</strong></li><li><strong>连接超时时间设置</strong></li></ul><h1 id="Nginx工作模式和进程模型"><a href="#Nginx工作模式和进程模型" class="headerlink" title="Nginx工作模式和进程模型"></a>Nginx工作模式和进程模型</h1><h2 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h2><ol><li>Nginx 启动后，会产生一个 master 主进程，主进程执行一系列的工作后会产生一个或者多个工作进程 worker</li><li>在客户端请求动态站点的过程中，Nginx 服务器还涉及和后端服务器的通信。Nginx 将接收到的 Web 请求通过代理转发到后端服务器，由后端服务器进行数据处理和组织；</li><li>Nginx 为了提高对请求的响应效率，降低网络压力，采用了缓存机制，将历史应答数据缓存到本地。保障对缓存文件的快速访问</li></ol><h2 id="进程模型"><a href="#进程模型" class="headerlink" title="进程模型"></a>进程模型</h2><p><img src="/2023/04/10/Nginx/workSpace\Blog\source_posts\Nginx\gVfCciWSaq.png!large"></p><h3 id="master-进程"><a href="#master-进程" class="headerlink" title="master 进程"></a>master 进程</h3><p>主要用来管理 worker 进程，master 进程会接收来自外界发来的信号，再根据信号做不同的事情。所以我们要控制 nginx，只需要通过 kill 向 master 进程发送信号就行了。</p><p>具体包括以下主要功能:</p><ul><li>接收来自外界的信号</li><li>向各 worker 进程发送信号</li><li>监控 worker 进程的运行状态，当 worker 进程退出后 (异常情况下)，会自动重新启动新的 worker 进程</li></ul><h3 id="worker进程"><a href="#worker进程" class="headerlink" title="worker进程"></a>worker进程</h3><p>主要任务是完成具体的任务逻辑。其主要关注点是与客户端或后端真实服务器 (此时 worker 作为中间代理) 之间的数据可读 / 可写等 I/O 交互事件。具体包括以下主要功能:</p><p>接收客户端请求；</p><ul><li><p>将请求一次送入各个功能模块进行过滤处理；</p></li><li><p>与后端服务器通信，接收后端服务器处理结果；</p></li><li><p>数据缓存 proxy_cache 模块</p></li><li><p>响应客户端请求</p><p>（一个请求，完全由 worker 进程来处理，而且只在一个 worker 进程中处理。）</p></li></ul><h3 id="worker进程是如何处理请求？"><a href="#worker进程是如何处理请求？" class="headerlink" title="worker进程是如何处理请求？"></a>worker进程是如何处理请求？</h3><p>首先，worker 进程之间是平等的，每个 worker 进程都是从 master 进程 fork 过来，在 master 进程里面，先建立好需要 listen 的 socket（listenfd）之后，然后再 fork 出多个 worker 进程。每个 worker 进程，处理请求的机会也是一样的。当一个连接请求过来，每个进程都有可能处理这个连接，怎么做的呢？</p><p>所有 worker 进程的 listenfd 会在新连接到来时变得可读，为保证只有一个进程处理该连接，所有 worker 进程在注册 listenfd 读事件前抢 accept_mutex，抢到互斥锁的那个 worker 进程注册 listenfd 读事件，在读事件里调用 accept 接受该连接。</p><p>当一个 worker 进程在 accept 这个连接之后，就开始读取请求，解析请求，处理请求，产生数据后，再返回给客户端，最后断开连接，这样就是一个完整的请求就是这样的了。</p><p>我们可以了解到一个请求，完全由 worker 进程来处理，且只在一个 worker 进程中处理。</p><h2 id="Nginx采用IO多路复用模型"><a href="#Nginx采用IO多路复用模型" class="headerlink" title="Nginx采用IO多路复用模型"></a>Nginx采用IO多路复用模型</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IO 多路复用是指内核一旦发现进程指定的一个或者多个 IO 条件准备读取，它就通知该进程，目前支持 I/O 多路复用的系统调用有 select ， poll ， epoll ，I/O 多路复用就是通过一种机制，一个进程可以监视多个描述符 (socket)，一旦某个描述符就绪 (一般是读就绪或者写就绪)，能够通知程序进行相应的读 写操作。</span><br></pre></td></tr></table></figure><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p><strong>基本原理</strong></p><p>select 函数监视的文件描述符分 3 类，分别是 writefds、readfds、和 exceptfds。调用后 select 函数会阻塞，直到有描述符就绪（有数据 可读、可写、或者有 except），或者超时（timeout 指定等待时间，如果立即返回设为 null 即可），函数返回。当 select 函数返回后，可以通过遍历 fdset，来找到就绪的描述符。</p><p><strong>缺点</strong></p><p>select 本质上是通过设置或者检查存放 fd 标志位的数据结构来进行下一步处理。这样所带来的缺点是：</p><ul><li>select 最大的缺陷就是单个进程所打开的 FD 是有一定限制的，它由 FD_SETSIZE 设置，默认值是 1024。（一般来说这个数目和系统内存关系很大，具体数目可以 cat /proc/sys/fs/file-max 查看。32 位机默认是 1024 个。64 位机默认是 2048）</li><li>对 socket 进行扫描时是线性扫描，即采用轮询的方法，效率较低。（当套接字比较多的时候，每次 select () 都要通过遍历 FD_SETSIZE 个 Socket 来完成调度，不管哪个 Socket 是活跃的，都遍历一遍。这会浪费很多 CPU 时间。如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询，这正是 epoll 与 kqueue 做的）</li><li>需要维护一个用来存放大量 fd 的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大。</li></ul><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p><strong>基本原理</strong></p><p>poll 本质上和 select 没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个 fd 对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有 fd 后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历 fd。这个过程经历了多次无谓的遍历。</p><p><strong>优点</strong></p><ul><li>它没有最大连接数的限制，原因是它是基于链表来存储的。</li></ul><p><strong>缺点</strong></p><ul><li>大量的 fd 的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义。</li><li>poll 还有一个特点是 “水平触发”，如果报告了 fd 后，没有被处理，那么下次 poll 时会再次报告该 fd。</li></ul><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>epoll 是在 2.6 内核中提出的，是之前的 select 和 poll 的增强版本。相对于 select 和 poll 来说，epoll 更加灵活，没有描述符限制。epoll 使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的 copy 只需一次。</p><p><strong>基本原理</strong></p><p>epoll 支持水平触发和边缘触发，最大的特点在于边缘触发，它只告诉进程哪些 fd 刚刚变为就绪态，并且只会通知一次。还有一个特点是，epoll 使用 “事件” 的就绪通知方式，通过 epoll_ctl 注册 fd，一旦该 fd 就绪，内核就会采用类似 callback 的回调机制来激活该 fd，epoll_wait 便可以收到通知。</p><p><strong>epoll 对文件描述符的操作有两种模式</strong></p><p>LT（level trigger）和 ET（edge trigger）。LT 模式是默认模式，两者区别如下：</p><ul><li>LT 模式：当 epoll_wait 检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用 epoll_wait 时，会再次响应应用程序并通知此事件。</li><li>ET 模式：当 epoll_wait 检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用 epoll_wait 时，不会再次响应应用程序并通知此事件。</li></ul><p><strong>优点</strong></p><ul><li>没有最大并发连接的限制，能打开的 FD 的上限远大于 1024（1G 的内存上能监听约 10 万个端口）。</li><li>效率提升，不是轮询的方式，不会随着 FD 数目的增加效率下降。<br>只有活跃可用的 FD 才会调用 callback 函数；即 Epoll 最大的优点就在于它只管你 “活跃” 的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll 的效率就会远远高于 select 和 poll。</li><li>内存拷贝，利用 mmap () 文件映射内存加速与内核空间的消息传递；即 epoll 使用 mmap 减少复制开销。</li></ul><h1 id="Nginx处理HTTP头部过程"><a href="#Nginx处理HTTP头部过程" class="headerlink" title="Nginx处理HTTP头部过程"></a>Nginx处理HTTP头部过程</h1><p>Nginx 在处理 HTTP 请求之前，首先需要 Nginx 的框架先和客户端建立好连接，然后接收用户发来的 HTTP 的请求行，比如方法、URL 等，然后接收所有的 Header，根据这些 Header 信息，才能决定由哪些 HTTP 模块处理请求。下面这张图，解释了 Nginx 在处理 HTTP 请求之前，所经历的一系列流程，强烈建议收藏保存。下面针对每个部分单独讲解一下。</p><p><img src="/2023/04/10/Nginx/workSpace\Blog\source_posts\Nginx\123.png"></p><h2 id="接受请求事件模块"><a href="#接受请求事件模块" class="headerlink" title="接受请求事件模块"></a>接受请求事件模块</h2><p><img src="/2023/04/10/Nginx/workSpace\Blog\source_posts\Nginx\321.png"></p><p>首先是三次握手，当客户端发来 ACK 之后，由操作系统内核回一个 SYN+ACK，紧接着客户端 ACK 之后，连接建立成功。同时可能有很多 worker 进程都在监听 80 或 443 端口，由操作系统的负载均衡算法，选取一个 worker 进程来处理，这个 worker 进程会通过 <code>epoll_wait</code> 方法，返回一个建立连接的句柄。拿到了监听的句柄之后，这实际上是一个读事件（因为是从操作系统中读取到了一个请求），调用 <code>accept</code> 方法，分配连接内存池。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">内存池主要分为连接内存池和请求内存池。</span><br></pre></td></tr></table></figure><p>连接内存池大小的配置是 <code>connection_pool_size</code>，到了这一步之后，Nginx 会为已经建立的连接分配一个 512 字节大小的连接内存池。分配完内存池，建立好连接之后，HTTP 模块会从事件模块手里接入请求处理的过程，HTTP 模块在启动时，会调用 <code>ngx_http_init_connection</code> 方法来设置回调方法，这个时候会把新建立连接的读事件通过 <code>epoll_ctl</code> 函数添加到 epoll 中，然后加一个超时定时器 <code>client_header_timeout: 60s</code>，这个定时器的作用是，如果超过 60s 还没有接收到客户端发来的请求，那么就会断开连接。这一部分走完之后，Nginx 的事件模块可能就会切换到其他的句柄去处理了。</p><p><img src="/2023/04/10/Nginx/workSpace\Blog\source_posts\Nginx\bVbFVZN.png"></p><p>当用户真的把请求发来之后，操作系统会回复一个 ACK，同时事件模块的 <code>epoll_wait</code> 也拿到了这个请求，这个时候会调用设置的回调方法 <code>ngx_http_wait_request_handler</code>，将接收到的用户请求读到用户态中，而读取到用户态中需要操作系统分配内存，那么这段内存分配多大？从哪里分配呢？</p><p>这段内存是从连接内存池分配的，初始虽然分配了 512 字节，但是内存池可以扩展，由 <code>client_header_buffer_size: 1k</code> 分配 1k 内存，内存池并不是越大越好，因为用户即使发送了 1 个字节，也会分配出 1k 的内存出来。当 URL 超过 1k 后，应该怎么办呢？</p><h2 id="接收请求HTTP模块"><a href="#接收请求HTTP模块" class="headerlink" title="接收请求HTTP模块"></a>接收请求HTTP模块</h2><p><img src="/2023/04/10/Nginx/workSpace\Blog\source_posts\Nginx\bVbFVZO.png"></p><p>处理请求和处理连接是不一样的，处理请求只需要放到 Nginx 内存中就行了，但是处理请求还需要做大量的上下文分析，所以要分配一个请求内存池 <code>request_pool_size: 4k</code>。分配完以后，状态机开始解析请求行，如果这时候发现 URL 大于 4k，那么就会再分配一个大内存，也就是 <code>large_client_header_buffers: 4 8k</code>，这个配置的意思是说，最多分配 4 个 8k，它并不是一次性分配 32k，而是先分配 8k 然后再去解析请求行，如果依然大于 8k，那么就会再分配 8k 的内存。</p><p>Nginx 有很多变量，这些变量都是指针，其中可以用来标识 URI，标识完成之后，就开始处理 header。状态机解析 header 的时候，如果发现内存不够，也就是假如 URL 已经用掉了 <code>large_client_header_buffers: 4 8k</code> 中的 2 个 8k，这时候最多也只能分配 8k，请求行和 header 是公用 4 个 8k的。</p><p>分配完大内存之后，就开始标识 header，确定哪一个 server 块去处理请求，然后移除超时定时器，接下来，就开始核心的 11 个阶段 HTTP 请求处理请求。</p><p>这里需要注意以下几个地方：</p><ul><li>连接内存池：初始大小 512 字节<ul><li><code>client_header_buffer_size: 1k</code> 从连接内存池中分配</li><li><code>large_client_header_buffers: 4 8k</code> 也是从连接内存池中分配</li></ul></li><li>请求内存池：<code>request_pool_size: 4k</code></li></ul>]]></content:encoded>
      
      
      <category domain="http://zyanprocess.github.io/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/">后端开发</category>
      
      
      <category domain="http://zyanprocess.github.io/tags/Nginx/">Nginx</category>
      
      
      <comments>http://zyanprocess.github.io/2023/04/10/Nginx/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>排序算法</title>
      <link>http://zyanprocess.github.io/2023/04/07/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</link>
      <guid>http://zyanprocess.github.io/2023/04/07/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</guid>
      <pubDate>Fri, 07 Apr 2023 06:25:38 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;排序算法可以分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;内部排序&lt;/strong&gt; ：数据记录在内存中进行排序。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;外部排序&lt;/strong&gt; ：因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;常见的内部排序算法有：&lt;strong&gt;插入排序&lt;/strong&gt;、&lt;strong&gt;希尔排序&lt;/strong&gt;、&lt;strong&gt;选择排序&lt;/strong&gt;、&lt;strong&gt;冒泡排序&lt;/strong&gt;、&lt;strong&gt;归并排序&lt;/strong&gt;、&lt;strong&gt;快速排序&lt;/strong&gt;、&lt;strong&gt;堆排序&lt;/strong&gt;、&lt;strong&gt;基数排序&lt;/strong&gt;等，本文只讲解内部排序算法。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>排序算法可以分为：</p><ul><li><strong>内部排序</strong> ：数据记录在内存中进行排序。</li><li><strong>外部排序</strong> ：因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。</li></ul><p>常见的内部排序算法有：<strong>插入排序</strong>、<strong>希尔排序</strong>、<strong>选择排序</strong>、<strong>冒泡排序</strong>、<strong>归并排序</strong>、<strong>快速排序</strong>、<strong>堆排序</strong>、<strong>基数排序</strong>等，本文只讲解内部排序算法。</p><span id="more"></span><p>用一张图概括：</p><p><img src="/2023/04/07/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/workSpace\Blog\source_posts\排序算法\sort1.png"></p><ul><li><strong>n</strong>：数据规模</li><li><strong>k</strong>：“桶” 的个数</li><li><strong>In-place</strong>：占用常数内存，不占用额外内存</li><li><strong>Out-place</strong>：占用额外内存</li></ul><h2 id="算法分类"><a href="#算法分类" class="headerlink" title="算法分类"></a>算法分类</h2><p>十种常见排序算法可以分类两大类别：<strong>比较类排序</strong>和<strong>非比较类排序</strong>。</p><p><img src="/2023/04/07/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/workSpace\Blog\source_posts\排序算法\sort2.png"></p><p>常见的<strong>快速排序</strong>、<strong>归并排序</strong>、<strong>堆排序</strong>以及<strong>冒泡排序</strong>等都属于<strong>比较类排序算法</strong>。比较类排序是通过比较来决定元素间的相对次序，由于其时间复杂度不能突破 <code>O(nlogn)</code>，因此也称为非线性时间比较类排序。在冒泡排序之类的排序中，问题规模为 <code>n</code>，又因为需要比较 <code>n</code> 次，所以平均时间复杂度为 <code>O(n²)</code>。在<strong>归并排序</strong>、<strong>快速排序</strong>之类的排序中，问题规模通过<strong>分治法</strong>消减为 <code>logn</code> 次，所以时间复杂度平均 <code>O(nlogn)</code>。</p><p>比较类排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，比较排序适用于一切需要排序的情况。</p><p>而<strong>计数排序</strong>、<strong>基数排序</strong>、<strong>桶排序</strong>则属于<strong>非比较类排序算法</strong>。非比较排序不通过比较来决定元素间的相对次序，而是通过确定每个元素之前，应该有多少个元素来排序。由于它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。 非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度 <code>O(n)</code>。</p><p>非比较排序时间复杂度底，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。</p><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>冒泡排序是一种简单的排序算法。它重复地遍历要排序的序列，依次比较两个元素，如果它们的顺序错误就把它们交换过来。遍历序列的工作是重复地进行直到没有再需要交换为止，此时说明该序列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢 “浮” 到数列的顶端。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li><p>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</p></li><li><p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</p></li><li><p>针对所有的元素重复以上的步骤，除了最后一个；</p></li><li><p>重复步骤 1~3，直到排序完成。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冒泡排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] bubbleSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = tmp;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>此处对代码做了一个小优化，加入了 is_sorted Flag，目的是将算法的最佳时间复杂度优化为 O(n)，即当原输入序列就是排序好的情况下，该算法的时间复杂度就是 O(n)。</strong></p><h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><ul><li><strong>稳定性</strong>：稳定</li><li><strong>时间复杂度</strong> ：最佳：O(n) ，最差：O(n2)， 平均：O(n2)</li><li><strong>空间复杂度</strong> ：O(1)</li><li><strong>排序方式</strong> ：In-place</li></ul><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>选择排序是一种简单直观的排序算法，无论什么数据进去都是 <code>O(n²)</code>的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><h2 id="算法步骤-1"><a href="#算法步骤-1" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li><li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li><li>重复第 2 步，直到所有元素均排序完毕。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选择排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] selectionSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (minIndex != i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            arr[i] = arr[minIndex];</span><br><span class="line">            arr[minIndex] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h2><ul><li><strong>稳定性</strong>：不稳定</li><li><strong>时间复杂度</strong> ：最佳：O(n2) ，最差：O(n2)， 平均：O(n2)</li><li><strong>空间复杂度</strong> ：O(1)</li><li><strong>排序方式</strong> ：In-place</li></ul><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>插入排序是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用 in-place 排序（即只需用到 <code>O(1)</code> 的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><p>插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><p>插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。</p><h2 id="算法步骤-2"><a href="#算法步骤-2" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li><p>从第一个元素开始，该元素可以认为已经被排序；</p></li><li><p>取出下一个元素，在已经排序的元素序列中从后向前扫描；</p></li><li><p>如果该元素（已排序）大于新元素，将该元素移到下一位置；</p></li><li><p>重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置；</p></li><li><p>将新元素插入到该位置后；</p></li><li><p>重复步骤 2~5。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] insertionSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">preIndex</span> <span class="operator">=</span> i - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        <span class="keyword">while</span> (preIndex &gt;= <span class="number">0</span> &amp;&amp; current &lt; arr[preIndex]) &#123;</span><br><span class="line">            arr[preIndex + <span class="number">1</span>] = arr[preIndex];</span><br><span class="line">            preIndex -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[preIndex + <span class="number">1</span>] = current;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h2><ul><li><strong>稳定性</strong>：稳定</li><li><strong>时间复杂度</strong> ：最佳：O(n) ，最差：O(n2)， 平均：O(n2)</li><li><strong>空间复杂度</strong> ：O(1)</li><li><strong>排序方式</strong> ：In-place</li></ul><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>希尔排序是希尔 (Donald Shell) 于 1959 年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为递减增量排序算法，同时该算法是冲破 <code>O(n²)</code> 的第一批算法之一。</p><p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录 “基本有序” 时，再对全体记录进行依次直接插入排序。</p><h2 id="算法步骤-3"><a href="#算法步骤-3" class="headerlink" title="算法步骤"></a>算法步骤</h2><p>我们来看下希尔排序的基本步骤，在此我们选择增量 <code>gap=length/2</code>，缩小增量继续以 <code>gap = gap/2</code> 的方式，这种增量选择我们可以用一个序列来表示，<code>&#123;n/2, (n/2)/2, ..., 1&#125;</code>，称为<strong>增量序列</strong>。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。</p><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p><ul><li>选择一个增量序列 <code>&#123;t1, t2, …, tk&#125;</code>，其中 <code>(ti&gt;tj, i&lt;j, tk=1)</code>；</li><li>按增量序列个数 k，对序列进行 k 趟排序；</li><li>每趟排序，根据对应的增量 <code>t</code>，将待排序列分割成若干长度为 <code>m</code> 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 希尔排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] shellSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> n / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (gap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> gap; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">preIndex</span> <span class="operator">=</span> i - gap;</span><br><span class="line">            <span class="keyword">while</span> (preIndex &gt;= <span class="number">0</span> &amp;&amp; arr[preIndex] &gt; current) &#123;</span><br><span class="line">                arr[preIndex + gap] = arr[preIndex];</span><br><span class="line">                preIndex -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[preIndex] = current;</span><br><span class="line">        &#125;</span><br><span class="line">        gap /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法分析-3"><a href="#算法分析-3" class="headerlink" title="算法分析"></a>算法分析</h2><ul><li><strong>稳定性</strong>：稳定</li><li><strong>时间复杂度</strong> ：最佳：O(nlogn)， 最差：O(n2) 平均：O(nlogn)</li><li><strong>空间复杂度</strong> ：<code>O(1)</code></li></ul><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] mergeSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> arr.length / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span>[] arr1 = Arrays.copyOfRange(arr, <span class="number">0</span>, middle);</span><br><span class="line">    <span class="type">int</span>[] arr2 = Arrays.copyOfRange(arr, middle, arr.length);</span><br><span class="line">    <span class="keyword">return</span> merge(mergeSort(arr1), mergeSort(arr2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] merge(<span class="type">int</span>[] arr1, <span class="type">int</span>[] arr2) &#123;</span><br><span class="line">    <span class="type">int</span>[] sorted_arr = <span class="keyword">new</span> <span class="title class_">int</span>[arr1.length + arr2.length];</span><br><span class="line">    <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>, idx1 = <span class="number">0</span>, idx2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (idx1 &lt; arr1.length &amp;&amp; idx2 &lt; arr2.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr1[idx1] &lt; arr2[idx2]) &#123;</span><br><span class="line">            sorted_arr[idx++] = arr1[idx1++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sorted_arr[idx++] = arr2[idx2++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (idx1 &lt; arr1.length) &#123;</span><br><span class="line">        <span class="keyword">while</span> (idx1 &lt; arr1.length) &#123;</span><br><span class="line">            sorted_arr[idx++] = arr1[idx1++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (idx2 &lt; arr2.length) &#123;</span><br><span class="line">            sorted_arr[idx++] = arr2[idx2++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sorted_arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法分析-4"><a href="#算法分析-4" class="headerlink" title="算法分析"></a>算法分析</h2><ul><li><strong>稳定性</strong>：稳定</li><li><strong>时间复杂度</strong> ：最佳：O(nlogn)， 最差：O(nlogn)， 平均：O(nlogn)</li><li><strong>空间复杂度</strong> ：O(n)</li></ul><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>快速排序用到了分治思想，同样的还有归并排序。乍看起来快速排序和归并排序非常相似，都是将问题变小，先排序子串，最后合并。不同的是快速排序在划分子问题的时候经过多一步处理，将划分的两组数据划分为一大一小，这样在最后合并的时候就不必像归并排序那样再进行比较。但也正因为如此，划分的不定性使得快速排序的时间复杂度并不稳定。</p><p>快速排序的基本思想：通过一趟排序将待排序列分隔成独立的两部分，其中一部分记录的元素均比另一部分的元素小，则可分别对这两部分子序列继续进行排序，以达到整个序列有序。</p><h2 id="算法步骤-4"><a href="#算法步骤-4" class="headerlink" title="算法步骤"></a>算法步骤</h2><p>快速排序使用分治法（Divide and conquer）策略来把一个序列分为较小和较大的 2 个子序列，然后递回地排序两个子序列。具体算法描述如下：</p><ol><li>从序列中<strong>随机</strong>挑出一个元素，做为 “基准”(<code>pivot</code>)；</li><li>重新排列序列，将所有比基准值小的元素摆放在基准前面，所有比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个操作结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地把小于基准值元素的子序列和大于基准值元素的子序列进行快速排序。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> low</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> high</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> partition(array, low, high);</span><br><span class="line">        quickSort(array, low, position - <span class="number">1</span>);</span><br><span class="line">        quickSort(array, position + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[low];</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; arr[high] &gt;= pivot) &#123;</span><br><span class="line">            high--;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, low, high);</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; arr[low] &lt;= pivot) &#123;</span><br><span class="line">            low++;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr,low,high);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[low];</span><br><span class="line">    arr[low] = arr[high];</span><br><span class="line">    arr[high] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法分析-5"><a href="#算法分析-5" class="headerlink" title="算法分析"></a>算法分析</h2><ul><li><strong>稳定性</strong> ：不稳定</li><li><strong>时间复杂度</strong> ：最佳：O(nlogn)， 最差：O(nlogn)，平均：O(nlogn)</li><li><strong>空间复杂度</strong> ：O(nlogn)</li></ul><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>堆排序是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足<strong>堆的性质</strong>：即<strong>子结点的值总是小于（或者大于）它的父节点</strong>。</p><h2 id="算法步骤-5"><a href="#算法步骤-5" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li><p>将初始待排序列 <code>(R1, R2, ……, Rn)</code> 构建成大顶堆，此堆为初始的无序区；</p></li><li><p>将堆顶元素 <code>R[1]</code> 与最后一个元素 <code>R[n]</code> 交换，此时得到新的无序区 <code>(R1, R2, ……, Rn-1)</code> 和新的有序区 (Rn), 且满足 <code>R[1, 2, ……, n-1]&lt;=R[n]</code>；</p></li><li><p>由于交换后新的堆顶 <code>R[1]</code> 可能违反堆的性质，因此需要对当前无序区 <code>(R1, R2, ……, Rn-1)</code> 调整为新堆，然后再次将 R [1] 与无序区最后一个元素交换，得到新的无序区 <code>(R1, R2, ……, Rn-2)</code> 和新的有序区 <code>(Rn-1, Rn)</code>。不断重复此过程直到有序区的元素个数为 <code>n-1</code>，则整个排序过程完成。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span>[] tree,<span class="type">int</span> n)</span> &#123;</span><br><span class="line">buildHeap(tree, n);<span class="comment">//第一步是将得到的数组构建成大顶堆</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">swap(tree, i, <span class="number">0</span>);<span class="comment">//第一次构建完大顶堆之后，要进行第一个数和最后一个树的交换</span></span><br><span class="line"><span class="comment">//交换完之后，最上面的数就不是最大数了，因此只需要对最上面的数，进行一个树的调整即可</span></span><br><span class="line"><span class="comment">//所以，我们使用的时adjustTree而不是buildHeap</span></span><br><span class="line">adjustTree(tree, i, <span class="number">0</span>);<span class="comment">//这里解释一下，这参数的含义：之所以将i当做数组的长度，</span></span><br><span class="line"><span class="comment">//是因为我们将第一个数和最后一个数交换之后，就已经把最大的数放在了数组最后，进行</span></span><br><span class="line"><span class="comment">//树调整的时候，就不需要管最后一个数字了。而0就是因为交换之后需要进行节点调节的那个节点</span></span><br><span class="line"><span class="comment">//换到了第一个位置</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这个函数写完之后，就可以将任意一个数组，构建成大顶堆了，构建完大顶堆之后，就要进行堆排序了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">buildHeap</span><span class="params">(<span class="type">int</span>[]tree,<span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (n-<span class="number">1</span>)/<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--) &#123;<span class="comment">//i从最后一个子节点的父节点开始，所以i = (n-1)/2</span></span><br><span class="line">adjustTree(tree, n, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//利用adjustTree和swap两个函数，可以针对某一个父节点，进行调节。接下来，解决当整个树是</span></span><br><span class="line"><span class="comment">//乱序的，将一个树构建成一个大顶堆。思路是这样的：从最后一个子节点的父节点开始调节，往上走。</span></span><br><span class="line"><span class="comment">//不断重复，每往上一个父节点，父节点的下标就减一，可以将adjustTree和swap函数放进一个for循环</span></span><br><span class="line"><span class="comment">//就是上面的for循环</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 表示从某一个节点开始，调整一次树，使之成为堆，其中i表示某一个节点的下标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">adjustTree</span><span class="params">(<span class="type">int</span>[]tree,<span class="type">int</span> n,<span class="type">int</span> i)</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(i&gt;=n) &#123;<span class="comment">//这是递归头。</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//首先确定i节点的左右两个孩子的下标</span></span><br><span class="line"><span class="type">int</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="number">2</span>*i+<span class="number">2</span>;</span><br><span class="line"><span class="comment">//接下来，在这三个值中，找出最大值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> i;<span class="comment">//先假设最大值为这个父节点</span></span><br><span class="line"><span class="keyword">if</span>(c1&lt;n &amp;&amp; tree[c1]&gt;tree[max]) &#123;<span class="comment">//要保证c1不会出界</span></span><br><span class="line">max = c1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(c2&lt;n &amp;&amp; tree[c2]&gt;tree[max]) &#123;<span class="comment">//保证c2不会出界  c2&lt;n</span></span><br><span class="line">max = c2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//经过上面的条件判断，就可以将最大值的下标保存到max中了，如果最大值max就是i，也就是</span></span><br><span class="line"><span class="comment">//父节点最大，就不用调整，但是如果父节点不是最大，就要进行交换了</span></span><br><span class="line"><span class="keyword">if</span>(max!=i) &#123;</span><br><span class="line">swap(tree,max,i);</span><br><span class="line">adjustTree(tree,n,max);<span class="comment">//交换之后，将父节点下放一级，就有可能会破坏下一层结构，</span></span><br><span class="line"><span class="comment">//所以，递归调用adjustTree.使用递归之后，就要添加递归头了</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] tree, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> tree[i];</span><br><span class="line">tree[i] = tree[j];</span><br><span class="line">tree[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法分析-6"><a href="#算法分析-6" class="headerlink" title="算法分析"></a>算法分析</h2><ul><li><strong>稳定性</strong> ：不稳定</li><li><strong>时间复杂度</strong> ：最佳：O(nlogn)， 最差：O(nlogn)， 平均：O(nlogn)</li><li><strong>空间复杂度</strong> ：O(1)</li></ul>]]></content:encoded>
      
      
      <category domain="http://zyanprocess.github.io/categories/%E7%AE%97%E6%B3%95/">算法</category>
      
      
      <category domain="http://zyanprocess.github.io/tags/%E6%8E%92%E5%BA%8F/">排序</category>
      
      
      <comments>http://zyanprocess.github.io/2023/04/07/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Tomcat</title>
      <link>http://zyanprocess.github.io/2023/04/06/Tomcat/</link>
      <guid>http://zyanprocess.github.io/2023/04/06/Tomcat/</guid>
      <pubDate>Thu, 06 Apr 2023 11:02:50 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;Tomcat介绍&quot;&gt;&lt;a href=&quot;#Tomcat介绍&quot; class=&quot;headerlink&quot; title=&quot;Tomcat介绍&quot;&gt;&lt;/a&gt;Tomcat介绍&lt;/h1&gt;&lt;h2 id=&quot;什么是Tomcat&quot;&gt;&lt;a href=&quot;#什么是Tomcat&quot; class=&quot;headerlink&quot; title=&quot;什么是Tomcat&quot;&gt;&lt;/a&gt;什么是Tomcat&lt;/h2&gt;&lt;p&gt;Tomcat是一个“HTTP服务器+Servlet容器”，也叫Web容器。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;HTTP服务器&lt;/strong&gt; ： 处理HTTP请求并响应结果。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Servlet容器&lt;/strong&gt; ： HTTP服务器将请求交给Servlet容器处理，Servlet容器会将请求转发到具体的Servlet。&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="Tomcat介绍"><a href="#Tomcat介绍" class="headerlink" title="Tomcat介绍"></a>Tomcat介绍</h1><h2 id="什么是Tomcat"><a href="#什么是Tomcat" class="headerlink" title="什么是Tomcat"></a>什么是Tomcat</h2><p>Tomcat是一个“HTTP服务器+Servlet容器”，也叫Web容器。</p><ul><li><strong>HTTP服务器</strong> ： 处理HTTP请求并响应结果。</li><li><strong>Servlet容器</strong> ： HTTP服务器将请求交给Servlet容器处理，Servlet容器会将请求转发到具体的Servlet。</li></ul><span id="more"></span><h2 id="HTTP服务器工作原理"><a href="#HTTP服务器工作原理" class="headerlink" title="HTTP服务器工作原理"></a>HTTP服务器工作原理</h2><p><img src="/2023/04/06/Tomcat/1.png"></p><ol><li>用户通过浏览器进行了一个操作，比如输入网址并回车，或者是点击链接，接着浏览器获取了这个事件。</li><li>浏览器向服务器发出了TCP连接请求。</li><li>服务程序接受浏览器的连接请求，并经过TCP三次握手建立连接。</li><li>浏览器将请求数据打包成一个HTTP协议格式的数据包。</li><li>浏览器将数据包推入网络，数据包经过网络传输，最终到达服务端程序。</li><li>服务端程序拿到这个数据包后，同样以HTTP协议格式解包，获取到客户端的意图。</li><li>得知客户端意图后进行处理，比如提供静态文件或者调用服务端程序获得动态结果。</li><li>服务器将响应结果按照HTTP协议格式打包。</li><li>服务器将响应数据包推入网络，数据包经过网络传输最终达到浏览器。</li><li>浏览器拿到数据包后，以HTTP协议的格式解包，然后解析数据。</li><li>浏览器将HTML文件展示在页面上。</li></ol><h1 id="什么是Servlet？"><a href="#什么是Servlet？" class="headerlink" title="什么是Servlet？"></a>什么是Servlet？</h1><p>Servelt指的是任何实现了<code>Servlet</code>接口的类。Servlet主要用于处理客户端传来的HTTP请求，并返回一个响应。</p><p>Servlet接口定义了下面5个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Servlet</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig var1)</span> <span class="keyword">throws</span> ServletException;</span><br><span class="line"></span><br><span class="line">    ServletConfig <span class="title function_">getServletConfig</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest var1, ServletResponse var2)</span> <span class="keyword">throws</span> ServletException, IOException;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">getServletInfo</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中最重要的是<code>service</code>方法，具体业务类在这个方法里实现业务的具体处理逻辑。</p><p>Servlet容器会根据<code>web.xml</code>文件中的映射关系，调用相应的Servlet，Servlet将处理的结果返回给Servlet容器，并通过HTTP服务器将响应传输给客户端。</p><p><img src="/2023/04/06/Tomcat/2.png"></p><h2 id="Tomcat如何创建Servlet"><a href="#Tomcat如何创建Servlet" class="headerlink" title="Tomcat如何创建Servlet"></a>Tomcat如何创建Servlet</h2><p>当容器启动时，会读取在webapps目录下所有的web应用中的<code>web.xml</code>文件，然后对xml文件进行解析，并读取Servlet注册信息。然后，将每个应用中注册的Servlet类都进行加载，并通过反射的方法实例化。</p><p><code>load-on-startup</code>元素是<code>&lt;servlet</code>元素的一个子元素，它用于指定Servlet被加载的时机和顺序。在<code>load-on-startup</code>元素中，设置的值必须是一个整数。如果这个值是一个负数，或者没有设定这个元素，Servlet容器将在客户端首次请求这个Servlet时加载它；如果这个值时正整数或0，Servlet将在Web应用启动时加载并初始化Servlet，并且<code>load-on-startup</code>的值越小，它对应的Servlet就越先被加载。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--给要配置的Servlet取一个名，一般建议就是当前Servlet的名字首字母小写--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>servletDemo01<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--要进行配置的那个Servlet的全限定名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.atguigu.servlet.ServletDemo01<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--添加一个初始化参数--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>username<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>aobama<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置它提前到服务器启动的时候创建--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--和上面的servlet-name是一致的--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>servletDemo01<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--就是你要给ServletDemo01配置的映射路径--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        一定要/</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/demo01<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Tomcat文件夹"><a href="#Tomcat文件夹" class="headerlink" title="Tomcat文件夹"></a>Tomcat文件夹</h2><ul><li><strong>/bin</strong>：存放windows或Linux平台上启动和关闭Tomcat的脚本文件</li><li><strong>/conf</strong>： 存放Tomcat的各种全局配置文件，其中最重要的是server.xml</li><li><strong>/lib</strong>：存放Tomcat以及所有Web应用都可以访问的JAR文件</li><li><strong>/logs</strong>：存放Tomcat执行时产生的日志文件</li><li><strong>/work</strong>：存放JSP编译后产生的Class文件</li><li><strong>/webapps</strong>：Tomcat的Web应用目录，默认情况下把Web应用放在这个目录下</li></ul><h2 id="Tomcat总体架构"><a href="#Tomcat总体架构" class="headerlink" title="Tomcat总体架构"></a>Tomcat总体架构</h2><p>Tomcat要实现2个核心功能：</p><ol><li>处理Socket连接，负责网络字节流与Request和Response对象的转化。</li><li>加载和管理Servlet，以及具体处理Request请求。</li></ol><p>因此Tomcat设计了两个核心组件<strong>连接器</strong>和<strong>容器</strong>来分别做这两件事。</p><p><img src="/2023/04/06/Tomcat/3.jpg"></p><h3 id="连接器的作用"><a href="#连接器的作用" class="headerlink" title="连接器的作用"></a>连接器的作用</h3><p>连接器对Servlet容器屏蔽了协议及I/O模型等区别，无论是HTTP还是AJP，在容器中获取到的都是一个标准的<code>ServletRequest</code>对象。</p><p>可以把连接器的功能需求进一步细化，比如：</p><ul><li>监听网络端口。</li><li>接受网络连接请求。</li><li>读取网络请求字节流。</li><li>根据具体应用层协议（HTTP/AJP）解析字节流，生成统一的<code>Tomcat Request</code>对象。</li><li>将<code>Tomcat Request</code>对象转成标准的<code>ServletRequest</code>。</li><li>调用<code>Servlet</code>容器，得到<code>ServletResponse</code>。</li><li>将<code>ServletResponse</code>转成<code>Tomcat Response</code>对象。</li><li>将<code>Tomcat Response</code>转成网络字节流。</li><li>将响应字节流写回给浏览器。</li></ul><p>连接器需要完成3个高内聚的功能：</p><ul><li><strong>网络通信</strong></li><li><strong>应用层协议解析</strong></li><li><strong>Tomcat Requset/Response 与 ServletRequest/ServletReponse的转化</strong></li></ul><p>因此Tomcat设计了3个组件实现3个功能，分别是<strong>Endpoint</strong>、<strong>Processor</strong>和<strong>Adapter</strong>。</p><p><strong>Endpoint负责提供字节流给Processor，Processor负责提供<code>Tomcat Request</code>对象给Adapter，Adapter负责提供<code>ServletRequest</code>对象给容器。</strong></p><p><img src="/2023/04/06/Tomcat/4.jpg"></p><p>连接器用**<code>ProtocolHandler</code><strong>接口来封装通信协议和I/O模块的差异，</strong><code>ProtocolHandler</code><strong>内部又分为</strong>Endpoint<strong>和</strong>Processor<strong>模块，</strong>Endpoint<strong>负责底层Socket通信，</strong>Processor<strong>负责应用层协议解析。连接器通过适配器</strong>Adapter**调用容器。</p><p><img src="/2023/04/06/Tomcat/5.jpg"></p><h3 id="容器的设计"><a href="#容器的设计" class="headerlink" title="容器的设计"></a>容器的设计</h3><p>Tomcat设计了4种容器，分别是<strong>Engine</strong>、<strong>Host</strong>、<strong>Context</strong>和<strong>Wrapper</strong>。这4种容器不是平行关系，而是父子关系。</p><p><img src="/2023/04/06/Tomcat/6.jpg"></p><ul><li><strong>Context</strong>表示一个Web应用</li><li><strong>Wrapper</strong>表示一个Servlet，一个Web应用中可能会有多个Servlet</li><li><strong>Host</strong>代表的是一个虚拟主机，或者说一个站点，可以给Tomcat配置多个虚拟主机地址，而一个虚拟主机下可以部署多个Web应用程序</li><li><strong>Engine</strong>表示引擎，用来管理多个虚拟站点，一个Service最多只能有一个Engine</li></ul><h3 id="请求如何定位到Servlet？"><a href="#请求如何定位到Servlet？" class="headerlink" title="请求如何定位到Servlet？"></a>请求如何定位到Servlet？</h3><p><strong>Tomcat是怎么确定请求是由哪个Wrapper容器里的Servlet来处理的？</strong></p><p>Mapper组件的功能就是将用户请求的URL定位到一个Servlet。它的工作原理是：Mapper组件里保存了Web应用的配置信息，其实就是容器组件与访问路径的映射关系，比如Host容器里配置的域名、Context容器里的Web应用路径，以及Wrapper容器里Servlet映射的路径。</p><p><em><strong>注意</strong></em>：一个请求URL最后只会定位到一个Wrapper容器，也就是一个Servlet。</p><p>举例：有一个网购系统，有面向网站管理人员的后台管理系统，还有面向终端客户的在线购物系统。这两个系统跑在同一个Tomcat上，为了隔离它们的访问域名，配置了两个虚拟域名：<code>manage.shopping.com</code>和<code>user.shopping.com</code>。</p><p><img src="/2023/04/06/Tomcat/7.jpg"></p><p>假如有用户访问一个URL，比如图中的<code>http://user.shopping.com:8080/order/buy</code>，Tomcat如何将这个URL定位到一个Servlet？</p><ol><li><strong>根据协议和端口号选定Service和Engine</strong>：URL访问的是8080端口，因此这个请求会被HTTP连接器接收，而一个连接器是属于一个Service组件的，这样Service组件就确定了。</li><li><strong>根据域名选定Host</strong>：域名是user.shopping.com，因此Mapper会找到Host2这个容器。</li><li><strong>根据URL路径找到Context组件</strong>。</li><li><strong>根据URL路径找到Wrapper（Servlet）</strong>：Context确定后，Mapper再根据web.xml种配置的Servlet映射路径来找到具体的Wrapper和Servlet。</li></ol><h3 id="Tomcat为什么要打破双亲委派机制"><a href="#Tomcat为什么要打破双亲委派机制" class="headerlink" title="Tomcat为什么要打破双亲委派机制"></a>Tomcat为什么要打破双亲委派机制</h3><p>Tomcat自定义类加载器打破双亲委派机制的目的是为了优先加载Web应用目录下的类，然后再加载其他目录下的类，是Servlet规范的推荐做法。</p><p>需要继承<code>ClassLoader</code>抽象类，并且需要重写<code>loadClass</code>方法。</p><h3 id="Tomcat如何隔离Web应用"><a href="#Tomcat如何隔离Web应用" class="headerlink" title="Tomcat如何隔离Web应用"></a>Tomcat如何隔离Web应用</h3><p>首先思考下面几个问题：</p><ol><li>假如在Tomcat中运行了两个Web应用程序，两个Web应用中有同名的Servlet，但是功能不同，Tomcat需要同时加载和管理这两个同名的Servlet类，保证不会发生冲突，因此Web应用之间的类需要隔离。</li><li>假如两个Web应用都依赖同一个第三方的JAR包，比如Spring，那Spring的JAR包被加载到内存之后，TOmcat要保证这两个Web应用能够共享，也就是说Spring的JAR包只要被加载一次，否则随着依赖的第三方JAR包增多，JVM的内存会膨胀。</li><li>跟JVM一样，需要隔离TOmcat本身的类和Web应用的类。</li></ol><p><img src="/2023/04/06/Tomcat/3.png"></p><h4 id="Web应用之间的类如何隔离？"><a href="#Web应用之间的类如何隔离？" class="headerlink" title="Web应用之间的类如何隔离？"></a>Web应用之间的类如何隔离？</h4><p>假如使用JVM默认的<code>AppClassLoader</code>来加载Web应用，<code>AppClassLoader</code>只能加载一个<code>Servlet</code>类，在加载第二个同名<code>Servlet</code>类时，<code>AppClassLoader</code>会返回第一个<code>Servlet</code>的Class实例，这是因为在<code>AppClassLoader</code>看来，同名的<code>Servlet</code>类只被加载一次。</p><p><strong>Tomcat的解决方案是自定义一个类加载器<code>WebAppClassLoader</code>，并且给每个Web应用创建一个类加载器实例。</strong>Context容器组件对应一个Web应用，<strong>因此每个Context容器负责创建和维护一个<code>WebAppClassLoader</code>加载器实例。</strong>不同的加载器加载出的类被认为是不同的类，即便它们的类名相同。这就相当于在Java虚拟机内部创建了一个互相隔离的Java类空间，每一个Web应用都有自己的类空间，Web应用之间通过各自的类加载器互相隔离。</p><h4 id="两个Web应用之间怎么共享类库，并且不能重复加载相同的类？"><a href="#两个Web应用之间怎么共享类库，并且不能重复加载相同的类？" class="headerlink" title="两个Web应用之间怎么共享类库，并且不能重复加载相同的类？"></a>两个Web应用之间怎么共享类库，并且不能重复加载相同的类？</h4><p>在双亲委派机制中，各个子加载器都可以通过父加载器去加载类，那么把需要共享的类放到父加载器的加载路径下就行。Tomcat又新增了一个类加载器<code>SharedClassLoader</code>，作为<code>WebAppClassLoader</code>的父加载器，专门来加载Web应用之间共享的类。如果<code>WebAppClassLoader</code>自己没有加载到某个类，就会委托父加载器<code>SharedClassLoader</code>去加载这个类，<code>SharedClassLoader</code>就会在指定目录下加载共享类，之后返回给<code>WebAppClassLoader</code>。</p><h4 id="如何隔离Tomcat本身的类和Web应用的类？"><a href="#如何隔离Tomcat本身的类和Web应用的类？" class="headerlink" title="如何隔离Tomcat本身的类和Web应用的类？"></a>如何隔离Tomcat本身的类和Web应用的类？</h4><p>要共享可以通过父子关系，要隔离需要兄弟关系。兄弟关系就是指两个类加载器时平行的，它们可能拥有同一个父类加载器，但是两个兄弟类加载器加载的类是隔离的。基于此Tomcat又设计了一个类加载器<code>CatalinaClassLoader</code>，专门加载Tomcat自身的类。</p><p>当Tomcat和各Web应用之间需要共享一些类时，再增加一个<code>CommonClassLoader</code>，作为<code>CatalinaClassLoader</code>和<code>SharedClassLoader</code>的父类加载器。<code>CommonClassLoader</code>能加载的类都可以被<code>CatalinaClassLoader</code>和<code>SharedClassLoader</code>使用，而<code>CatalinaClassLoader</code>和<code>SharedClassLoader</code>能加载的类则与对方互相隔离。<code>WebAppClassLoader</code>可以使用<code>SharedClassLoader</code>加载到的类，但各个<code>WebAppClassLoader</code>实例之间相互隔离。</p>]]></content:encoded>
      
      
      <category domain="http://zyanprocess.github.io/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/">后端开发</category>
      
      
      <category domain="http://zyanprocess.github.io/tags/Tomcat/">Tomcat</category>
      
      
      <comments>http://zyanprocess.github.io/2023/04/06/Tomcat/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>泛型&amp;通配符</title>
      <link>http://zyanprocess.github.io/2023/04/06/%E6%B3%9B%E5%9E%8B/</link>
      <guid>http://zyanprocess.github.io/2023/04/06/%E6%B3%9B%E5%9E%8B/</guid>
      <pubDate>Thu, 06 Apr 2023 06:39:52 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;泛型&quot;&gt;&lt;a href=&quot;#泛型&quot; class=&quot;headerlink&quot; title=&quot;泛型&quot;&gt;&lt;/a&gt;泛型&lt;/h1&gt;&lt;h2 id=&quot;什么是泛型&quot;&gt;&lt;a href=&quot;#什么是泛型&quot; class=&quot;headerlink&quot; title=&quot;什么是泛型&quot;&gt;&lt;/a&gt;什么是泛型&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Java泛型&lt;/strong&gt;是jdk 5中引入的一个新特性，可以增强代码的可读性以及稳定性。&lt;/p&gt;
&lt;p&gt;编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型。比如：&lt;code&gt;ArrayList&amp;lt;Persion&amp;gt; persons = new ArrayList&amp;lt;Persion&amp;gt;()&lt;/code&gt; 这行代码指明了该&lt;code&gt;ArrayList&lt;/code&gt;对象只能传入&lt;code&gt;Persion&lt;/code&gt;对象，如果传入其他类型的对象就会报错。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ArrayList&amp;lt;E&amp;gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;AbstractList&lt;/span&gt;&amp;lt;E&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;并且，原生&lt;code&gt;List&lt;/code&gt;返回类型是&lt;code&gt;Object&lt;/code&gt;，需要手动转换类型才能使用。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="什么是泛型"><a href="#什么是泛型" class="headerlink" title="什么是泛型"></a>什么是泛型</h2><p><strong>Java泛型</strong>是jdk 5中引入的一个新特性，可以增强代码的可读性以及稳定性。</p><p>编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型。比如：<code>ArrayList&lt;Persion&gt; persons = new ArrayList&lt;Persion&gt;()</code> 这行代码指明了该<code>ArrayList</code>对象只能传入<code>Persion</code>对象，如果传入其他类型的对象就会报错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br></pre></td></tr></table></figure><p>并且，原生<code>List</code>返回类型是<code>Object</code>，需要手动转换类型才能使用。</p><span id="more"></span><h2 id="泛型的使用方式"><a href="#泛型的使用方式" class="headerlink" title="泛型的使用方式"></a>泛型的使用方式</h2><p><strong>泛型类、泛型接口、泛型方法</strong></p><ol><li><p>泛型类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等参数</span></span><br><span class="line"><span class="comment">//在实例化泛型类时，必须指定T的具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Generic</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Generic</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Generic</span><span class="params">(T key)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体实例化泛型类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Generic&lt;Integer&gt; integerGeneric = <span class="keyword">new</span> <span class="title class_">Generic</span>&lt;&gt;(<span class="number">123456</span>);</span><br></pre></td></tr></table></figure></li><li><p>泛型接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Generator</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现泛型接口，不指定类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GeneratorImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现泛型接口，指定类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GeneratorImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>泛型方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">(E[] inputArray)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (E element : inputArray) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%s&quot;</span>,element);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建不同类型数组</span></span><br><span class="line">Integer[] intArray = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">String[] stringArray = &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;;</span><br><span class="line">printArray(intArray);</span><br><span class="line">printArray(stringArray);</span><br></pre></td></tr></table></figure></li></ol><h2 id="泛型擦除机制"><a href="#泛型擦除机制" class="headerlink" title="泛型擦除机制"></a>泛型擦除机制</h2><p><strong>Java的泛型时伪泛型，这是因为Java在编译期间，所有的泛型信息都会被擦掉，这也就是通常说的类型擦除</strong></p><p>编译器会在编译期间动态地将泛型<code>T</code>擦除为<code>Object</code>或者将<code>T extends xxx</code>擦除为其限定类型<code>xxx</code>。</p><p>因此，泛型本质上是编译器的行为，为了保证引入泛型机制但不创建新的类型，减少虚拟机的运行开销。编译器通过擦除将泛型类转化为一般类。</p><p>具体例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        list.add(<span class="number">12</span>);</span><br><span class="line">        <span class="comment">//1.编译期间直接添加会报错</span></span><br><span class="line">        <span class="comment">//list.add(&quot;a&quot;);</span></span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">List</span>&gt; clazz = list.getClass();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">add</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;add&quot;</span>, Object.class);</span><br><span class="line">        <span class="comment">//2.运行期间通过反射添加，是可以的</span></span><br><span class="line">        add.invoke(list, <span class="string">&quot;nihao&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(list);</span><br></pre></td></tr></table></figure><p>由于泛型擦除的问题，下面的方法重载会报错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(List&lt;String&gt; list)</span> &#123; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(List&lt;Integer&gt; list)</span> &#123; &#125;</span><br></pre></td></tr></table></figure><p>泛型擦除之后，<code>List&lt;String&gt; </code>与<code>List&lt;Integer&gt;</code>在编译之后都变成了<code>List</code>。</p><p><strong>既然编译器要把泛型擦除，为什么还要用泛型？不用Object？</strong></p><ul><li>使用泛型可以在编译期间进行类型检测。</li><li>使用<code>Object</code>类型需要手动添加强制类型转换，降低代码可读性，提高出错概率。</li><li>泛型可以使用自限定类型如<code>T extends Comparable</code>。</li></ul><h2 id="桥方法"><a href="#桥方法" class="headerlink" title="桥方法"></a>桥方法</h2><p>用于继承泛型类时保证多态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(T data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(T data)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Node.setData&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyNode</span> <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyNode</span><span class="params">(Integer data)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Node&lt;T&gt;泛型擦除后为setData(Object data)，而子类MyData中并没有重写该方法，所以编译器会加入该桥方法保证多态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(Object data)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyNode.setData&quot;</span>);</span><br><span class="line">        setData((Integer)data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(Integer data)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyNode.setData&quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>.setData(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>注意</strong></em> ： 桥方法为编译器自动生成，非手写。</p><h2 id="泛型的限制"><a href="#泛型的限制" class="headerlink" title="泛型的限制"></a>泛型的限制</h2><p>泛型的限制一般是由泛型擦除机制导致的。擦除为<code>Object</code>后无法进行类型判断</p><ul><li>只能声明，不能实例化<code>T</code>类型变量。</li><li>泛型参数不能是基本类型。因为基本类型不是<code>Object</code>子类，应该用基本类型对应的引用类型代替。</li><li>不能实例化泛型参数的数组。擦除后为<code>Object</code>后无法进行类型判断。</li><li>不能实例化泛型数组。</li><li>泛型无法使用<code>Instance of</code>和<code>getClass()</code>进行类型判断。</li><li>不能实现两个不同泛型参数的统一接口，擦除后多个父类的桥方法将冲突。</li><li>不能使用<code>static</code>修饰范型变量。</li></ul><h1 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h1><h2 id="什么是通配符"><a href="#什么是通配符" class="headerlink" title="什么是通配符"></a>什么是通配符</h2><p>泛型类型是固定的，某些场景下使用起来不太灵活，所以引入通配符的概念。</p><p><strong>通配符</strong>允许类型参数变化，用来解决泛型无法协变的问题。</p><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//限制类型为 Person的子类</span></span><br><span class="line">&lt;? <span class="keyword">extends</span> <span class="title class_">Person</span>&gt;</span><br><span class="line"><span class="comment">//限制类型为 Manager的子类</span></span><br><span class="line">&lt;? <span class="keyword">extends</span> <span class="title class_">Manager</span>&gt;</span><br></pre></td></tr></table></figure><h2 id="通配符？和常用的泛型T之间有什么区别？"><a href="#通配符？和常用的泛型T之间有什么区别？" class="headerlink" title="通配符？和常用的泛型T之间有什么区别？"></a>通配符？和常用的泛型T之间有什么区别？</h2><ul><li><code>T</code>可以用于声明变量或常量，而<code>？</code>不行。</li><li><code>T</code>一般用于声明泛型类或方法，通配符<code>？</code>一般用于泛型方法的调用代码和形参。</li><li><code>T</code>在编译期会被擦除为限定类型或<code>Object</code>，通配符用于捕获具体类型。</li></ul><h2 id="无界通配符"><a href="#无界通配符" class="headerlink" title="无界通配符"></a>无界通配符</h2><p>可以接收任何泛型类型数据，用于实现不依赖于具体类型参数的简单方法，可以捕获参数类型并交由泛型方法进行处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">(Person&lt;?&gt; p)</span>&#123;</span><br><span class="line">    <span class="comment">//自行定义逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>List&lt;?&gt;</code>和<code>List</code>区别</strong></p><ul><li><p><code>List&lt;?&gt; list</code>表示<code>list</code>是持有某种特定类型的List，但是不知道具体是哪种类型。因此我们添加元素进去时会报错。</p></li><li><p><code>List list</code>表示<code>list</code>是持有的元素的类型是<code>Object</code>，因此可以添加任何类型的对象，只不过编译器会有警告信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;sss&quot;</span>);<span class="comment">//报错</span></span><br><span class="line"><span class="type">List</span> <span class="variable">list1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list1.add(<span class="string">&quot;sss&quot;</span>);<span class="comment">//警告信息</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="上边界通配符和下边界通配符"><a href="#上边界通配符和下边界通配符" class="headerlink" title="上边界通配符和下边界通配符"></a>上边界通配符和下边界通配符</h2><p>在使用泛型的时候，还可以为传入的泛型类型实参进行上下边界的限制。</p><p>如： <strong>类型实参只准传入某种类型的父类或某种类型的子类。</strong></p><ul><li>**上边界通配符<code>extends</code>**可以实现泛型的向上转型。即传入的类型实参必须是指定类型的子类型</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//限制必须是Person类的子类</span></span><br><span class="line">&lt;? <span class="keyword">extends</span> <span class="title class_">Person</span>&gt;</span><br></pre></td></tr></table></figure><p>类型边界可以设置多个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;T <span class="keyword">extends</span> <span class="title class_">T1</span> &amp; T2&gt;</span><br></pre></td></tr></table></figure><ul><li>**下边界通配符<code>super</code>**与上边界通配符<code>extends</code>刚好相反，可以实现泛型的向下转型。即传入的类型实参必须是指定类型的父类型。</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//限制必须是Employee类的父类</span></span><br><span class="line">List&lt;? <span class="built_in">super</span> Employee&gt;</span><br></pre></td></tr></table></figure><p><strong><code>? extends xxx</code>和<code>? super xxx</code>有什么区别</strong></p><p>两者接收参数的范围不同。并且使用<code>? extends xxx</code>声明的泛型参数只能调用<code>get()</code>方法返回<code>xxx</code>类型，调用<code>set()</code>方法报错。使用<code>? super xxx</code>声明的泛型参数只能调用<code>set()</code>方法接收<code>xxx</code>类型，调用<code>get()</code>方法报错。</p><p><strong><code>T extends xxx</code>和<code>? extends xxx</code>有什么区别</strong></p><p><code>T extends xxx</code>用于定义泛型类和方法，擦除后为<code>xxx</code>类型。</p><p><code>? extends xxx</code>用户声明方法形参，接收<code>xxx</code>和其子类型。</p><p><strong><code>Class&lt;?&gt;</code>和<code>Class</code>有什么区别</strong></p><p>直接受用<code>Class</code>的话会有一个类型警告，使用<code>Class&lt;?&gt;</code>则没有。因为<code>Class</code>是一个泛型类，接收原生类型会产生警告。</p>]]></content:encoded>
      
      
      <category domain="http://zyanprocess.github.io/categories/Java/">Java</category>
      
      
      <category domain="http://zyanprocess.github.io/tags/%E6%B3%9B%E5%9E%8B%E5%92%8C%E9%80%9A%E9%85%8D%E7%AC%A6/">泛型和通配符</category>
      
      
      <comments>http://zyanprocess.github.io/2023/04/06/%E6%B3%9B%E5%9E%8B/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Java面向对象</title>
      <link>http://zyanprocess.github.io/2023/04/06/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</link>
      <guid>http://zyanprocess.github.io/2023/04/06/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</guid>
      <pubDate>Thu, 06 Apr 2023 05:19:33 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;内部类&quot;&gt;&lt;a href=&quot;#内部类&quot; class=&quot;headerlink&quot; title=&quot;内部类&quot;&gt;&lt;/a&gt;内部类&lt;/h1&gt;&lt;p&gt;在Java中，可以将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。&lt;/p&gt;
&lt;p&gt;广泛意义上的内部类一般来说包括这四种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;成员内部类&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;局部内部类&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;匿名内部类&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;静态内部类&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>在Java中，可以将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。</p><p>广泛意义上的内部类一般来说包括这四种：</p><ol><li><p>成员内部类</p></li><li><p>局部内部类</p></li><li><p>匿名内部类</p></li><li><p>静态内部类</p></li></ol><span id="more"></span><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>成员内部类是最普通的内部类，它的定义为位于另一个类的内部，形如下面的形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//外部使用成员内部类 </span></span><br><span class="line"><span class="type">Outer</span> <span class="variable">outter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>(<span class="number">100</span>); </span><br><span class="line">Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> outter.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        inner.say();       <span class="comment">//输出：200    </span></span><br><span class="line">           <span class="comment">//     100</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Outer</span><span class="params">(<span class="type">double</span> x)</span> &#123; </span><br><span class="line">        <span class="built_in">this</span>.x = x; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123; </span><br><span class="line">        <span class="keyword">private</span> <span class="type">double</span> x=<span class="number">200</span>;</span><br><span class="line">        <span class="comment">//内部类 </span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123; </span><br><span class="line">            System.out.println(x); </span><br><span class="line">            System.out.println(Outer.<span class="built_in">this</span>.x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>特点： 成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）。 不过要注意的是，当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。</p><p>如果要访问外部类的同名成员，需要以下面的形式进行访问：</p><p>外部类.this.成员变量</p><p>外部类.this.成员方法</p><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//局部内部类</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">PersonImp</span> <span class="keyword">implements</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.prinln(<span class="string">&quot;新编写的局部内部类的say方法内容&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        PersonImp p=<span class="keyword">new</span> <span class="title class_">PersonImp</span>();</span><br><span class="line">        <span class="comment">//这里像调用haha()方法，但是需要一个Person类，为此专门创建一个class文件类很浪费时间，所以使用局部内部类</span></span><br><span class="line">        haha(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">haha</span><span class="params">(Person p)</span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//窗口关闭</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    Frame f=<span class="keyword">new</span> <span class="title class_">Frame</span>(<span class="string">&quot;QQ登陆器&quot;</span>);</span><br><span class="line">    f.setVisible(<span class="literal">true</span>);</span><br><span class="line">    f.setSize(<span class="number">300</span>,<span class="number">200</span>);</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MyWindowListener</span> <span class="keyword">implements</span> <span class="title class_">WindowListener</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">windowClosing</span><span class="params">(WindowEvent e)</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;哈哈哈&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    MyWindowListener l=<span class="keyword">new</span> <span class="title class_">MyWindowListener</span>();</span><br><span class="line">    <span class="comment">//想要添加一个窗口关闭的事件，可以使用局部类</span></span><br><span class="line">    f.addWindowListener(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意:局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的。局部内部类也是只能访问final类型变量。</p><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>匿名内部类由于没有名字，所以它的创建方式有点儿奇怪。匿名内部类创建出来只能使用一次，和匿名对象类似。创建格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 父类构造器（参数列表）|实现接口（） &#123;</span><br><span class="line">    <span class="comment">//匿名内部类的类体部分 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//匿名内部类</span></span><br><span class="line">        Person p=<span class="keyword">new</span> <span class="title class_">Person</span>()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;锄禾日当午&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        haha(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">haha</span><span class="params">(Person p)</span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这里我们看到使用匿名内部类我们必须要继承一个父类或者实现一个接口，当然也仅能只继承一个父类或者实现一个接口。同时它也是没有class关键字，这是因为匿名内部类是直接使用new来生成一个对象的引用。当然这个引用是隐式的。</p><p>在使用匿名内部类的过程中，我们需要注意如下几点：</p><ol><li><p>使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或 者实现一个接口。</p></li><li><p>匿名内部类中是不能定义构造函数的。</p></li><li><p>匿名内部类中不能存在任何的静态成员变量和静态方法。</p></li><li><p>匿名内部类为局部内部类，所以局部内部类的所有限制同样对匿名内部类生效。</p></li><li><p>匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。</p></li><li><p>只能访问final型的局部变量。JDK1.8之后变量默认为final类型，但是只要第二次赋值，就不再是final类型的了。</p></li></ol><p>只能访问final类型的局部变量的原因，因为局部类编译的时候是单独编译成一个文件，所以在文件中有final变量的备份。</p><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。</p><p>静态内部类是不需要依赖于外部类对象的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非static成员变量或者方法。格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">        Book.<span class="type">Info</span> <span class="variable">info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>.Info(); </span><br><span class="line">        info.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span> &#123; </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Info</span> &#123; </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是一本书&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p><strong>抽象类</strong>必须使用abstract class声明</p><p>一个抽象类中可以没有抽象方法。抽象方法必须写在抽象类或者接口中。格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> class 类名&#123; <span class="comment">// 抽象类 </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><strong>抽象方法</strong>只声明而未实现的方法称为抽象方法（未实现指的是：没有“{}”方法体），抽象方法必须使用abstract关键字声明。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象类 </span></span><br><span class="line"><span class="keyword">abstract</span> class 类名&#123; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> 方法名() ; <span class="comment">// 抽象方法，只声明而未实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>不能被实例化</strong></p><p>在抽象类的使用中有几个原则：</p><ul><li>抽象类本身是不能直接进行实例化操作的，即：不能直接使用关键字new完成。 不能被我们创建，但是jvm虚拟器可以创建。</li><li>一个抽象类必须被子类所继承，被继承的子类（如果不是抽象类）则必须覆写(重写)抽象类中的全部抽象方法。</li></ul><p><strong>抽象类和普通类的区别</strong></p><ol><li><p>抽象类必须用public或protected修饰(如果为private修饰，那么子类则无法继承，也就无法实现其抽象方法）。 默认缺省为 public ；</p></li><li><p>抽象类不可以使用new关键字创建对象， 但是在子类创建对象时， 抽象父类也会被JVM实例化 ；</p></li><li><p>如果一个子类继承抽象类，那么必须实现其所有的抽象方法。如果有未实现的抽象方法，那么子类也必须定义为 abstract类 ；</p></li></ol><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>如果一个类中的全部方法都是抽象方法，全部属性都是全局常量，那么此时就可以将这个类定义成一个接口。</p><p>定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface 接口名称&#123; </span><br><span class="line">    全局常量 ; </span><br><span class="line">    抽象方法 ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>面向接口编程思想</strong>： 这种思想是接口是定义（规范，约束）与实现（名实分离的原则）的分离。</p><p>优点：</p><ol><li><p> 降低程序的耦合性</p></li><li><p> 易于程序的扩展</p></li><li><p> 有利于程序的维护</p></li></ol><p><strong>全局常量和抽象方法的简写</strong>： 因为接口本身都是由全局常量和抽象方法组成 ， 所以接口中的成员定义可以简写：</p><ol><li>全局常量编写时， 可以省略public static final 关键字，例如：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">INFO</span> <span class="operator">=</span> <span class="string">&quot;内容&quot;</span> ; </span><br><span class="line"><span class="comment">//简写后： </span></span><br><span class="line"><span class="type">String</span> <span class="variable">INFO</span> <span class="operator">=</span> <span class="string">&quot;内容&quot;</span> ; </span><br></pre></td></tr></table></figure><ol start="2"><li>抽象方法编写时， 可以省略 public abstract 关键字， 例如：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> ; </span><br><span class="line"><span class="comment">//简写后： </span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> ; </span><br></pre></td></tr></table></figure><p><strong>接口的实现 implements</strong></p><p>接口可以多实现：</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class 子类 implements 父接口<span class="number">1</span>,父接口<span class="number">2.</span>..&#123; &#125; </span><br><span class="line"><span class="comment">//以上的代码称为接口的实现。那么如果一个类即要实现接口，又要继承抽象类的话，则按照以下的格式编写即可： </span></span><br><span class="line">class 子类 extends 父类 implements 父接口<span class="number">1</span>,父接口<span class="number">2.</span>..&#123; &#125;</span><br></pre></td></tr></table></figure><p>注意：如果一个接口要想使用，必须依靠子类。 子类（如果不是抽象类的话）要实现接口中的所有抽象方法。</p><p><strong>接口的继承 extends</strong></p><p>继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类。</p><p>继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实力域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</p><p>继承的限制：Java中只有单继承，多重继承，没有多继承（即一个子类只能有一个父类）。多重继承通俗来讲就是爷爷、爸爸、孙子。</p><p>接口因为都是抽象部分， 不存在具体的实现， 所以允许多继承,例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">A</span>,B&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        student.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123;</span><br><span class="line">        supper();<span class="comment">//平时supper()可以省略，作用时默认调用父类的无参构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">        <span class="built_in">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span>+name+<span class="string">&quot;，年龄：&quot;</span>+age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    Student()&#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果为：</span></span><br><span class="line"><span class="comment">//姓名：张三，年龄：1</span></span><br></pre></td></tr></table></figure><p>student类实例化时先实例化person，默认调用的person的无参构造方法。</p><p><em><strong>super</strong></em> </p><ul><li>通过super可以访问父类的构造方法、属性、方法。</li><li>通过super调用父类构造方法的代码，必须写在第一行。</li><li>super和this调用构造函数时都需要放在第一行，但是两者不会同时使用，因为不可能调用自身构造函数的同时还调用父类的构造方法</li></ul><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>就是对象的多种表现形式</p><p><strong>多态的体现</strong></p><p>对象的多态性，从概念上非常好理解，在类中有子类和父类之分，子类就是父类的一种形态 ，对象多态性就从此而来。</p><p>ps: 方法的<strong>重载</strong>和<strong>重写</strong>也是多态的一种， 不过是方法的多态（相同方法名的多种形态）。</p><p><em><strong>重载：</strong></em> 一个类中方法的多态性体现 。</p><p><em><strong>重写：</strong></em> 子父类中方法的多态性体现。</p><p><strong>多态的使用：对象的类型转换</strong>：类似于基本数据类型的转换：</p><ul><li>向上转型：将子类实例变为父类实例 |- 格式：父类 父类对象 = 子类实例 ；</li><li>向下转型：将父类实例变为子类实例 |- 格式：子类 子类对象 = （子类）父类实例 ；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    Student student1=<span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        Nurse nurse1=<span class="keyword">new</span> <span class="title class_">Nurse</span>();</span><br><span class="line">        <span class="comment">//向上转型，父类引用指向子类对象</span></span><br><span class="line">    Person person1=student1;</span><br><span class="line">    person1.say();<span class="comment">//输出：我是学生</span></span><br><span class="line">        Person person2=nurse1;</span><br><span class="line">        person2.say();<span class="comment">//输出：我是护士</span></span><br><span class="line">        <span class="comment">//向下转型</span></span><br><span class="line">        Student student2=(Student)person1;</span><br><span class="line">        student2.say();<span class="comment">//输出：我是学生</span></span><br><span class="line">        <span class="comment">//向下转型需要注意的是不能把原来是护士的张三转成学生   例如：</span></span><br><span class="line">        Student student3=(Student)person2;</span><br><span class="line">        student3.say();<span class="comment">//此处会报错     </span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//向上转型比较高级的用法</span></span><br><span class="line">        Student student4=<span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        say(student4);<span class="comment">//输出：我是学生</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">(Person person)</span>&#123;</span><br><span class="line">        person.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是学生&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Nurse</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是护士&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：向上转型的对象，是通过父类调用子类覆盖或继承父类的方法，不是父类的方法。而且此时父类对象不能调用子类特有的方法。</p><h1 id="try-catch的处理流程"><a href="#try-catch的处理流程" class="headerlink" title="try+catch的处理流程"></a>try+catch的处理流程</h1><ol><li><p>一旦产生异常，则系统会自动产生一个异常类的实例化对象。</p></li><li><p> 那么，此时如果异常发生在try语句，则会自动找到匹配的catch语句执行，如果没有在try语句中，则会将异常抛出.</p></li><li><p> 所有的catch根据方法的参数匹配异常类的实例化对象，如果匹配成功，则表示由此catch进行处理。</p></li></ol><p><strong>finally</strong></p><p>在进行异常的处理之后，在异常的处理格式中还有一个finally语句，那么此语句将作为异常的统一出口，不管是否产生了异常，最终都要执行此段代码。</p><p>注意：finally在一些情况是不会被执行的，比如电脑被关机了（方法强制中断）。</p><p>唯一会使finally不执行的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        haha();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">haha</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            System.out.println(a/b);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;出现了异常&quot;</span>);</span><br><span class="line">            <span class="comment">//退出JVM</span></span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;锄禾日当午，汗滴禾下土&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果：出现了异常</span></span><br></pre></td></tr></table></figure><p>finally两种执行情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//案例一</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Person p=haha();</span><br><span class="line">        System.out.println(p.age);<span class="comment">//输出：28</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Person <span class="title function_">haha</span><span class="params">()</span>&#123;</span><br><span class="line">        Person p=<span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            p.age=<span class="number">18</span>;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            p.age=<span class="number">28</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">        <span class="type">int</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//finally会再return 准备数据返回的阶段执行，所以，无论是否return，finally都是执行。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//案例二</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> haha();</span><br><span class="line">        System.out.println(a);<span class="comment">//输出：10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">haha</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            a = <span class="number">20</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果和案例一不一样，是因为两者返回的数据类型不一样。</span></span><br><span class="line"><span class="comment">//案例一返回的是引用数据类型，在return的准备数据返回的阶段，备份的是堆内存地址，所以堆内存里的Person对象的age改变，return备份的值都会改变。</span></span><br><span class="line"><span class="comment">//案例二返回的是基本数据类型，在return的准备数据返回阶段，备份的是值，即10，所以无论栈内存中的a如何改变，都不会影响return备份的10。</span></span><br></pre></td></tr></table></figure><h1 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h1><p><strong>方法的重载</strong></p><ul><li>方法名称相同, 参数类型或参数长度不同或顺序不同, 可以完成方法的重载 ；</li><li>方法的重载与返回值无关；</li><li>方法的重载 ,可以让我们在不同的需求下, 通过传递不同的参数调用方法来完成具体的功能。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">z</span> <span class="operator">=</span> x + y;</span><br><span class="line"><span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">sum</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span>&#123;</span><br><span class="line"><span class="type">double</span> <span class="variable">z</span> <span class="operator">=</span> x + y;</span><br><span class="line"><span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>构造方法的重载</strong></p><ul><li>一个类, 可以存在多个构造方法 ；</li><li>参数列表的长度或类型不同即可完成构造方法的重载 ；</li><li>构造方法的重载 ,可以让我们在不同的创建对象的需求下, 调用不同的方法来完成对象的初始化 ；</li></ul><h1 id="重写（override）"><a href="#重写（override）" class="headerlink" title="重写（override）"></a>重写（override）</h1><ol><li>参数列表必须完全与被重写的方法相同；</li><li>返回类型必须完全与被重写的返回类型相同；</li><li>访问权限不能比父类被重写的方法的访问权限更低。例如父类方法为public，子类就不能为protected;</li><li>父类的成员方法只能被它的子类继承；</li><li>声明为static和private的方法不能被重写，但是能够被再次声明；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Student student=<span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        student.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;锄禾日当午，汗滴禾下土。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;锄禾日当午，玻璃好上霜。要不及时擦，整不好得脏。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果为：</span></span><br><span class="line"><span class="comment">//锄禾日当午，玻璃好上霜。要不及时擦，整不好得脏。</span></span><br></pre></td></tr></table></figure><p><strong>重写与重载的区别</strong></p><ul><li>重写方法名返回值相同参数相同；</li><li>重载方法名相同返回值相同参数可以不同，个数可以不同；</li><li>重写发生在父子类中，重载发生在一个类中；</li><li>重载与访问权限无关 ；</li><li>异常处理：重载与异常无关 ； 重写异常范围可以更小，但是不能抛出新的异常 ；</li></ul>]]></content:encoded>
      
      
      <category domain="http://zyanprocess.github.io/categories/Java/">Java</category>
      
      
      <category domain="http://zyanprocess.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象</category>
      
      
      <comments>http://zyanprocess.github.io/2023/04/06/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>设计模式</title>
      <link>http://zyanprocess.github.io/2023/04/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
      <guid>http://zyanprocess.github.io/2023/04/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
      <pubDate>Wed, 05 Apr 2023 12:54:31 GMT</pubDate>
      
      <description>&lt;ol&gt;
&lt;li&gt;面向接口编程，而不是面向实现。这个很重要，也是优雅的、可扩展的代码的第一步，这就不需要多说了吧。&lt;/li&gt;
&lt;li&gt;职责单一原则。每个类都应该只有一个单一的功能，并且该功能应该由这个类完全封装起来。&lt;/li&gt;
&lt;li&gt;对修改关闭，对扩展开放。对修改关闭是说，我们辛辛苦苦加班写出来的代码，该实现的功能和该修复的 bug 都完成了，别人可不能说改就改；对扩展开放就比较好理解了，也就是说在我们写好的代码基础上，很容易实现扩展。&lt;/li&gt;
&lt;/ol&gt;</description>
      
      
      
      <content:encoded><![CDATA[<ol><li>面向接口编程，而不是面向实现。这个很重要，也是优雅的、可扩展的代码的第一步，这就不需要多说了吧。</li><li>职责单一原则。每个类都应该只有一个单一的功能，并且该功能应该由这个类完全封装起来。</li><li>对修改关闭，对扩展开放。对修改关闭是说，我们辛辛苦苦加班写出来的代码，该实现的功能和该修复的 bug 都完成了，别人可不能说改就改；对扩展开放就比较好理解了，也就是说在我们写好的代码基础上，很容易实现扩展。</li></ol><span id="more"></span><h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><p>创建型模式的作用就是创建对象，说到创建一个对象，最熟悉的就是 new 一个对象，然后 set 相关属性。但是，在很多场景下，我们需要给客户端提供更加友好的创建对象的方式，尤其是那种我们定义了类，但是需要提供给其他开发者用的时候。</p><h3 id="简单工厂模式-字符串"><a href="#简单工厂模式-字符串" class="headerlink" title="简单工厂模式(字符串)"></a>简单工厂模式(字符串)</h3><blockquote><p>简单工厂模式：一又称为静态工厂方法（static Factory Method)模式，它属于类创建型模式。</p><p>在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有<strong>共同的父类</strong>。</p></blockquote><p>和名字一样简单，非常简单，直接上代码吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FoodFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Food <span class="title function_">makeFood</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">&quot;noodle&quot;</span>)) &#123;</span><br><span class="line">            <span class="type">Food</span> <span class="variable">noodle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LanZhouNoodle</span>();</span><br><span class="line">            noodle.addSpicy(<span class="string">&quot;more&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> noodle;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals(<span class="string">&quot;chicken&quot;</span>)) &#123;</span><br><span class="line">            <span class="type">Food</span> <span class="variable">chicken</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HuangMenChicken</span>();</span><br><span class="line">            chicken.addCondiment(<span class="string">&quot;potato&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> chicken;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>其中，LanZhouNoodle 和 HuangMenChicken 都继承自 Food。</em></p><p>简单地说，简单工厂模式通常就是这样，一个工厂类 xxxFactory，里面有一个静态方法，根据我们不同的参数，返回不同的派生自同一个父类（或实现同一接口）的实例对象。</p><blockquote><p>我们强调<strong>职责单一</strong>原则，一个类只提供一种功能，FoodFactory 的功能就是只要负责生产各种 Food。</p></blockquote><h3 id="工厂模式-多个工厂，中餐-字符串-西餐-字符串"><a href="#工厂模式-多个工厂，中餐-字符串-西餐-字符串" class="headerlink" title="工厂模式(多个工厂，中餐(字符串)西餐(字符串))"></a>工厂模式(多个工厂，中餐(字符串)西餐(字符串))</h3><p>简单工厂模式很简单，如果它能满足我们的需要，我觉得就不要折腾了。之所以需要引入工厂模式，是因为我们往往需要使用两个或两个以上的工厂。</p><blockquote><p>美国餐馆的套餐A</p><p>中国餐馆的套餐A</p><p>华为工厂生成</p><p>苹果工厂</p><p>定义一个用于创建对象的接口，让子类决定实例化哪个类。工厂方法使一个类的实例化延迟到其子类。</p><p>如Collection   LinkedList ArrayList  ListItr  Itr</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FoodFactory</span> &#123;</span><br><span class="line">    Food <span class="title function_">makeFood</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChineseFoodFactory</span> <span class="keyword">implements</span> <span class="title class_">FoodFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Food <span class="title function_">makeFood</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">&quot;A&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ChineseFoodA</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals(<span class="string">&quot;B&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ChineseFoodB</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AmericanFoodFactory</span> <span class="keyword">implements</span> <span class="title class_">FoodFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Food <span class="title function_">makeFood</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">&quot;A&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AmericanFoodA</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals(<span class="string">&quot;B&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AmericanFoodB</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，ChineseFoodA、ChineseFoodB、AmericanFoodA、AmericanFoodB 都派生自 Food。</p><p>客户端调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">APP</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 先选择一个具体的工厂</span></span><br><span class="line">        <span class="type">FoodFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChineseFoodFactory</span>();</span><br><span class="line">        <span class="comment">// 由第一步的工厂产生具体的对象，不同的工厂造出不一样的对象</span></span><br><span class="line">        <span class="type">Food</span> <span class="variable">food</span> <span class="operator">=</span> factory.makeFood(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然都是调用 makeFood(“A”)  制作 A 类食物，但是，不同的工厂生产出来的完全不一样。</p><p>第一步，我们需要选取合适的工厂，然后第二步基本上和简单工厂一样。</p><p><strong>核心在于，我们需要在第一步选好我们需要的工厂</strong>。比如，我们有 LogFactory 接口，实现类有 FileLogFactory 和 KafkaLogFactory，分别对应将日志写入文件和写入 Kafka 中，显然，我们客户端第一步就需要决定到底要实例化 FileLogFactory 还是 KafkaLogFactory，这将决定之后的所有的操作。</p><p>虽然简单，不过我也把所有的构件都画到一张图上，这样读者看着比较清晰：</p><p><img src="/2023/04/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1.png" alt="(factory-1)"></p><h3 id="抽象工厂模式-组合工厂"><a href="#抽象工厂模式-组合工厂" class="headerlink" title="抽象工厂模式(组合工厂)"></a>抽象工厂模式(组合工厂)</h3><p>当涉及到<strong>产品族</strong>的时候，就需要引入抽象工厂模式了。</p><p>一个经典的例子是造一台电脑。我们先不引入抽象工厂模式，看看怎么实现。</p><p>因为电脑是由许多的构件组成的，我们将 CPU 和主板进行抽象，然后 CPU 由 CPUFactory 生产，主板由 MainBoardFactory 生产，然后，我们再将 CPU 和主板搭配起来组合在一起，如下图：</p><p><img src="/2023/04/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2.png" alt="factory-1"></p><p>这个时候的客户端调用是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到 Intel 的 CPU</span></span><br><span class="line"><span class="type">CPUFactory</span> <span class="variable">cpuFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntelCPUFactory</span>();</span><br><span class="line"><span class="type">CPU</span> <span class="variable">cpu</span> <span class="operator">=</span> intelCPUFactory.makeCPU();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到 AMD 的主板</span></span><br><span class="line"><span class="type">MainBoardFactory</span> <span class="variable">mainBoardFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AmdMainBoardFactory</span>();</span><br><span class="line"><span class="type">MainBoard</span> <span class="variable">mainBoard</span> <span class="operator">=</span> mainBoardFactory.make();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组装 CPU 和主板</span></span><br><span class="line"><span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>(cpu, mainBoard);</span><br></pre></td></tr></table></figure><p>单独看 CPU 工厂和主板工厂，它们分别是前面我们说的<strong>工厂模式</strong>。这种方式也容易扩展，因为要给电脑加硬盘的话，只需要加一个 HardDiskFactory 和相应的实现即可，不需要修改现有的工厂。</p><p>但是，这种方式有一个问题，那就是如果 <strong>Intel 家产的 CPU 和 AMD 产的主板不能兼容使用</strong>，那么这代码就容易出错，因为客户端并不知道它们不兼容，也就会错误地出现随意组合。</p><p>下面就是我们要说的<strong>产品族</strong>的概念，它代表了组成某个产品的一系列附件的集合：</p><p><img src="/2023/04/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3.png" alt="abstract-factory-2"></p><p>当涉及到这种产品族的问题的时候，就需要抽象工厂模式来支持了。我们不再定义 CPU 工厂、主板工厂、硬盘工厂、显示屏工厂等等，我们直接定义电脑工厂，每个电脑工厂负责生产所有的设备，这样能保证肯定不存在兼容问题。</p><p><img src="/2023/04/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4.png" alt="abstract-factory-3"></p><p>这个时候，对于客户端来说，不再需要单独挑选 CPU厂商、主板厂商、硬盘厂商等，直接选择一家品牌工厂，品牌工厂会负责生产所有的东西，而且能保证肯定是兼容可用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 第一步就要选定一个“大厂”</span></span><br><span class="line">    <span class="type">ComputerFactory</span> <span class="variable">cf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AmdFactory</span>();</span><br><span class="line">    <span class="comment">// 从这个大厂造 CPU</span></span><br><span class="line">    <span class="type">CPU</span> <span class="variable">cpu</span> <span class="operator">=</span> cf.makeCPU();</span><br><span class="line">    <span class="comment">// 从这个大厂造主板</span></span><br><span class="line">    <span class="type">MainBoard</span> <span class="variable">board</span> <span class="operator">=</span> cf.makeMainBoard();</span><br><span class="line">  <span class="comment">// 从这个大厂造硬盘</span></span><br><span class="line">  <span class="type">HardDisk</span> <span class="variable">hardDisk</span> <span class="operator">=</span> cf.makeHardDisk();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 将同一个厂子出来的 CPU、主板、硬盘组装在一起</span></span><br><span class="line">    <span class="type">Computer</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>(cpu, board, hardDisk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，抽象工厂的问题也是显而易见的，比如我们要加个显示器，就需要修改所有的工厂，给所有的工厂都加上制造显示器的方法。这有点违反了<strong>对修改关闭，对扩展开放</strong>这个设计原则。</p><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式用得最多，错得最多。</p><p>饿汉模式最简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 首先，将 new Singleton() 堵死</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;;</span><br><span class="line">    <span class="comment">// 创建私有静态实例，意味着这个类第一次使用的时候就会进行创建</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 瞎写一个静态方法。这里想说的是，如果我们只是要调用 Singleton.getDate(...)，</span></span><br><span class="line">    <span class="comment">// 本来是不想要生成 Singleton 实例的，不过没办法，已经生成了</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title function_">getDate</span><span class="params">(String mode)</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>很多人都能说出饿汉模式的缺点，可是我觉得生产过程中，很少碰到这种情况：你定义了一个单例的类，不需要其实例，可是你却把一个或几个你会用到的静态方法塞到这个类中。</p></blockquote><p>饱汉模式最容易出错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 首先，也是先堵死 new Singleton() 这条路</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// 和饿汉模式相比，这边不需要先实例化出来，注意这里的 volatile，它是必须的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">// 这一次判断也是必须的，不然会有并发问题</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>双重检查，指的是两次检查 instance 是否为 null。</p><p>volatile 在这里是需要的，希望能引起读者的关注。</p><p>很多人不知道怎么写，直接就在 getInstance() 方法签名上加上 synchronized，这就不多说了，性能太差。</p></blockquote><p>嵌套类最经典，以后大家就用它吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton3</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// 主要是使用了 嵌套类可以访问外部类的静态属性和静态方法 的特性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Holder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton3</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton3</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton3 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，很多人都会把这个<strong>嵌套类</strong>说成是<strong>静态内部类</strong>，严格地说，内部类和嵌套类是不一样的，它们能访问的外部类权限也是不一样的。</p></blockquote><p>最后，我们说一下枚举，枚举很特殊，它在类加载的时候会初始化里面的所有的实例，而且 JVM 保证了它们不会再被实例化，所以它天生就是单例的。</p><p>虽然我们平时很少看到用枚举来实现单例，但是在 RxJava 的源码中，有很多地方都用了枚举来实现单例。</p><h3 id="建造者模式-一顿设置最后build"><a href="#建造者模式-一顿设置最后build" class="headerlink" title="建造者模式(一顿设置最后build)"></a>建造者模式(一顿设置最后build)</h3><p>经常碰见的 XxxBuilder 的类，通常都是建造者模式的产物。建造者模式其实有很多的变种，但是对于客户端来说，我们的使用通常都是一个模式的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Food</span> <span class="variable">food</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FoodBuilder</span>().a().b().c().build();</span><br><span class="line"><span class="type">Food</span> <span class="variable">food</span> <span class="operator">=</span> Food.builder().a().b().c().build();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>套路就是先 new 一个 Builder，然后可以链式地调用一堆方法，最后再调用一次 build() 方法，我们需要的对象就有了。</p><p>来一个中规中矩的建造者模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="comment">// 下面是“一堆”的属性</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String nickName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法私有化，不然客户端就会直接调用构造方法了</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">User</span><span class="params">(String name, String password, String nickName, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">        <span class="built_in">this</span>.nickName = nickName;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 静态方法，用于生成一个 Builder，这个不一定要有，不过写这个方法是一个很好的习惯，</span></span><br><span class="line">    <span class="comment">// 有些代码要求别人写 new User.UserBuilder().a()...build() 看上去就没那么好</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserBuilder <span class="title function_">builder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserBuilder</span>();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UserBuilder</span> &#123;</span><br><span class="line">        <span class="comment">// 下面是和 User 一模一样的一堆属性</span></span><br><span class="line">        <span class="keyword">private</span> String  name;</span><br><span class="line">        <span class="keyword">private</span> String password;</span><br><span class="line">        <span class="keyword">private</span> String nickName;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">UserBuilder</span><span class="params">()</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 链式调用设置各个属性值，返回 this，即 UserBuilder</span></span><br><span class="line">        <span class="keyword">public</span> UserBuilder <span class="title function_">name</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> UserBuilder <span class="title function_">password</span><span class="params">(String password)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.password = password;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> UserBuilder <span class="title function_">nickName</span><span class="params">(String nickName)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.nickName = nickName;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> UserBuilder <span class="title function_">age</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// build() 方法负责将 UserBuilder 中设置好的属性“复制”到 User 中。</span></span><br><span class="line">        <span class="comment">// 当然，可以在 “复制” 之前做点检验</span></span><br><span class="line">        <span class="keyword">public</span> User <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (name == <span class="literal">null</span> || password == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户名和密码必填&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (age &lt;= <span class="number">0</span> || age &gt;= <span class="number">150</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;年龄不合法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 还可以做赋予”默认值“的功能</span></span><br><span class="line">          <span class="keyword">if</span> (nickName == <span class="literal">null</span>) &#123;</span><br><span class="line">                nickName = name;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(name, password, nickName, age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>核心是：先把所有的属性都设置给 Builder，然后 build() 方法的时候，将这些属性<strong>复制</strong>给实际产生的对象。</p><p>看看客户端的调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">APP</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">d</span> <span class="operator">=</span> User.builder()</span><br><span class="line">                .name(<span class="string">&quot;foo&quot;</span>)</span><br><span class="line">                .password(<span class="string">&quot;pAss12345&quot;</span>)</span><br><span class="line">                .age(<span class="number">25</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>说实话，建造者模式的<strong>链式</strong>写法很吸引人，但是，多写了很多“无用”的 builder 的代码，感觉这个模式没什么用。不过，当属性很多，而且有些必填，有些选填的时候，这个模式会使代码清晰很多。我们可以在 <strong>Builder 的构造方法</strong>中强制让调用者提供必填字段，还有，在 build() 方法中校验各个参数比在 User 的构造方法中校验，代码要优雅一些。</p><blockquote><p>题外话，强烈建议读者使用 lombok，用了 lombok 以后，上面的一大堆代码会变成如下这样:</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String  name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String nickName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>怎么样，省下来的时间是不是又可以干点别的了。</p></blockquote><p>当然，如果你只是想要链式写法，不想要建造者模式，有个很简单的办法，User 的 getter 方法不变，所有的 setter 方法都让其 <strong>return this</strong> 就可以了，然后就可以像下面这样调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>().setName(<span class="string">&quot;&quot;</span>).setPassword(<span class="string">&quot;&quot;</span>).setAge(<span class="number">20</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>很多人是这么用的，但是笔者觉得其实这种写法非常地不优雅，不是很推荐使用。</p></blockquote><h3 id="原型模式-clone"><a href="#原型模式-clone" class="headerlink" title="原型模式(clone)"></a>原型模式(clone)</h3><p>这是我要说的创建型模式的最后一个设计模式了。</p><p>原型模式很简单：有一个原型<strong>实例</strong>，基于这个原型实例产生新的实例，也就是“克隆”了。</p><p>Object 类中有一个 clone() 方法，它用于生成一个新的对象，当然，如果我们要调用这个方法，java 要求我们的类必须先<strong>实现 Cloneable 接口</strong>，此接口没有定义任何方法，但是不这么做的话，在 clone() 的时候，会抛出 CloneNotSupportedException 异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>java 的克隆是浅克隆，碰到对象引用的时候，克隆出来的对象和原对象中的引用将指向同一个对象。通常实现深克隆的方法是将对象进行序列化，然后再进行反序列化。</p></blockquote><p>原型模式了解到这里我觉得就够了，各种变着法子说这种代码或那种代码是原型模式，没什么意义。</p><h3 id="创建型模式总结"><a href="#创建型模式总结" class="headerlink" title="创建型模式总结"></a>创建型模式总结</h3><p>创建型模式总体上比较简单，它们的作用就是为了产生实例对象，算是各种工作的第一步了，因为我们写的是<strong>面向对象</strong>的代码，所以我们第一步当然是需要创建一个对象了。</p><p>简单工厂模式最简单；工厂模式在简单工厂模式的基础上增加了选择工厂的维度，需要第一步选择合适的工厂；抽象工厂模式有产品族的概念，如果各个产品是存在兼容性问题的，就要用抽象工厂模式。单例模式就不说了，为了保证全局使用的是同一对象，一方面是安全性考虑，一方面是为了节省资源；建造者模式专门对付属性很多的那种类，为了让代码更优美；原型模式用得最少，了解和 Object 类中的 clone() 方法相关的知识即可。</p><h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><p>前面创建型模式介绍了创建对象的一些设计模式，这节介绍的结构型模式旨在通过改变代码结构来达到解耦的目的，使得我们的代码容易维护和扩展。</p><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>第一个要介绍的代理模式是最常使用的模式之一了，用一个代理来隐藏具体实现类的实现细节，通常还用于在真实的实现的前后添加一部分逻辑。</p><p>既然说是<strong>代理</strong>，那就要对客户端隐藏真实实现，由代理来负责客户端的所有请求。当然，代理只是个代理，它不会完成实际的业务逻辑，而是一层皮而已，但是对于客户端来说，它必须表现得就是客户端需要的真实实现。</p><blockquote><p>理解<strong>代理</strong>这个词，这个模式其实就简单了。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FoodService</span> &#123;</span><br><span class="line">    Food <span class="title function_">makeChicken</span><span class="params">()</span>;</span><br><span class="line">    Food <span class="title function_">makeNoodle</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FoodServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">FoodService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Food <span class="title function_">makeChicken</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">Food</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chicken</span>()</span><br><span class="line">        f.setChicken(<span class="string">&quot;1kg&quot;</span>);</span><br><span class="line">      f.setSpicy(<span class="string">&quot;1g&quot;</span>);</span><br><span class="line">      f.setSalt(<span class="string">&quot;3g&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Food <span class="title function_">makeNoodle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Food</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Noodle</span>();</span><br><span class="line">        f.setNoodle(<span class="string">&quot;500g&quot;</span>);</span><br><span class="line">        f.setSalt(<span class="string">&quot;5g&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理要表现得“就像是”真实实现类，所以需要实现 FoodService</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FoodServiceProxy</span> <span class="keyword">implements</span> <span class="title class_">FoodService</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 内部一定要有一个真实的实现类，当然也可以通过构造方法注入</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">FoodService</span> <span class="variable">foodService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FoodServiceImpl</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Food <span class="title function_">makeChicken</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我们马上要开始制作鸡肉了&quot;</span>);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 如果我们定义这句为核心代码的话，那么，核心代码是真实实现类做的，</span></span><br><span class="line">        <span class="comment">// 代理只是在核心代码前后做些“无足轻重”的事情</span></span><br><span class="line">        <span class="type">Food</span> <span class="variable">food</span> <span class="operator">=</span> foodService.makeChicken();</span><br><span class="line">      </span><br><span class="line">        System.out.println(<span class="string">&quot;鸡肉制作完成啦，加点胡椒粉&quot;</span>); <span class="comment">// 增强</span></span><br><span class="line">      food.addCondiment(<span class="string">&quot;pepper&quot;</span>);</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> food;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Food <span class="title function_">makeNoodle</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;准备制作拉面~&quot;</span>);</span><br><span class="line">        <span class="type">Food</span> <span class="variable">food</span> <span class="operator">=</span> foodService.makeNoodle();</span><br><span class="line">        System.out.println(<span class="string">&quot;制作完成啦&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> food;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>客户端调用，注意，我们要用代理来实例化接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里用代理类来实例化</span></span><br><span class="line"><span class="type">FoodService</span> <span class="variable">foodService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FoodServiceProxy</span>();</span><br><span class="line">foodService.makeChicken();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2023/04/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.png" alt="proxy"></p><p>我们发现没有，代理模式说白了就是做 <strong>“方法包装”</strong> 或做 <strong>“方法增强”</strong>。在面向切面编程中，其实就是动态代理的过程。比如 Spring 中，我们自己不定义代理类，但是 Spring 会帮我们动态来定义代理，然后把我们定义在 @Before、@After、@Around 中的代码逻辑动态添加到代理中。</p><p>说到动态代理，又可以展开说，Spring 中实现动态代理有两种，一种是如果我们的类定义了接口，如 UserService 接口和 UserServiceImpl 实现，那么采用 JDK 的动态代理，感兴趣的读者可以去看看 java.lang.reflect.Proxy 类的源码；另一种是我们自己没有定义接口的，Spring 会采用 CGLIB 进行动态代理，它是一个 jar 包，性能还不错。</p><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>说完代理模式，说适配器模式，是因为它们很相似，这里可以做个比较。</p><p>适配器模式做的就是，有一个接口需要实现，但是我们现成的对象都不满足，需要加一层适配器来进行适配。</p><p>适配器模式总体来说分三种：默认适配器模式、对象适配器模式、类适配器模式。先不急着分清楚这几个，先看看例子再说。</p><h4 id="1）默认适配器模式"><a href="#1）默认适配器模式" class="headerlink" title="1）默认适配器模式"></a>1）默认适配器模式</h4><p>首先，我们先看看最简单的适配器模式**默认适配器模式(Default Adapter)**是怎么样的。</p><p>我们用 Appache commons-io 包中的 FileAlterationListener 做例子，此接口定义了很多的方法，用于对文件或文件夹进行监控，一旦发生了对应的操作，就会触发相应的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FileAlterationListener</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">(<span class="keyword">final</span> FileAlterationObserver observer)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onDirectoryCreate</span><span class="params">(<span class="keyword">final</span> File directory)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onDirectoryChange</span><span class="params">(<span class="keyword">final</span> File directory)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onDirectoryDelete</span><span class="params">(<span class="keyword">final</span> File directory)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onFileCreate</span><span class="params">(<span class="keyword">final</span> File file)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onFileChange</span><span class="params">(<span class="keyword">final</span> File file)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onFileDelete</span><span class="params">(<span class="keyword">final</span> File file)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onStop</span><span class="params">(<span class="keyword">final</span> FileAlterationObserver observer)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此接口的一大问题是抽象方法太多了，如果我们要用这个接口，意味着我们要实现每一个抽象方法，如果我们只是想要监控文件夹中的<strong>文件创建</strong>和<strong>文件删除</strong>事件，可是我们还是不得不实现所有的方法，很明显，这不是我们想要的。</p><p>所以，我们需要下面的一个<strong>适配器</strong>，它用于实现上面的接口，但是<strong>所有的方法都是空方法</strong>，这样，我们就可以转而定义自己的类来继承下面这个类即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileAlterationListenerAdaptor</span> <span class="keyword">implements</span> <span class="title class_">FileAlterationListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">(<span class="keyword">final</span> FileAlterationObserver observer)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDirectoryCreate</span><span class="params">(<span class="keyword">final</span> File directory)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDirectoryChange</span><span class="params">(<span class="keyword">final</span> File directory)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDirectoryDelete</span><span class="params">(<span class="keyword">final</span> File directory)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFileCreate</span><span class="params">(<span class="keyword">final</span> File file)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFileChange</span><span class="params">(<span class="keyword">final</span> File file)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFileDelete</span><span class="params">(<span class="keyword">final</span> File file)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStop</span><span class="params">(<span class="keyword">final</span> FileAlterationObserver observer)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>比如我们可以定义以下类，我们仅仅需要实现我们想实现的方法就可以了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileMonitor</span> <span class="keyword">extends</span> <span class="title class_">FileAlterationListenerAdaptor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFileCreate</span><span class="params">(<span class="keyword">final</span> File file)</span> &#123;</span><br><span class="line">        <span class="comment">// 文件创建</span></span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFileDelete</span><span class="params">(<span class="keyword">final</span> File file)</span> &#123;</span><br><span class="line">        <span class="comment">// 文件删除</span></span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>MVC中也有默认适配器模式</p></blockquote><p>当然，上面说的只是适配器模式的其中一种，也是最简单的一种，无需多言。下面，再介绍<strong>“正统的”</strong>适配器模式。</p><h4 id="2）对象适配器模式-构造传入类似对象"><a href="#2）对象适配器模式-构造传入类似对象" class="headerlink" title="2）对象适配器模式(构造传入类似对象)"></a>2）<strong>对象</strong>适配器模式(构造传入类似对象)</h4><p>来看一个《Head First 设计模式》中的一个例子，我稍微修改了一下，看看怎么将鸡适配成鸭，这样鸡也能当鸭来用。因为，现在鸭这个接口，我们没有合适的实现类可以用，所以需要适配器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Duck</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quack</span><span class="params">()</span>; <span class="comment">// 鸭的呱呱叫</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>; <span class="comment">// 飞</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Cock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">gobble</span><span class="params">()</span>; <span class="comment">// 鸡的咕咕叫</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>; <span class="comment">// 飞</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WildCock</span> <span class="keyword">implements</span> <span class="title class_">Cock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">gobble</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;咕咕叫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;鸡也会飞哦&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>鸭接口有 fly() 和 quare() 两个方法，鸡 Cock 如果要冒充鸭，fly() 方法是现成的，但是鸡不会鸭的呱呱叫，没有 quack() 方法。这个时候就需要适配了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 毫无疑问，首先，这个适配器肯定需要 implements Duck，这样才能当做鸭来用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CockAdapter</span> <span class="keyword">implements</span> <span class="title class_">Duck</span> &#123;</span><br><span class="line">  </span><br><span class="line">    Cock cock;</span><br><span class="line">    <span class="comment">// 构造方法中需要一个鸡的实例，此类就是将这只鸡适配成鸭来用</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">CockAdapter</span><span class="params">(Cock cock)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cock = cock;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 实现鸭的呱呱叫方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quack</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 内部其实是一只鸡的咕咕叫</span></span><br><span class="line">        cock.gobble();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        cock.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>客户端调用很简单了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 有一只野鸡</span></span><br><span class="line">  <span class="type">Cock</span> <span class="variable">wildCock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WildCock</span>();</span><br><span class="line">  <span class="comment">// 成功将野鸡适配成鸭</span></span><br><span class="line">  <span class="type">Duck</span> <span class="variable">duck</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CockAdapter</span>(wildCock);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>到这里，大家也就知道了适配器模式是怎么回事了。无非是我们需要一只鸭，但是我们只有一只鸡，这个时候就需要定义一个适配器，由这个适配器来充当鸭，但是适配器里面的方法还是由鸡来实现的。</p><p>我们用一个图来简单说明下：</p><p><img src="/2023/04/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/6.png" alt="adapter-1"></p><p>上图应该还是很容易理解的，我就不做更多的解释了。下面，我们看看类适配模式怎么样的。</p><h4 id="3）类适配器模式-继承"><a href="#3）类适配器模式-继承" class="headerlink" title="3）类适配器模式(继承)"></a>3）<strong>类</strong>适配器模式(继承)</h4><p>废话少说，直接上图：</p><p><img src="/2023/04/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/workSpace\Blog\source_posts\设计模式\adapter-2.png" alt="adapter-1"></p><p>看到这个图，大家应该很容易理解的吧，通过继承的方法，适配器自动获得了所需要的大部分方法。这个时候，客户端使用更加简单，直接 <code>Target t = new SomeAdapter();</code> 就可以了。</p><h4 id="适配器模式总结"><a href="#适配器模式总结" class="headerlink" title="适配器模式总结"></a>适配器模式总结</h4><ol><li><p>类适配和对象适配的异同</p><blockquote><p>一个采用继承，一个采用组合；</p><p>类适配属于静态实现，对象适配属于组合的动态实现，对象适配需要多实例化一个对象。</p><p>总体来说，对象适配用得比较多。</p></blockquote></li><li><p>适配器模式和代理模式的异同</p><p>比较这两种模式，其实是比较对象适配器模式和代理模式，在代码结构上，它们很相似，都需要一个具体的实现类的实例。但是它们的目的不一样，代理模式做的是增强原方法的活；适配器做的是适配的活，为的是提供“把鸡包装成鸭，然后当做鸭来使用”，而鸡和鸭它们之间原本没有继承关系。</p><p><img src="https://www.javadoop.com/blogimages/design-pattern/adapter-5.png" alt="adapter-5"></p></li></ol><h3 id="桥接模式-笔和形状组合"><a href="#桥接模式-笔和形状组合" class="headerlink" title="桥接模式(笔和形状组合)"></a>桥接模式(笔和形状组合)</h3><p>理解桥梁模式，其实就是理解代码抽象和解耦。（继承改为关联关系）</p><p>我们首先需要一个桥梁，它是一个接口，定义提供的接口方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DrawAPI</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">int</span> radius, <span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后是一系列实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedPen</span> <span class="keyword">implements</span> <span class="title class_">DrawAPI</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">int</span> radius, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用红色笔画图，radius:&quot;</span> + radius + <span class="string">&quot;, x:&quot;</span> + x + <span class="string">&quot;, y:&quot;</span> + y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreenPen</span> <span class="keyword">implements</span> <span class="title class_">DrawAPI</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">int</span> radius, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用绿色笔画图，radius:&quot;</span> + radius + <span class="string">&quot;, x:&quot;</span> + x + <span class="string">&quot;, y:&quot;</span> + y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BluePen</span> <span class="keyword">implements</span> <span class="title class_">DrawAPI</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">int</span> radius, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用蓝色笔画图，radius:&quot;</span> + radius + <span class="string">&quot;, x:&quot;</span> + x + <span class="string">&quot;, y:&quot;</span> + y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>定义一个抽象类，此类的实现类都需要使用 DrawAPI：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> DrawAPI drawAPI;</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">Shape</span><span class="params">(DrawAPI drawAPI)</span> &#123;<span class="comment">//构造</span></span><br><span class="line">        <span class="built_in">this</span>.drawAPI = drawAPI;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>定义抽象类的子类：他可以注入笔</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 圆形</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> radius;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">(<span class="type">int</span> radius, DrawAPI drawAPI)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(drawAPI);<span class="comment">//调用父类的有参构造</span></span><br><span class="line">        <span class="built_in">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        drawAPI.draw(radius, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 长方形</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Rectangle</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, DrawAPI drawAPI)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(drawAPI);</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        drawAPI.draw(<span class="number">0</span>, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后，我们来看客户端演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Shape</span> <span class="variable">greenCircle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">10</span>, <span class="keyword">new</span> <span class="title class_">GreenPen</span>());</span><br><span class="line">    <span class="type">Shape</span> <span class="variable">redRectangle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="number">4</span>, <span class="number">8</span>, <span class="keyword">new</span> <span class="title class_">RedPen</span>());</span><br><span class="line">    greenCircle.draw();</span><br><span class="line">    redRectangle.draw();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可能大家看上面一步步还不是特别清晰，我把所有的东西整合到一张图上：</p><p><img src="/2023/04/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/workSpace\Blog\source_posts\设计模式\bridge-1.png" alt="bridge-1"></p><p>这回大家应该就知道抽象在哪里，怎么解耦了吧。桥梁模式的优点也是显而易见的，就是非常容易进行扩展。</p><blockquote><p>本节引用了<a href="https://www.tutorialspoint.com/design_pattern/bridge_pattern.htm">这里</a>的例子，并对其进行了修改。</p></blockquote><h3 id="装饰模式-实现同一接口，不断构造"><a href="#装饰模式-实现同一接口，不断构造" class="headerlink" title="装饰模式(实现同一接口，不断构造)"></a>装饰模式(实现同一接口，不断构造)</h3><p>要把装饰模式说清楚明白，不是件容易的事情。也许读者知道 <strong>Java IO</strong> 中的几个类是典型的装饰模式的应用，但是读者不一定清楚其中的关系，也许看完就忘了，希望看完这节后，读者可以对其有更深的感悟。</p><p>首先，我们先看一个简单的图，看这个图的时候，了解下层次结构就可以了：</p><blockquote><p>意思说说，他们都是实现了同一接口，但是每层都继承父类，然后包装父类对应的方法。举个例子：你也构造一个汽车，这个汽车多安了几排灯，最终的效果是开灯时不仅开启了原来的灯，也开启了你的灯。是不是跟代理有点类似？</p></blockquote><p><img src="/2023/04/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/workSpace\Blog\source_posts\设计模式\decorator-1.png"></p><p>我们来说说装饰模式的出发点，从图中可以看到，接口 <code>Component</code> 其实已经有了 <code>ConcreteComponentA</code> 和 <code>ConcreteComponentB</code> 两个实现类了，但是，如果我们要<strong>增强</strong>这两个实现类的话，我们就可以采用装饰模式，用具体的装饰器来<strong>装饰</strong>实现类，以达到增强的目的。</p><blockquote><p>从名字来简单解释下装饰器。既然说是装饰，那么往往就是<strong>添加小功能</strong>这种，而且，我们要满足可以添加多个小功能。最简单的，代理模式就可以实现功能的增强，但是代理不容易实现多个功能的增强，当然你可以说用代理包装代理的多层包装方式，但是那样的话代码就复杂了。</p></blockquote><p>首先明白一些简单的概念，从图中我们看到，所有的具体装饰者们 <strong>ConcreteDecorator</strong> 都可以作为 Component 来使用，因为它们都实现了 Component 中的所有接口。它们和 Component 实现类 ConcreteComponent 的区别是，它们只是装饰者，起<strong>装饰</strong>作用，也就是即使它们看上去牛逼轰轰，但是它们都只是在具体的实现中<strong>加了层皮来装饰</strong>而已。</p><blockquote><p>注意这段话中混杂在各个名词中的 Component 和 Decorator，别搞混了。</p></blockquote><p>下面来看看一个例子，先把装饰模式弄清楚，然后再介绍下 java io 中的装饰模式的应用。</p><p>最近大街上流行起来了“快乐柠檬”，我们把快乐柠檬的饮料分为三类：红茶、绿茶、咖啡，在这三大类的基础上，又增加了许多的口味，什么金桔柠檬红茶、金桔柠檬珍珠绿茶、芒果红茶、芒果绿茶、芒果珍珠红茶、烤珍珠红茶、烤珍珠芒果绿茶、椰香胚芽咖啡、焦糖可可咖啡等等，每家店都有很长的菜单，但是仔细看下，其实原料也没几样，但是可以搭配出很多组合，如果顾客需要，很多没出现在菜单中的饮料他们也是可以做的。</p><p>在这个例子中，红茶、绿茶、咖啡是最基础的饮料，其他的像金桔柠檬、芒果、珍珠、椰果、焦糖等都属于装饰用的。当然，在开发中，我们确实可以像门店一样，开发这些类：LemonBlackTea、LemonGreenTea、MangoBlackTea、MangoLemonGreenTea……但是，很快我们就发现，这样子干肯定是不行的，这会导致我们需要组合出所有的可能，而且如果客人需要在红茶中加双份柠檬怎么办？三份柠檬怎么办？</p><p>不说废话了，上代码。</p><p>首先，定义饮料抽象基类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Beverage</span> &#123;<span class="comment">//饮料</span></span><br><span class="line">  <span class="comment">// 返回描述</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">getDescription</span><span class="params">()</span>;</span><br><span class="line">  <span class="comment">// 返回价格</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后是三个基础饮料实现类，红茶、绿茶和咖啡：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlackTea</span> <span class="keyword">extends</span> <span class="title class_">Beverage</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;红茶&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreenTea</span> <span class="keyword">extends</span> <span class="title class_">Beverage</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;绿茶&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...<span class="comment">// 咖啡省略</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>定义调料，也就是装饰者的基类，此类必须继承自 Beverage：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调料</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Condiment</span> <span class="keyword">extends</span> <span class="title class_">Beverage</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后我们来定义柠檬、芒果等具体的调料，它们属于装饰者，毫无疑问，这些调料肯定都需要继承调料 Condiment 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lemon</span> <span class="keyword">extends</span> <span class="title class_">Condiment</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Beverage bevarage;</span><br><span class="line">    <span class="comment">// 这里很关键，需要传入具体的饮料，如需要传入没有被装饰的红茶或绿茶，</span></span><br><span class="line">    <span class="comment">// 当然也可以传入已经装饰好的芒果绿茶，这样可以做芒果柠檬绿茶</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Lemon</span><span class="params">(Beverage bevarage)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bevarage = bevarage;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 装饰</span></span><br><span class="line">        <span class="keyword">return</span> bevarage.getDescription() + <span class="string">&quot;, 加柠檬&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 装饰</span></span><br><span class="line">        <span class="keyword">return</span> beverage.cost() + <span class="number">2</span>; <span class="comment">// 加柠檬需要 2 元</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mango</span> <span class="keyword">extends</span> <span class="title class_">Condiment</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Beverage bevarage;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Mango</span><span class="params">(Beverage bevarage)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bevarage = bevarage;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bevarage.getDescription() + <span class="string">&quot;, 加芒果&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> beverage.cost() + <span class="number">3</span>; <span class="comment">// 加芒果需要 3 元</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...<span class="comment">// 给每一种调料都加一个类</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>看客户端调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 首先，我们需要一个基础饮料，红茶、绿茶或咖啡</span></span><br><span class="line">    <span class="type">Beverage</span> <span class="variable">beverage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GreenTea</span>();</span><br><span class="line">    <span class="comment">// 开始装饰</span></span><br><span class="line">    beverage = <span class="keyword">new</span> <span class="title class_">Lemon</span>(beverage); <span class="comment">// 先加一份柠檬</span></span><br><span class="line">    beverage = <span class="keyword">new</span> <span class="title class_">Mongo</span>(beverage); <span class="comment">// 再加一份芒果</span></span><br><span class="line"></span><br><span class="line">    System.out.println(beverage.getDescription() + <span class="string">&quot; 价格：￥&quot;</span> + beverage.cost());</span><br><span class="line">    <span class="comment">//&quot;绿茶, 加柠檬, 加芒果 价格：￥16&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果我们需要 <strong>芒果-珍珠-双份柠檬-红茶</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Beverage</span> <span class="variable">beverage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mongo</span>(<span class="keyword">new</span> <span class="title class_">Pearl</span>(<span class="keyword">new</span> <span class="title class_">Lemon</span>(<span class="keyword">new</span> <span class="title class_">Lemon</span>(<span class="keyword">new</span> <span class="title class_">BlackTea</span>()))));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>是不是很变态？</p><p>看看下图可能会清晰一些：</p><p><img src="/2023/04/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/workSpace\Blog\source_posts\设计模式\decorator-2.png" alt="decorator-2"></p><p>到这里，大家应该已经清楚装饰模式了吧。</p><h5 id="装饰模式应用：Stream"><a href="#装饰模式应用：Stream" class="headerlink" title="装饰模式应用：Stream"></a>装饰模式应用：Stream</h5><p>下面，我们再来说说 java IO 中的装饰模式。看下图 InputStream 派生出来的部分类：</p><p><img src="/2023/04/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/workSpace\Blog\source_posts\设计模式\decorator-3.png" alt="decorator-3"></p><p>我们知道 InputStream 代表了输入流，具体的输入来源可以是文件（FileInputStream）、管道（PipedInputStream）、数组（ByteArrayInputStream）等，这些就像前面奶茶的例子中的红茶、绿茶，属于基础输入流。</p><p>FilterInputStream 承接了装饰模式的关键节点，它的实现类是一系列装饰器，</p><ul><li>比如 BufferedInputStream 代表用缓冲来装饰，也就<strong>使得输入流具有了缓冲的功能</strong>，</li><li>LineNumberInputStream 代表用行号来装饰，在操作的时候就可以<strong>取得行号</strong>了，</li><li>DataInputStream 的装饰，使得我们可以从输入流转换为 java 中的<strong>基本类型值</strong>。</li></ul><p>当然，在 java IO 中，如果我们使用装饰器的话，就不太适合面向接口编程了，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LineNumberInputStream</span>(<span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;&quot;</span>)));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样的结果是，InputStream 还是不具有读取行号的功能，因为读取行号的方法定义在 LineNumberInputStream 类中。</p><p>我们应该像下面这样使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DataInputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(</span><br><span class="line">                              <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;&quot;</span>)));</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>所以说嘛，要找到纯的严格符合设计模式的代码还是比较难的。</p></blockquote><h3 id="门面模式-持有多个类似属性"><a href="#门面模式-持有多个类似属性" class="headerlink" title="门面模式(持有多个类似属性)"></a>门面模式(持有多个类似属性)</h3><p>门面模式（也叫外观模式，Facade Pattern）在许多源码中有使用，比如 slf4j 就可以理解为是门面模式的应用。这是一个简单的设计模式，我们直接上代码再说吧。</p><p>首先，我们定义一个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>定义几个实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;Circle::draw()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;Rectangle::draw()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>客户端调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 画一个圆形</span></span><br><span class="line">  <span class="type">Shape</span> <span class="variable">circle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">  circle.draw();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 画一个长方形</span></span><br><span class="line">  <span class="type">Shape</span> <span class="variable">rectangle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line">  rectangle.draw();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上是我们常写的代码，我们需要画圆就要先实例化圆，画长方形就需要先实例化一个长方形，然后再调用相应的 draw() 方法。</p><p>下面，我们看看怎么用门面模式来让客户端调用更加友好一些。</p><p>我们先定义一个门面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShapeMaker</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> Shape circle;</span><br><span class="line">   <span class="keyword">private</span> Shape rectangle;</span><br><span class="line">   <span class="keyword">private</span> Shape square;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">ShapeMaker</span><span class="params">()</span> &#123;</span><br><span class="line">      circle = <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">      rectangle = <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line">      square = <span class="keyword">new</span> <span class="title class_">Square</span>();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 下面定义一堆方法，具体应该调用什么方法，由这个门面来决定</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawCircle</span><span class="params">()</span>&#123;</span><br><span class="line">      circle.draw();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawRectangle</span><span class="params">()</span>&#123;</span><br><span class="line">      rectangle.draw();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawSquare</span><span class="params">()</span>&#123;</span><br><span class="line">      square.draw();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>看看现在客户端怎么调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">ShapeMaker</span> <span class="variable">shapeMaker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShapeMaker</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 客户端调用现在更加清晰了</span></span><br><span class="line">  shapeMaker.drawCircle();</span><br><span class="line">  shapeMaker.drawRectangle();</span><br><span class="line">  shapeMaker.drawSquare();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>门面模式的优点显而易见，客户端不再需要关注实例化时应该使用哪个实现类，直接调用门面提供的方法就可以了，因为门面类提供的方法的方法名对于客户端来说已经很友好了。</p><h3 id="组合模式-对象和list调用方法一致"><a href="#组合模式-对象和list调用方法一致" class="headerlink" title="组合模式(对象和list调用方法一致)"></a>组合模式(对象和list调用方法一致)</h3><blockquote><p>桥接模式是传入对象，组合模式是list和对象调用方法一致</p></blockquote><p>组合模式用于表示具有层次结构的数据，使得我们对单个对象和组合对象的访问具有一致性。</p><p>直接看一个例子吧，每个员工都有姓名、部门、薪水这些属性，同时还有下属员工集合（虽然可能集合为空），而下属员工和自己的结构是一样的，也有姓名、部门这些属性，同时也有他们的下属员工集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> String dept;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> salary;</span><br><span class="line">   <span class="keyword">private</span> List&lt;Employee&gt; subordinates; <span class="comment">// 下属</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String name,String dept, <span class="type">int</span> sal)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">      <span class="built_in">this</span>.dept = dept;</span><br><span class="line">      <span class="built_in">this</span>.salary = sal;</span><br><span class="line">      subordinates = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Employee&gt;();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Employee e)</span> &#123;</span><br><span class="line">      subordinates.add(e);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Employee e)</span> &#123;</span><br><span class="line">      subordinates.remove(e);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> List&lt;Employee&gt; <span class="title function_">getSubordinates</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> subordinates;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (<span class="string">&quot;Employee :[ Name : &quot;</span> + name + <span class="string">&quot;, dept : &quot;</span> + dept + <span class="string">&quot;, salary :&quot;</span> + salary+<span class="string">&quot; ]&quot;</span>);</span><br><span class="line">   &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通常，这种类需要定义 add(node)、remove(node)、getChildren() 这些方法。</p><blockquote><p>很多源码中如果出现xxxComposite的样式，就是组合模式</p></blockquote><h3 id="享元模式-map复用生成过的"><a href="#享元模式-map复用生成过的" class="headerlink" title="享元模式(map复用生成过的)"></a>享元模式(map复用生成过的)</h3><p>英文是 Flyweight Pattern，不知道是谁最先翻译的这个词，感觉这翻译真的不好理解，我们试着强行关联起来吧。Flyweight 是轻量级的意思，享元分开来说就是 共享 元器件，也就是复用已经生成的对象，这种做法当然也就是轻量级的了。</p><p>复用对象最简单的方式是，用一个 <code>HashMap </code>来存放每次新生成的对象。每次需要一个对象的时候，先到 HashMap 中看看有没有，如果没有，再生成新的对象，然后将这个对象放入 HashMap 中。</p><p>这种简单的代码我就不演示了。</p><h3 id="结构型模式总结"><a href="#结构型模式总结" class="headerlink" title="结构型模式总结"></a>结构型模式总结</h3><p>前面，我们说了代理模式、适配器模式、桥梁模式、装饰模式、门面模式、组合模式和享元模式。读者是否可以分别把这几个模式说清楚了呢？在说到这些模式的时候，心中是否有一个清晰的图或处理流程在脑海里呢？</p><p>代理模式是做方法增强的，适配器模式是把鸡包装成鸭这种用来适配接口的，桥梁模式做到了很好的解耦，装饰模式从名字上就看得出来，适合于装饰类或者说是增强类的场景，门面模式的优点是客户端不需要关心实例化过程，只要调用需要的方法即可，组合模式用于描述具有层次结构的数据，享元模式是为了在特定的场景中缓存已经创建的对象，用于提高性能。</p><h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><p>行为型模式关注的是各个类之间的相互作用，将职责划分清楚，使得我们的代码更加地清晰。</p><h3 id="策略模式-传入不同策略对象，但调用相同方法，线程池"><a href="#策略模式-传入不同策略对象，但调用相同方法，线程池" class="headerlink" title="策略模式(传入不同策略对象，但调用相同方法，线程池)"></a>策略模式(传入不同策略对象，但调用相同方法，线程池)</h3><p>策略模式太常用了，所以把它放到最前面进行介绍。它比较简单，我就不废话，直接用代码说事吧。</p><p>下面设计的场景是，我们需要画一个图形，可选的策略就是用红色笔来画，还是绿色笔来画，或者蓝色笔来画。</p><blockquote><p>洗衣机多种策略，线程池里的拒绝策略</p><p>定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。策略模式让算法独立于使用它的客户而变化，也称为政策模式。</p></blockquote><p>首先，先定义一个策略接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">int</span> radius, <span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后我们定义具体的几个策略：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedPen</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">int</span> radius, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;用红色笔画图，radius:&quot;</span> + radius + <span class="string">&quot;, x:&quot;</span> + x + <span class="string">&quot;, y:&quot;</span> + y);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreenPen</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">int</span> radius, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;用绿色笔画图，radius:&quot;</span> + radius + <span class="string">&quot;, x:&quot;</span> + x + <span class="string">&quot;, y:&quot;</span> + y);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BluePen</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">int</span> radius, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;用蓝色笔画图，radius:&quot;</span> + radius + <span class="string">&quot;, x:&quot;</span> + x + <span class="string">&quot;, y:&quot;</span> + y);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用策略的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> Strategy strategy;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Context</span><span class="params">(Strategy strategy)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.strategy = strategy;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">executeDraw</span><span class="params">(<span class="type">int</span> radius, <span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> strategy.draw(radius, x, y);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>客户端演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>(<span class="keyword">new</span> <span class="title class_">BluePen</span>()); <span class="comment">// 使用绿色笔来画</span></span><br><span class="line">  context.executeDraw(<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>放到一张图上，让大家看得清晰些：</p><p><img src="/2023/04/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/workSpace\Blog\source_posts\设计模式\strategy-1.png" alt="strategy-1"></p><p>这个时候，大家有没有联想到结构型模式中的桥梁模式，它们其实非常相似，我把桥梁模式的图拿过来大家对比下：</p><p><img src="/2023/04/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/workSpace\Blog\source_posts\设计模式\bridge-1.png" alt="bridge-1"></p><p>要我说的话，它们非常相似，桥梁模式在左侧加了一层抽象而已。<strong>桥梁模式的耦合更低</strong>，结构更复杂一些。</p><h3 id="观察者模式-注册观察者后通知"><a href="#观察者模式-注册观察者后通知" class="headerlink" title="观察者模式(注册观察者后通知)"></a>观察者模式(注册观察者后通知)</h3><p>观察者模式对于我们来说，真是再简单不过了。无外乎两个操作，观察者订阅自己关心的主题和主题有数据变化后通知观察者们。</p><p>首先，需要定义主题，每个主题需要持有观察者列表的引用，用于在数据变更的时候通知各个观察者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Observer&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> state;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">        <span class="comment">// 数据已变更，通知观察者们</span></span><br><span class="line">        notifyAllObservers();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注册观察者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通知观察者们</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyAllObservers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">            observer.update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>定义观察者接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Subject subject;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其实如果只有一个观察者类的话，接口都不用定义了，不过，通常场景下，既然用到了观察者模式，我们就是希望一个事件出来了，会有多个不同的类需要处理相应的信息。比如，订单修改成功事件，我们希望发短信的类得到通知、发邮件的类得到通知、处理物流信息的类得到通知等。</p><p>我们来定义具体的几个观察者类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinaryObserver</span> <span class="keyword">extends</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="comment">// 在构造方法中进行订阅主题</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BinaryObserver</span><span class="params">(Subject subject)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.subject = subject;</span><br><span class="line">        <span class="comment">// 通常在构造方法中将 this 发布出去的操作一定要小心</span></span><br><span class="line">        <span class="built_in">this</span>.subject.attach(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 该方法由主题类在数据变更的时候进行调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> Integer.toBinaryString(subject.getState());</span><br><span class="line">        System.out.println(<span class="string">&quot;订阅的数据发生变化，新的数据处理为二进制值为：&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HexaObserver</span> <span class="keyword">extends</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HexaObserver</span><span class="params">(Subject subject)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.subject = subject;</span><br><span class="line">        <span class="built_in">this</span>.subject.attach(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> Integer.toHexString(subject.getState()).toUpperCase();</span><br><span class="line">        System.out.println(<span class="string">&quot;订阅的数据发生变化，新的数据处理为十六进制值为：&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>客户端使用也非常简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 先定义一个主题</span></span><br><span class="line">    <span class="type">Subject</span> <span class="variable">subject1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Subject</span>();</span><br><span class="line">    <span class="comment">// 定义观察者</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">BinaryObserver</span>(subject1);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HexaObserver</span>(subject1);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 模拟数据变更，这个时候，观察者们的 update 方法将会被调用</span></span><br><span class="line">    subject.setState(<span class="number">11</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>output:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">订阅的数据发生变化，新的数据处理为二进制值为：1011</span><br><span class="line">订阅的数据发生变化，新的数据处理为十六进制值为：B</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当然，jdk 也提供了相似的支持，具体的大家可以参考 java.util.Observable 和 java.util.Observer 这两个类。</p><p>实际生产过程中，观察者模式往往用消息中间件来实现，如果要实现单机观察者模式，笔者建议读者使用 Guava 中的 EventBus，它有同步实现也有异步实现，本文主要介绍设计模式，就不展开说了。</p><p>还有，即使是上面的这个代码，也会有很多变种，大家只要记住核心的部分，那就是一定有一个地方存放了所有的观察者，然后在事件发生的时候，遍历观察者，调用它们的回调函数。</p><h3 id="责任链模式-靠next指针一直调用"><a href="#责任链模式-靠next指针一直调用" class="headerlink" title="责任链模式(靠next指针一直调用)"></a>责任链模式(靠next指针一直调用)</h3><p>责任链通常需要先建立一个单向链表，然后调用方只需要调用头部节点就可以了，后面会自动流转下去。比如流程审批就是一个很好的例子，只要终端用户提交申请，根据申请的内容信息，自动建立一条责任链，然后就可以开始流转了。</p><p>有这么一个场景，用户参加一个活动可以领取奖品，但是活动需要进行很多的规则校验然后才能放行，比如首先需要校验用户是否是新用户、今日参与人数是否有限额、全场参与人数是否有限额等等。设定的规则都通过后，才能让用户领走奖品。</p><blockquote><p>如果产品给你这个需求的话，我想大部分人一开始肯定想的就是，用一个 List 来存放所有的规则，然后 foreach 执行一下每个规则就好了。不过，读者也先别急，看看责任链模式和我们说的这个有什么不一样？</p></blockquote><p>首先，我们要定义流程上节点的基类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">RuleHandler</span> &#123;</span><br><span class="line">    <span class="comment">// 后继节点 ，如果把这个类命名为next你就更能理解了</span></span><br><span class="line">    <span class="keyword">protected</span> RuleHandler successor;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(Context context)</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSuccessor</span><span class="params">(RuleHandler successor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.successor = successor;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> RuleHandler <span class="title function_">getSuccessor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> successor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来，我们需要定义具体的每个节点了。</p><p>校验用户是否是新用户：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewUserRuleHandler</span> <span class="keyword">extends</span> <span class="title class_">RuleHandler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (context.isNewUser()) &#123;</span><br><span class="line">            <span class="comment">// 如果有后继节点的话，传递下去</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.getSuccessor() != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.getSuccessor().apply(context);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;该活动仅限新用户参与&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>校验用户所在地区是否可以参与：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocationRuleHandler</span> <span class="keyword">extends</span> <span class="title class_">RuleHandler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">allowed</span> <span class="operator">=</span> activityService.isSupportedLocation(context.getLocation);</span><br><span class="line">        <span class="keyword">if</span> (allowed) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.getSuccessor() != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.getSuccessor().apply(context);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;非常抱歉，您所在的地区无法参与本次活动&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>校验奖品是否已领完：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LimitRuleHandler</span> <span class="keyword">extends</span> <span class="title class_">RuleHandler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">remainedTimes</span> <span class="operator">=</span> activityService.queryRemainedTimes(context); <span class="comment">// 查询剩余奖品</span></span><br><span class="line">        <span class="keyword">if</span> (remainedTimes &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.getSuccessor() != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.getSuccessor().apply(userInfo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;您来得太晚了，奖品被领完了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">RuleHandler</span> <span class="variable">newUserHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NewUserRuleHandler</span>();</span><br><span class="line">    <span class="type">RuleHandler</span> <span class="variable">locationHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocationRuleHandler</span>();</span><br><span class="line">    <span class="type">RuleHandler</span> <span class="variable">limitHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LimitRuleHandler</span>();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 假设本次活动仅校验地区和奖品数量，不校验新老用户</span></span><br><span class="line">    locationHandler.setSuccessor(limitHandler);</span><br><span class="line">  </span><br><span class="line">    locationHandler.apply(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码其实很简单，就是先定义好一个链表，然后在通过任意一节点后，如果此节点有后继节点，那么传递下去。</p><p>至于它和我们前面说的用一个 List 存放需要执行的规则的做法有什么异同，留给读者自己琢磨吧。</p><h3 id="模板方法模式-回调"><a href="#模板方法模式-回调" class="headerlink" title="模板方法模式(回调)"></a>模板方法模式(回调)</h3><p>在含有继承结构的代码中，模板方法模式是非常常用的。</p><p>通常会有一个抽象类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractTemplate</span> &#123;</span><br><span class="line">    <span class="comment">// 这就是模板方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">templateMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        init();</span><br><span class="line">        apply(); <span class="comment">// 这个是重点</span></span><br><span class="line">        end(); <span class="comment">// 可以作为钩子方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init 抽象层已经实现，子类也可以选择覆写&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 留给子类实现</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">end</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>模板方法中调用了 3 个方法，其中 apply() 是抽象方法，子类必须实现它，其实模板方法中有几个抽象方法完全是自由的，我们也可以将三个方法都设置为抽象方法，让子类来实现。也就是说，模板方法只负责定义第一步应该要做什么，第二步应该做什么，第三步应该做什么，至于怎么做，由子类来实现。</p><p>我们写一个实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteTemplate</span> <span class="keyword">extends</span> <span class="title class_">AbstractTemplate</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类实现抽象方法 apply&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">end</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我们可以把 method3 当做钩子方法来使用，需要的时候覆写就可以了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>客户端调用演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">AbstractTemplate</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteTemplate</span>();</span><br><span class="line">    <span class="comment">// 调用模板方法</span></span><br><span class="line">    t.templateMethod();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码其实很简单，基本上看到就懂了，关键是要学会用到自己的代码中。</p><blockquote><p>如果在源码中看到了final修饰符，而该方法中调用了其他源码，很可能就是模板方法模式</p></blockquote><h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><p>update: 2017-10-19</p><p>废话我就不说了，我们说一个简单的例子。商品库存中心有个最基本的需求是减库存和补库存，我们看看怎么用状态模式来写。</p><p>核心在于，我们的关注点不再是 Context 是该进行哪种操作，而是关注在这个 Context 会有哪些操作。</p><p>定义状态接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAction</span><span class="params">(Context context)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>定义减库存的状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeductState</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAction</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;商品卖出，准备减库存&quot;</span>);</span><br><span class="line">        context.setState(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//... 执行减库存的具体操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Deduct State&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>定义补库存状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RevertState</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAction</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;给此商品补库存&quot;</span>);</span><br><span class="line">        context.setState(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//... 执行加库存的具体操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Revert State&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>前面用到了 context.setState(this)，我们来看看怎么定义 Context 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> State state;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Context</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(State state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们来看下客户端调用，大家就一清二楚了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 我们需要操作的是 iPhone X</span></span><br><span class="line">    <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>(<span class="string">&quot;iPhone X&quot;</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 看看怎么进行补库存操作</span></span><br><span class="line">  <span class="type">State</span> <span class="variable">revertState</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RevertState</span>();</span><br><span class="line">  revertState.doAction(context);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 同样的，减库存操作也非常简单</span></span><br><span class="line">  <span class="type">State</span> <span class="variable">deductState</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeductState</span>();</span><br><span class="line">  deductState.doAction(context);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果需要我们可以获取当前的状态</span></span><br><span class="line">    <span class="comment">// context.getState().toString();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>读者可能会发现，在上面这个例子中，如果我们不关心当前 context 处于什么状态，那么 Context 就可以不用维护 state 属性了，那样代码会简单很多。</p><p>不过，商品库存这个例子毕竟只是个例，我们还有很多实例是需要知道当前 context 处于什么状态的。</p><h3 id="行为型模式总结"><a href="#行为型模式总结" class="headerlink" title="行为型模式总结"></a>行为型模式总结</h3><p>行为型模式部分介绍了策略模式、观察者模式、责任链模式、模板方法模式和状态模式，其实，经典的行为型模式还包括备忘录模式、命令模式等，但是它们的使用场景比较有限，而且本文篇幅也挺大了，我就不进行介绍了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> 学习设计模式的目的是为了让我们的代码更加的优雅、易维护、易扩展。这次整理这篇文章，让我重新审视了一下各个设计模式，对我自己而言收获还是挺大的。我想，文章的最大收益者一般都是作者本人，为了写一篇文章，需要巩固自己的知识，需要寻找各种资料，而且，自己写过的才最容易记住，也算是我给读者的建议吧。</p><p>（全文完）</p><h3 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h3><blockquote><p>精髓：传入一个对象，在我们这里调用该对象的方法，而该方法会把this指针传进去</p></blockquote><p>传入访问者，遍历元素调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体元素类, 用于访问者访问</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ElementA</span> <span class="keyword">implements</span> <span class="title class_">IElement</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ElementA</span><span class="params">(String name)</span> &#123;  <span class="built_in">this</span>.name = name;  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 接受访问者访问自己  */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(IVisitor visitor)</span> &#123;</span><br><span class="line">        visitor.viewElementA(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;   <span class="keyword">return</span> name; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 具体访问者类, 用于访问元素 **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VisitorA</span> <span class="keyword">implements</span>  <span class="title class_">IVisitor</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">viewElementA</span><span class="params">(ElementA elementA)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A访问者 访问 A元素: &quot;</span> + elementA.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">viewElementB</span><span class="params">(ElementB elementB)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A访问者 访问 B元素: &quot;</span> + elementB.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ElementStructure</span> &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;IElement&gt; listElement = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addElement</span><span class="params">(IElement element)</span> &#123;</span><br><span class="line">        lstElement.add(element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(IVisitor visitor)</span> &#123;<span class="comment">// 传入访问者</span></span><br><span class="line">        <span class="keyword">for</span> (IElement element : listElement) &#123;</span><br><span class="line">            element.accept(visitor);<span class="comment">//visitor.viewElementA(this);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://zyanprocess.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</category>
      
      
      <category domain="http://zyanprocess.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</category>
      
      
      <comments>http://zyanprocess.github.io/2023/04/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>学习Docker</title>
      <link>http://zyanprocess.github.io/2023/04/05/%E5%AD%A6%E4%B9%A0Docker/</link>
      <guid>http://zyanprocess.github.io/2023/04/05/%E5%AD%A6%E4%B9%A0Docker/</guid>
      <pubDate>Wed, 05 Apr 2023 09:01:25 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;docker概念&quot;&gt;&lt;a href=&quot;#docker概念&quot; class=&quot;headerlink&quot; title=&quot;docker概念&quot;&gt;&lt;/a&gt;docker概念&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;一句话概括容器：容器就是将软件打包成标准化单元，以用于开发、交付和部署。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;容器镜像是轻量的、可执行的独立软件包&lt;/strong&gt; ，包含软件运行所需的所有内容：代码、运行时环境、系统工具、系统库和设置。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;容器化软件适用于基于 Linux 和 Windows 的应用，在任何环境中都能够始终如一地运行。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;容器赋予了软件独立性&lt;/strong&gt;，使其免受外在环境差异（例如，开发和预演环境的差异）的影响，从而有助于减少团队间在相同基础设施上运行不同软件时的冲突。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;容器虚拟化的是操作系统而不是硬件，容器之间是共享同一套操作系统资源的。虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统。因此容器的隔离级别会稍低一些。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="docker概念"><a href="#docker概念" class="headerlink" title="docker概念"></a>docker概念</h1><p><strong>一句话概括容器：容器就是将软件打包成标准化单元，以用于开发、交付和部署。</strong></p><ul><li><strong>容器镜像是轻量的、可执行的独立软件包</strong> ，包含软件运行所需的所有内容：代码、运行时环境、系统工具、系统库和设置。</li><li><strong>容器化软件适用于基于 Linux 和 Windows 的应用，在任何环境中都能够始终如一地运行。</strong></li><li><strong>容器赋予了软件独立性</strong>，使其免受外在环境差异（例如，开发和预演环境的差异）的影响，从而有助于减少团队间在相同基础设施上运行不同软件时的冲突。</li></ul><p>容器虚拟化的是操作系统而不是硬件，容器之间是共享同一套操作系统资源的。虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统。因此容器的隔离级别会稍低一些。</p><span id="more"></span><p><img src="/2023/04/05/%E5%AD%A6%E4%B9%A0Docker/pic1.png"></p><h2 id="docker-思想："><a href="#docker-思想：" class="headerlink" title="docker 思想："></a>docker 思想：</h2><ul><li><strong>集装箱</strong></li><li><strong>标准化</strong>：① 运输方式 ② 存储方式 ③ API 接口</li><li><strong>隔离</strong></li></ul><h2 id="为什么要用docker"><a href="#为什么要用docker" class="headerlink" title="为什么要用docker"></a>为什么要用docker</h2><ul><li><p><strong>Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 “这段代码在我机器上没问题啊” 这类问题；——一致的运行环境</strong></p></li><li><p><strong>可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。——更快速的启动时间</strong></p></li><li><p><strong>避免公用的服务器，资源会容易受到其他用户的影响。——隔离性</strong></p></li><li><p><strong>善于处理集中爆发的服务器使用压力；——弹性伸缩，快速扩展</strong></p></li><li><p><strong>可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。——迁移方便</strong></p></li><li><p><strong>使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。——持续交付和部署</strong></p></li></ul><h1 id="docker基本概念"><a href="#docker基本概念" class="headerlink" title="docker基本概念"></a>docker基本概念</h1><h2 id="镜像：-一个特殊的文件系统"><a href="#镜像：-一个特殊的文件系统" class="headerlink" title="镜像： 一个特殊的文件系统"></a>镜像： 一个特殊的文件系统</h2><p><strong>操作系统分为内核和用户空间</strong>。对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 root 文件系统。</p><p><strong>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。</strong> 镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p><p>Docker 设计时，就充分利用 <strong>Union FS</strong> 的技术，将其设计为<strong>分层存储的架构</strong> 。镜像实际是由多层文件系统联合组成。</p><p><strong>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。</strong> 比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p><p>分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</p><h2 id="容器：-镜像运行时的实体"><a href="#容器：-镜像运行时的实体" class="headerlink" title="容器： 镜像运行时的实体"></a>容器： 镜像运行时的实体</h2><p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，<strong>容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等</strong> 。</p><p><strong>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。前面讲过镜像使用的是分层存储，容器也是如此。</strong></p><p><strong>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</strong></p><p>按照 Docker 最佳实践的要求，<strong>容器不应该向其存储层内写入任何数据</strong> ，容器存储层要保持无状态化。<strong>所有的文件写入操作，都应该使用数据卷（Volume）、或者绑定宿主目录</strong>，在这些位置的读写会跳过容器存储层，直接对宿主(或网络存储)发生读写，其性能和稳定性更高。数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此， <strong>使用数据卷后，容器可以随意删除、重新 run ，数据却不会丢失。</strong></p><h2 id="仓库-集中存放镜像文件的地方"><a href="#仓库-集中存放镜像文件的地方" class="headerlink" title="仓库: 集中存放镜像文件的地方"></a>仓库: 集中存放镜像文件的地方</h2><p>镜像构建完成后，可以很容易的在当前宿主上运行，但是， <strong>如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。</strong></p><p>一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。所以说：<strong>镜像仓库是 Docker 用来集中存放镜像文件的地方类似于我们之前常用的代码仓库。</strong></p><p>通常，<strong>一个仓库会包含同一个软件不同版本的镜像</strong>，而<strong>标签就常用于对应该软件的各个版本</strong> 。我们可以通过<code>&lt;仓库名&gt;:&lt;标签&gt;</code>的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签.。</p><p><strong>这里补充一下 Docker Registry 公开服务和私有 Docker Registry 的概念：</strong></p><p><strong>Docker Registry 公开服务</strong> 是开放给用户使用、允许用户管理镜像的 Registry 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。</p><h1 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h1><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker version <span class="comment"># 查看docker版本</span></span><br><span class="line">docker images <span class="comment"># 查看所有已下载镜像，等价于：docker image ls 命令</span></span><br><span class="line">docker container <span class="built_in">ls</span> <span class="comment">#查看所有容器</span></span><br><span class="line">docker ps <span class="comment">#查看正在运行的容器</span></span><br><span class="line">docker image prune <span class="comment"># 清理临时的、没有被使用的镜像文件。-a, --all: 删除所有没有用的镜像，而不仅仅是临时文件；</span></span><br></pre></td></tr></table></figure><h2 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker search mysql <span class="comment"># 查看mysql相关镜像</span></span><br><span class="line">docker pull mysql:5.7 <span class="comment"># 拉取mysql镜像</span></span><br><span class="line">docker image <span class="built_in">ls</span> <span class="comment"># 查看所有已下载镜像</span></span><br></pre></td></tr></table></figure><h2 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h2><p>通过 <code>docker rmi [image]</code>（等价于<code>docker image rm [image]</code>）删除镜像之前首先要确保这个镜像没有被容器引用（可以通过标签名称或者镜像 ID删除）。通过我们前面讲的<code>docker ps</code>命令即可查看。</p><p>当镜像被容器引用时，首先需要通过<code>docker stop id</code>或者<code>docker stop 镜像名</code>暂停这个容器。</p><p>然后查看镜像的id： <code>docker images</code></p><p>最后通过IMAGE ID或者镜像名字就可以删除： <code>docker rmi id</code></p><h2 id="docker-容器指令"><a href="#docker-容器指令" class="headerlink" title="docker 容器指令"></a>docker 容器指令</h2><ul><li><p>通过镜像运行一个容器： <code>docker run run tomcat:8.0-jre8</code></p><p>通过该方式运行的 tomcat 是不能直接被外部访问的，因为容器具有隔离性，若是想直接通过 8080 端口访问容器内部的 tomcat，则需要对宿主机端口与容器内的端口进行映射：</p><p><code>docker run -p 8080:8080 tomcat:8.0-jre8</code></p><p>解释一下这两个端口的作用(<code>8080:8080</code>)，第一个 8080 为宿主机端口，第二个 8080 为容器内的端口，外部访问 8080 端口就会通过映射访问容器内的 8080 端口。</p><p>容器还能够以后台的方式运行，这样就不会占用终端：</p><p><code>docker run -d -p 8080:8080 tomcat:8.0-jre8</code></p><p>启动容器时默认会给容器一个名称，但这个名称其实是可以设置的，使用指令：</p><p><code>docker run -d -p 8080:8080 --name tomcat01 tomcat:8.0-jre8</code></p><table><thead><tr><th>参数</th><th>功能</th></tr></thead><tbody><tr><td>-a</td><td>参数会将运行和非运行的容器全部列举出来</td></tr><tr><td>-q</td><td>只查询正在运行的容器 id</td></tr><tr><td>-aq</td><td>查询运行和非运行的所有容器</td></tr></tbody></table></li><li><p>容器启动： <code>docker start 容器id</code></p></li><li><p>让已经停止运行的容器运行： <code>docker restart 容器id/名称</code></p></li><li><p>重启容器： <code>docker stop 容器id/名称</code></p></li><li><p>停止容器： <code>docker kill 容器id/名称</code></p></li><li><p>查看容器运行日志： <code>docker logs 容器id/名称</code>  </p><table><thead><tr><th>参数</th><th>功能</th></tr></thead><tbody><tr><td>-f</td><td>实时显示日志信息</td></tr><tr><td>-t</td><td>显示日志的时间戳</td></tr></tbody></table></li><li><p>查看容器运行了哪些进程： <code>docker top 容器id/名称</code></p></li></ul>]]></content:encoded>
      
      
      <category domain="http://zyanprocess.github.io/categories/docker/">docker</category>
      
      
      <category domain="http://zyanprocess.github.io/tags/docker/">docker</category>
      
      
      <comments>http://zyanprocess.github.io/2023/04/05/%E5%AD%A6%E4%B9%A0Docker/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>学习Linux</title>
      <link>http://zyanprocess.github.io/2023/04/04/%E5%AD%A6%E4%B9%A0Linux/</link>
      <guid>http://zyanprocess.github.io/2023/04/04/%E5%AD%A6%E4%B9%A0Linux/</guid>
      <pubDate>Tue, 04 Apr 2023 07:37:00 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;linux简单介绍&quot;&gt;&lt;a href=&quot;#linux简单介绍&quot; class=&quot;headerlink&quot; title=&quot;linux简单介绍&quot;&gt;&lt;/a&gt;linux简单介绍&lt;/h1&gt;&lt;p&gt;linux是一个开源、免费的&lt;font color=&quot;red&quot;&gt;操作系统&lt;/font&gt;，其稳定性、安全性、处理多并发得到业界认可。&lt;/p&gt;
&lt;p&gt;linux的特点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;免费、开源的&lt;/li&gt;
&lt;li&gt;支持多线程、多用户&lt;/li&gt;
&lt;li&gt;安全性好&lt;/li&gt;
&lt;li&gt;堆内存和文件管理优越&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="linux简单介绍"><a href="#linux简单介绍" class="headerlink" title="linux简单介绍"></a>linux简单介绍</h1><p>linux是一个开源、免费的<font color="red">操作系统</font>，其稳定性、安全性、处理多并发得到业界认可。</p><p>linux的特点</p><ul><li>免费、开源的</li><li>支持多线程、多用户</li><li>安全性好</li><li>堆内存和文件管理优越</li></ul><span id="more"></span><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><table><thead><tr><th>常用快捷键</th><th>功能</th></tr></thead><tbody><tr><td>ctrl + c</td><td>停止进程</td></tr><tr><td>ctrl + l</td><td>清屏；彻底清屏是：reset</td></tr><tr><td>ctrl + q</td><td>退出</td></tr><tr><td>善于用tab键</td><td>提示(更重要的是可以防止敲错)</td></tr><tr><td>上下键</td><td>查找执行过的命令</td></tr><tr><td>ctrl + alt</td><td>linux和Windows之间切换</td></tr></tbody></table><h2 id="文件目录类"><a href="#文件目录类" class="headerlink" title="文件目录类"></a>文件目录类</h2><ul><li><p><em><strong>pwd</strong></em> 显示当前工作目录的绝对路径</p></li><li><p><em><strong>ls</strong></em> 列出目录的内容</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-a</td><td>全部的文件，连同隐藏档( 开头为 . 的文件) 一起列出来(常用)</td></tr><tr><td>-l</td><td>长数据串列出，包含文件的属性与权限等等数据；(常用)等价于“ll”</td></tr></tbody></table></li><li><p><em><strong>cd</strong></em> 切换目录</p><table><thead><tr><th>参数</th><th>功能</th></tr></thead><tbody><tr><td>cd 绝对路径</td><td>切换路径</td></tr><tr><td>cd 相对路径</td><td>切换路径</td></tr><tr><td>cd ~或者cd</td><td>回到自己的家目录</td></tr><tr><td>cd -</td><td>回到上一次所在目录</td></tr><tr><td>cd ..</td><td>回到当前目录的上一级目录</td></tr><tr><td>cd -P</td><td>跳转到实际物理路径，而非快捷方式路径</td></tr></tbody></table></li><li><p><em><strong>mkdir</strong></em> 创建一个新目录</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-p</td><td>创建多层目录</td></tr></tbody></table></li><li><p><em><strong>rmdir</strong></em> 删除一个空的目录</p></li><li><p><em><strong>touch</strong></em> 创建空文件</p></li><li><p><em><strong>cp</strong></em> 复制文件或目录</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-r</td><td>递归复制整个文件夹</td></tr></tbody></table><p>案例：<code>cp -r xiyou/dssz/ ./</code></p></li><li><p><em><strong>rm</strong></em> 删除文件或目录</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-r</td><td>递归删除目录中所有内容</td></tr><tr><td>-f</td><td>强制执行删除操作，而不提示用于进行确认。</td></tr><tr><td>-v</td><td>显示指令的详细执行过程</td></tr></tbody></table><p>删除目录中的内容： <code>rm xiyou/mingjie/test.txt</code></p><p>递归删除目录中的所有内容： <code>rm -rf xiyou/</code></p></li><li><p><em><strong>mv</strong></em> 移动文件与目录或重命名</p><p>重命名： <code>mv test/test.txt test/test1.txt</code></p><p>移动文件： <code>mv test/test.txt ./</code></p></li><li><p><em><strong>cat</strong></em> 查看文件内容</p><table><thead><tr><th>选项</th><th>功能描述</th></tr></thead><tbody><tr><td>-n</td><td>显示所有行的行号，包括空行。</td></tr></tbody></table></li><li><p><em><strong>more</strong></em> 文件内容分屏查看器</p><table><thead><tr><th>操作</th><th>功能说明</th></tr></thead><tbody><tr><td>空白键 (space)</td><td>代表向下翻一页；</td></tr><tr><td>Enter</td><td>代表向下翻『一行』；</td></tr><tr><td>q</td><td>代表立刻离开 more ，不再显示该文件内容。</td></tr><tr><td>Ctrl+F</td><td>向下滚动一屏</td></tr><tr><td>Ctrl+B</td><td>返回上一屏</td></tr><tr><td>=</td><td>输出当前行的行号</td></tr><tr><td>:f</td><td>输出文件名和当前行的行号</td></tr></tbody></table></li><li><p><em><strong>echo</strong></em> 输出内容到控制台</p><p>-e：  支持反斜线控制的字符转换</p><table><thead><tr><th>控制字符</th><th>作用</th></tr></thead><tbody><tr><td>\</td><td>输出\本身</td></tr><tr><td>\n</td><td>换行符</td></tr><tr><td>\t</td><td>制表符，也就是Tab键</td></tr></tbody></table><p>案例： <code>echo &quot;hello\tworld&quot;       -&gt;         hello\tworld</code></p><p>​            <code>echo -e &quot;hello\tworld&quot;       -&gt;         hello     world</code></p></li><li><p><em><strong>head</strong></em> 显示文件头部内容</p><p>案例： <code>head -n 2 test.txt</code>   显示文件的头2行</p></li><li><p><em><strong>tail</strong></em> 输出文件尾部内容</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-n&lt;行数&gt;</td><td>输出文件尾部n行内容</td></tr><tr><td>-f</td><td>显示文件最新追加的内容，监视文件变化</td></tr></tbody></table><p>查看文件尾1行内容： <code>tail -n 1 test.txt</code></p><p>实时追踪该文档的所有更新： <code>tail -f test.txt</code></p></li><li><p><em><strong>&gt;</strong></em> 输出重定向和 ***&gt;&gt;***追加</p><p>将<em><strong>ls</strong></em>查看信息写入到文件中： <code>ls -l &gt; test.txt</code></p><p>将<em><strong>ls</strong></em>查看信息追加到文件中： <code>ls -l &gt;&gt; test.txt</code></p><p>将文件1的内容覆盖到文件2： <code>cat 1.txt &gt; 2.txt</code></p><p>采用<em><strong>echo</strong></em>将hello单词追加到文件中： <code>echo hello &gt;&gt; test.txt</code></p></li><li><p><em><strong>ln</strong></em> 软链接，主要存放了链接其他文件的路径</p><p>删除软链接： <code>rm -rf 软链接名</code>，而不是<code>rm -rf 软链接名/</code></p><p>如果使用 <code>rm -rf 软链接名/</code>  删除，会把软链接对应的真实目录下内容删掉</p></li><li><p><em><strong>history</strong></em> 查看已经执行过的历史命令</p></li></ul><h2 id="时间日期类"><a href="#时间日期类" class="headerlink" title="时间日期类"></a>时间日期类</h2><ul><li><p><em><strong>date</strong></em> 显示当前时间</p><p>显示当前时间年月日： <code>date +%Y%m%d</code></p><p>显示当前时间年月日时分秒： <code>date +%Y%m%d %H:%M:%S</code></p><p>显示前一天： <code>date -d &#39;1 days ago&#39;</code></p><p>显示明天时间： <code>date -d &#39;-1 days ago&#39;</code></p><p>设置系统当前时间： <code>date -s &quot;2017-06-19 20:52:18&quot;</code></p></li><li><p><em><strong>cal</strong></em> 查看当前月日历</p><p>查看2023年的日历： <code>cal 2023</code></p></li></ul><h2 id="用户管理命令"><a href="#用户管理命令" class="headerlink" title="用户管理命令"></a>用户管理命令</h2><ul><li><p><em><strong>useradd</strong></em> 添加新用户</p><p>案例： <code>useradd test</code></p></li><li><p><em><strong>passwd</strong></em> 设置用户密码</p><p>案例： <code>passwd test</code></p></li><li><p><em><strong>id</strong></em> 查看用户是否存在</p><p>案例： <code>id test</code></p></li><li><p><em><strong>cat /etc/passwd</strong></em> 查看创建了哪些用户</p></li><li><p><em><strong>su</strong></em> 切换用户</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>su 用户名称</td><td>切换用户，只能获得用户的执行权限，不能获得环境变量</td></tr><tr><td>su - 用户名称</td><td>切换到用户并获得该用户的环境变量及执行权限</td></tr></tbody></table></li><li><p><em><strong>userdel</strong></em> 删除用户</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-r</td><td>删除用户的同时，删除与用户相关的所有文件。</td></tr></tbody></table></li><li><p><em><strong>who</strong></em> 查看登录用户信息</p><p>显示自身用户名称： <code>whoami</code></p><p>显示登陆用户的用户名： <code>who am i</code></p></li><li><p><em><strong>sudo</strong></em> 设置普通用户具有root权限</p><p>案例： <code>sudo mkdir module</code></p></li><li><p><em><strong>usermod</strong></em> 修改用户</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-g</td><td>修改用户的初始登录组，给定的组必须存在。默认组id是1。</td></tr></tbody></table><p>案例： <code>usermod -g root test  usermod -g 用户组 用户名</code></p></li></ul><h2 id="用户组管理命令"><a href="#用户组管理命令" class="headerlink" title="用户组管理命令"></a>用户组管理命令</h2><ul><li><p><em><strong>groupadd</strong></em> 新增组</p><p>案例： <code>groupadd test</code></p></li><li><p><em><strong>groupdel</strong></em> 删除组</p><p>案例： <code>groupdel test</code></p></li><li><p><em><strong>groupmod</strong></em> 修改组</p><p>案例： <code>groupmod -n test test1</code></p></li><li><p><em><strong>cat /etc/group</strong></em> 查看创建了哪些组</p></li></ul><h2 id="文件权限类"><a href="#文件权限类" class="headerlink" title="文件权限类"></a>文件权限类</h2><ul><li><strong>从左到右的10个字符表示，如下图所示：</strong></li></ul><p><img src="/2023/04/04/%E5%AD%A6%E4%B9%A0Linux/pic1.png" alt="1680675595556"></p><p>如果没有权限，就会出现减号[ - ]而已。从左至右用0-9这些数字来表示:</p><ol><li><p>0首位表示类型</p><p>在Linux中第一个字符代表这个文件是目录、文件或链接文件等等</p><p>- 代表文件</p><p> d 代表目录</p><p> l 链接文档(link file)；</p></li><li><p>第1-3位确定属主（该文件的所有者）拥有该文件的权限。—User</p></li><li><p>第4-6位确定属组（所有者的同组用户）拥有该文件的权限，—Group</p></li><li><p>第7-9位确定其他用户拥有该文件的权限 —Other</p></li></ol><ul><li><strong>rxw作用文件和目录的不同解释</strong></li></ul><ol><li><p>作用到文件：</p><p>[ r ] 代表可读(read): 可以读取，查看</p><p>[ w ] 代表可写(write): 可以修改，但是不代表可以删除该文件，删除一个文件的前提条件是对该文件所在的目录有写权限，才能删除该文件.</p><p>[ x ] 代表可执行(execute):可以被系统执行</p></li><li><p>作用到目录：</p><p>[ r ] 代表可读(read): 可以读取，ls查看目录内容</p><p>[ w ] 代表可写(write): 可以修改，目录内创建+删除+重命名目录</p><p>[ x ] 代表可执行(execute):可以进入该目录</p></li></ol><ul><li><strong>文件属性基本介绍，如下图所示</strong></li></ul><p><img src="/2023/04/04/%E5%AD%A6%E4%B9%A0Linux/pic2.png"></p><ol><li>如果查看到是文件：链接数指的是硬链接个数。</li><li>如果查看的是文件夹：链接数指的是子文件夹个数。</li></ol><ul><li><p><em><strong>chmod</strong></em> 改变权限</p><p><img src="/2023/04/04/%E5%AD%A6%E4%B9%A0Linux/pic3.png"></p><p>u:所有者  g:所有组  o:其他人  a:所有人(u、g、o的总和)</p><p>r=4     w=2     x=1                  rwx=4+2+1=7</p><p>修改文件使其所属主用户具有执行权限： <code>chmod u+x test.txt</code></p><p>修改文件使其所属组用户具有执行权限： <code>chmod g+x test.txt</code></p><p>修改文件所属主用户执行权限,并使其他用户具有执行权限： <code>chmod u-x, o+x test.txt</code></p><p>数字的方式，设置文件所有者、所属组、其他用户都具有可读可写可执行权限： <code>chmod 777 test.txt</code></p><p>修改整个文件夹里面的所有文件的所有者、所属组、其他用户都具有可读可写可执行权限。</p><p><code>chmod -R 777 test/</code></p></li><li><p><em><strong>chown</strong></em> 改变所有者</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-R</td><td>递归操作</td></tr></tbody></table><p>案例： <code>chown test test.txt    chown [选项] [最终用户] [文件或目录] </code></p></li><li><p><em><strong>chgrp</strong></em> 改变所属组</p><p>案例： <code>chgrp test test.txt    chgrp [最终用户组] [文件或目录]</code></p></li></ul><h2 id="搜索查找类"><a href="#搜索查找类" class="headerlink" title="搜索查找类"></a>搜索查找类</h2><ul><li><p><em><strong>find</strong></em> 查找目录或文件</p><table><thead><tr><th align="left">选项</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left">-name&lt;查询方式&gt;</td><td align="left">按照指定的文件名查找模式查找文件</td></tr><tr><td align="left">-user&lt;用户名&gt;</td><td align="left">查找属于指定用户名所有文件</td></tr><tr><td align="left">-size&lt;文件大小&gt;</td><td align="left">按照指定的文件大小查找文件,单位为:    <strong>b</strong> —— 块（512字节）   <strong>c</strong> —— 字节   <strong>w</strong> —— 字（2字节）   <strong>k</strong> —— 千字节   <strong>M</strong> —— 兆字节   <strong>G</strong> —— 吉字节</td></tr></tbody></table><p>按文件名查找： <code>find test/ -name *.txt</code></p><p>按拥有者查找： <code>find test/ -user test</code></p><p>按文件大小查找： <code>find /home -szie +204800        +n 大于  -n小于   n等于</code></p></li><li><p><em><strong>locate</strong></em> 快速定位文件路径</p></li><li><p><em><strong>grep</strong></em> 过滤查找及“|”管道符</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-n</td><td>显示匹配行及行号。</td></tr></tbody></table><p>查找某文件在第几行： <code>ls | grep -n test</code></p></li></ul><h2 id="压缩和解压缩类"><a href="#压缩和解压缩类" class="headerlink" title="压缩和解压缩类"></a>压缩和解压缩类</h2><ul><li><p><em><strong>gzip/gunzip</strong></em> 压缩</p><p><code>gzip test.txt      压缩文件，只能将文件压缩为*.gz文件</code></p><p><code>gunzip test.txt.gz     解压缩文件命令</code></p></li><li><p><em><strong>zip/unzip</strong></em> 压缩</p><table><thead><tr><th>zip选项</th><th>功能</th></tr></thead><tbody><tr><td>-r</td><td>压缩目录</td></tr></tbody></table><table><thead><tr><th>unzip选项</th><th>功能</th></tr></thead><tbody><tr><td>-d&lt;目录&gt;</td><td>指定解压后文件的存放目录</td></tr></tbody></table><p>压缩 test.txt和test1.txt，压缩后的名称为mypackage.zip： <code>zip mypackage.zip test.txt test1.txt</code></p><p>解压mypackage.zip到指定目录： <code>unzip mypackage.zip -d /opt</code></p></li><li><p><em><strong>tar</strong></em> 打包</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-c</td><td>产生.tar打包文件</td></tr><tr><td>-v</td><td>显示详细信息</td></tr><tr><td>-f</td><td>指定压缩后的文件名</td></tr><tr><td>-z</td><td>打包同时压缩</td></tr><tr><td>-x</td><td>解包.tar文件</td></tr><tr><td>-C</td><td>解压到指定目录</td></tr></tbody></table><p>压缩多个文件： <code>tar -zcvf test.tar.gz test1.txt test2.txt</code></p><p>压缩目录： <code>tar -zcvf test.tar.gz test/</code></p><p>解压到当前目录： <code>tar -zxvf test.tar.gz</code></p><p>解压到指定目录： <code>tar -zxvf test.tar.gz -C /opt</code></p></li></ul><h2 id="磁盘分区类"><a href="#磁盘分区类" class="headerlink" title="磁盘分区类"></a>磁盘分区类</h2><ul><li><p><em><strong>df</strong></em> 查看磁盘空间使用情况</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-h</td><td>以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；</td></tr></tbody></table></li><li><p><em><strong>fdisk</strong></em> 查看分区。必须在root用户下才能使用</p></li><li><p><em><strong>Isblk</strong></em> 查看设备挂载情况</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-f</td><td>查看详细的设备挂载情况，显示文件系统信息</td></tr></tbody></table></li><li><p><em><strong>mount/umount</strong></em> 挂载/卸载</p></li></ul><h2 id="进程线程类"><a href="#进程线程类" class="headerlink" title="进程线程类"></a>进程线程类</h2><ul><li><p><em><strong>ps</strong></em> 查看当前系统进程状态</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-a</td><td>选择所有进程</td></tr><tr><td>-u</td><td>显示所有用户的所有进程</td></tr><tr><td>-x</td><td>显示没有终端的进程</td></tr></tbody></table><p>查看系统中所有进程： <code>ps -aux | grep xxx</code></p><p>查看父子进程之间的关系： <code>ps -ef | grep xxx</code></p></li><li><p><em><strong>kill</strong></em> 终止进程</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-9</td><td>表示强迫进程立即停止</td></tr></tbody></table></li><li><p><em><strong>pstree</strong></em> 查看进程树</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-p</td><td>显示进程的PID</td></tr><tr><td>-u</td><td>显示进程的所属用户</td></tr></tbody></table><p>显示进程pid： <code>pstree -p</code></p><p>显示进程所属用户： <code>pstree -u</code></p></li><li><p><em><strong>top</strong></em> 查看系统健康状态</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-d 秒数</td><td>指定top命令每隔几秒更新。默认是3秒在top命令的交互模式当中可以执行的命令：</td></tr><tr><td>-i</td><td>使top不显示任何闲置或者僵死进程。</td></tr><tr><td>-p</td><td>通过指定监控进程ID来仅仅监控某个进程的状态。</td></tr></tbody></table></li><li><p><em><strong>netstat</strong></em> 显示网络统计信息和端口占用情况</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-n</td><td>拒绝显示别名，能显示数字的全部转化成数字</td></tr><tr><td>-l</td><td>仅列出有在listen（监听）的服务状态</td></tr><tr><td>-p</td><td>表示显示哪个进程在调用</td></tr></tbody></table><p>查看该进程网络信息： <code>netstat -anp | grep 进程号</code></p><p>查看网络端口号占用情况： <code>netstat -nlp | grep 端口号</code></p></li></ul><h2 id="RPM查询命令"><a href="#RPM查询命令" class="headerlink" title="RPM查询命令"></a>RPM查询命令</h2><ul><li><p><em><strong>rpm -qa</strong></em> 查询所安装的所有rpm软件包</p></li><li><p><em><strong>rpm -e</strong></em> 卸载软件包</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-e</td><td>卸载软件包</td></tr><tr><td>–nodeps</td><td>卸载软件时，不检查依赖。这样的话，那些使用该软件包的软件在此之后可能就不能正常工作了。</td></tr></tbody></table></li><li><p><em><strong>rpm -ivh</strong></em> 安装软件包</p></li></ul><h2 id="YUM仓库类"><a href="#YUM仓库类" class="headerlink" title="YUM仓库类"></a>YUM仓库类</h2><ul><li><p><em><strong>yum</strong></em> 安装软件</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-y</td><td>对所有提问都回答“yes”</td></tr></tbody></table><table><thead><tr><th>参数</th><th>功能</th></tr></thead><tbody><tr><td>install</td><td>安装rpm软件包</td></tr><tr><td>update</td><td>更新rpm软件包</td></tr><tr><td>check-update</td><td>检查是否有可用的更新rpm软件包</td></tr><tr><td>remove</td><td>删除指定的rpm软件包</td></tr><tr><td>list</td><td>显示软件包信息</td></tr><tr><td>clean</td><td>清理yum过期的缓存</td></tr><tr><td>deplist</td><td>显示yum软件包的所有依赖关系</td></tr></tbody></table><p>采用yum方式安装firefox： <code>yum -y install firefox.x86_64</code></p></li></ul><h2 id="网络配置和系统管理操作"><a href="#网络配置和系统管理操作" class="headerlink" title="网络配置和系统管理操作"></a>网络配置和系统管理操作</h2><ul><li><p><em><strong>ifconfig</strong></em> 配置网络接口，显示当前网络ip</p></li><li><p><em><strong>ping</strong></em> 测试主机之间网络连通性</p></li><li><p><strong>修改IP地址</strong></p><ol><li>查看IP配置文件： <code>vim /etc/sysconfig/network-scripts/ifcfg-ens33</code></li><li>重启网络： <code>service network restart</code></li></ol></li><li><p><strong>配置主机名</strong></p><ol><li>查看当前服务器主机名称： <code>hostname</code></li><li>修改主机名： <code>vi /etc/hostname</code></li></ol></li><li><p><strong>修改hosts映射文件</strong></p><ol><li>打开/etc/hosts： <code>vim /etc/hosts</code></li></ol></li><li><p><strong>关闭防火墙</strong></p><ol><li><p><em><strong>service</strong></em> ： <code>service  服务名 start | stop | restart | status  </code> <strong>（CentOS 6）</strong></p><p>查看网络服务的状态： <code>service network status</code></p><p>停止网络服务： <code>service network stop</code></p><p>启动网络服务： <code>service network start</code></p><p>重启网络服务： <code>service network restart</code></p></li><li><p><em><strong>chkconfig</strong></em> 设置后台服务的自动启动<strong>（CentOS 6）</strong></p></li><li><p><em><strong>systemctl</strong></em> ： <code>systemctl  start | stop | restart | status  服务名</code></p><p>查看防火墙服务的状态： <code>systemctl status firewalld</code></p><p>查看服务开机启动状态： <code>systemctl list-unit-files</code></p><p>开启iptables(防火墙)服务的自动启动： <code>systemctl enable firewalld.service</code></p><p>关闭iptables(防火墙)服务的自动启动： <code>systemctl disable firewalld.service</code></p></li></ol></li></ul><h2 id="关机命令"><a href="#关机命令" class="headerlink" title="关机命令"></a>关机命令</h2><ul><li><p>立即关机</p><p><code>shutdown -h now</code></p></li><li><p>现在重新启动计算机</p><p><code>shutdown -r now</code></p><p><code>reboot</code></p></li></ul><h2 id="Linux查看内存、磁盘存储、io-读写、端口占用、进程等命令"><a href="#Linux查看内存、磁盘存储、io-读写、端口占用、进程等命令" class="headerlink" title="Linux查看内存、磁盘存储、io 读写、端口占用、进程等命令"></a>Linux查看内存、磁盘存储、io <strong>读写</strong>、端口占用、进程等命令</h2><ol><li><p>查看内存：top</p></li><li><p>查看磁盘存储情况：df -h</p></li><li><p>查 看磁盘IO读写情况：iotop（需要安装一下：yum install iotop）、iotop -o（直接查看输出比较高的磁盘读写程序）</p></li><li><p>查看端口占用情况：netstat -tunlp | grep 端口号</p></li><li><p>查看进程：ps -aux</p></li></ol>]]></content:encoded>
      
      
      <category domain="http://zyanprocess.github.io/categories/Linux/">Linux</category>
      
      
      <category domain="http://zyanprocess.github.io/tags/Linux/">Linux</category>
      
      
      <comments>http://zyanprocess.github.io/2023/04/04/%E5%AD%A6%E4%B9%A0Linux/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
