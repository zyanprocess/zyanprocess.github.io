<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>zaynの博客</title>
    <link>http://zyanprocess.github.io/</link>
    
    <atom:link href="http://zyanprocess.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>从前追寻答案，现在相信过程</description>
    <pubDate>Sun, 09 Jul 2023 16:47:44 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>自定义注解</title>
      <link>http://zyanprocess.github.io/2023/07/10/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/</link>
      <guid>http://zyanprocess.github.io/2023/07/10/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/</guid>
      <pubDate>Sun, 09 Jul 2023 16:00:14 GMT</pubDate>
      
      <description>&lt;p&gt;要深入学习注解，我们就必须能定义自己的注解，并使用注解，在定义自己的注解之前，我们就必须要了解Java&lt;/p&gt;
&lt;p&gt;为我们提供的元注解和相关定义注解的语法。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>要深入学习注解，我们就必须能定义自己的注解，并使用注解，在定义自己的注解之前，我们就必须要了解Java</p><p>为我们提供的元注解和相关定义注解的语法。</p><span id="more"></span><h1 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h1><p>元注解的作用就是负责注解其他注解，用来提供对其它annotation类型做说明。</p><ol><li>@Target</li><li>@Retention</li><li>@Documented</li><li>@Inherited</li></ol><h2 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h2><p>@Target说明了Annotation所修饰的对象范围：Annotation可被用于packages、type（类、接口、枚举、Annotation类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数）。在Annotation类型的声明中使用了Target可以更加清楚其修饰的目标。</p><p><strong>作用：</strong> 用于描述注解的适用范围</p><p><strong>取值：</strong>（ElementType）</p><ol><li>CONSTRUCTOR：用于描述构造器</li><li>FIELD： 用于描述域</li><li>LOCAL_VARIABLE： 用于描述局部变量</li><li>METHOD： 用于描述方法</li><li>PACKAGE： 用于描述包</li><li>PARAMETER： 用于描述参数</li><li>TYPE： 用于描述类、接口或enum声明</li></ol><h2 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h2><p>@Retention定义了该Annotation被保留的时间长短：某些Annotation仅出现在源代码中，而被编译器丢弃；而另一些却被编译在class文件中；编译在class文件中的Annotation可能会被虚拟机忽略，而另一些在class被装载时将被读取（请注意并不影响class的执行，因为Annotation与class在使用上是被分离的）。使用这个meta-Annotation可以对 Annotation的“生命周期”限制。</p><p><strong>作用：</strong> 表示需要在什么级别保存该注释信息，用于描述注解的生命周期（即：被描述的注解在什么范围内有效）</p><p><strong>取值：</strong>（RetentionPoicy）</p><ol><li>SOURCE： 在源文件中有效，即源文件保留</li><li>CLASS： 在class文件中有效，即class保留</li><li>RUNTIME： 在运行时有效，即运行时保留</li></ol><p>Retention meta-annotation类型有唯一的value作为成员，它的取值来自java.lang.annotation.RetentionPolicy的枚举类型值。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Column &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;fieldName&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">setFuncName</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;setField&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getFuncName</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;getField&quot;</span>; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">defaultDBValue</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Column注解的的RetentionPolicy的属性值是RUTIME,这样注解处理器可以通过反射，获取到该注解的属性值，从而去做一些运行时的逻辑处理。</p><h2 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h2><p>@Documented用于描述其它类型的annotation应该被作为被标注的程序成员的公共API，因此可以被例如javadoc此类的工具文档化。Documented是一个标记注解，没有成员。</p><h2 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h2><p>@Inherited 元注解是一个标记注解，@Inherited阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类。</p><p><strong>注意：</strong>@Inherited annotation类型是被标注过的class的子类所继承。类并不从它所实现的接口继承</p><p>annotation，方法并不从它所重载的方法继承annotation。</p><p>当@Inherited annotation类型标注的annotation的Retention是RetentionPolicy.RUNTIME，则反射API增强</p><p>了这种继承性。如果我们使用java.lang.reflect去查询一个@Inherited annotation类型的annotation时，反射代码</p><p>检查将展开工作：检查class和其父类，直到发现指定的annotation类型被发现，或者到达类继承结构的顶层。</p><h1 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h1><p>使用@interface自定义注解时，自动继承了java.lang.annotation.Annotation接口，由编译程序自动完成其他细节。在定义注解时，不能继承其他的注解或接口。@interface用来声明一个注解，其中的每一个方法实际上是声明了一个配置参数。方法的名称就是参数的名称，返回值类型就是参数的类型（返回值类型只能是基本类型、Class、String、enum）。可以通过default来声明参数的默认值。</p><p><strong>定义注解格式：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public @interface 注解名 &#123;定义体&#125;</span><br><span class="line"></span><br><span class="line">　　注解参数的可支持数据类型：</span><br><span class="line"></span><br><span class="line">　　　　1.所有基本数据类型（int,float,boolean,byte,double,char,long,short)</span><br><span class="line"></span><br><span class="line">　　　　2.String类型</span><br><span class="line"></span><br><span class="line">　　　　3.Class类型</span><br><span class="line"></span><br><span class="line">　　　　4.enum类型</span><br><span class="line"></span><br><span class="line">　　　　5.Annotation类型</span><br><span class="line"></span><br><span class="line">　　　　6.以上所有类型的数组</span><br></pre></td></tr></table></figure><p>Annotation类型里面的参数该怎么设定: </p><p>　　第一,只能用public或默认(default)这两个访问权修饰.例如,String value();这里把方法设为defaul默认类型；　</p><p>　　第二,参数成员只能用基本类型byte,short,char,int,long,float,double,boolean八种基本数据类型和</p><p> String,Enum,Class,annotations等数据类型,以及这一些类型的数组.例如,String value();这里的参数成员就为</p><p>String;　　</p><p>　　第三,如果只有一个参数成员,最好把参数名称设为”value”,后加小括号.例:下面的例子FruitName注解就只有一个参数成员。</p><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 水果名称注解</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> peida</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FruitName &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 水果颜色注解</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> peida</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FruitColor &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 颜色枚举</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> peida</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Color</span>&#123; BULE,RED,GREEN&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 颜色属性</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Color <span class="title function_">fruitColor</span><span class="params">()</span> <span class="keyword">default</span> Color.GREEN;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> annotation.FruitColor.Color;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Apple</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@FruitName(&quot;Apple&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String appleName;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@FruitColor(fruitColor=Color.RED)</span></span><br><span class="line">    <span class="keyword">private</span> String appleColor;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAppleColor</span><span class="params">(String appleColor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.appleColor = appleColor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAppleColor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> appleColor;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAppleName</span><span class="params">(String appleName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.appleName = appleName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAppleName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> appleName;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">displayName</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;水果的名字是：苹果&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注解元素的默认值：</strong></p><p>注解元素必须有确定的值，要么在定义注解的默认值中指定，要么在使用注解时指定，非基本类型的注解元素的值不可为null。因此, 使用空字符串或0作为默认值是一种常用的做法。这个约束使得处理器很难表现一个元素的存在或缺失的状态，因为每个注解的声明中，所有元素都存在，并且都具有相应的值，为了绕开这个约束，我们只能定义一些特殊的值，例如空字符串或者负数，一次表示某个元素不存在，在定义注解时，这已经成为一个习惯用法。</p>]]></content:encoded>
      
      
      <category domain="http://zyanprocess.github.io/categories/Java/">Java</category>
      
      
      <category domain="http://zyanprocess.github.io/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/">后端开发</category>
      
      
      <comments>http://zyanprocess.github.io/2023/07/10/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>代码随想录Day07哈希表</title>
      <link>http://zyanprocess.github.io/2023/07/09/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95Day07%E5%93%88%E5%B8%8C%E8%A1%A8/</link>
      <guid>http://zyanprocess.github.io/2023/07/09/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95Day07%E5%93%88%E5%B8%8C%E8%A1%A8/</guid>
      <pubDate>Sun, 09 Jul 2023 06:27:17 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;哈希表part02&quot;&gt;&lt;a href=&quot;#哈希表part02&quot; class=&quot;headerlink&quot; title=&quot;哈希表part02&quot;&gt;&lt;/a&gt;哈希表part02&lt;/h2&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="哈希表part02"><a href="#哈希表part02" class="headerlink" title="哈希表part02"></a>哈希表part02</h2><span id="more"></span><h1 id="454-四数相加II"><a href="#454-四数相加II" class="headerlink" title="454. 四数相加II"></a>454. 四数相加II</h1><p><strong>题意：</strong> 给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line"></span><br><span class="line">A = [ 1, 2]</span><br><span class="line">B = [-2,-1]</span><br><span class="line">C = [-1, 2]</span><br><span class="line">D = [ 0, 2]</span><br><span class="line">输出:</span><br><span class="line"></span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>解答：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fourSumCount</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[] nums3, <span class="type">int</span>[] nums4)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i : nums1) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> j : nums2) &#123;</span><br><span class="line">               map.put(i + j, map.getOrDefault(i + j, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i : nums3) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> j : nums4) &#123;</span><br><span class="line">               res += map.getOrDefault(<span class="number">0</span> - i - j, <span class="number">0</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>思路：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用map存储</span><br></pre></td></tr></table></figure><h1 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383. 赎金信"></a>383. 赎金信</h1><p><strong>题意：</strong> 给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">canConstruct(&quot;a&quot;, &quot;b&quot;) -&gt; false</span><br><span class="line">canConstruct(&quot;aa&quot;, &quot;ab&quot;) -&gt; false</span><br><span class="line">canConstruct(&quot;aa&quot;, &quot;aab&quot;) -&gt; true</span><br></pre></td></tr></table></figure><p><strong>解答：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> &#123;</span><br><span class="line">       HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">char</span> c : magazine.toCharArray()) &#123;</span><br><span class="line">           map.put(c, map.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">char</span> c : ransomNote.toCharArray()) &#123;</span><br><span class="line">           <span class="keyword">if</span> (!map.containsKey(c) || map.get(c) == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               map.put(c, map.get(c) - <span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>思路：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类似异位词</span><br></pre></td></tr></table></figure><h1 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15.  三数之和"></a>15.  三数之和</h1><p><strong>题意：</strong> 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p><p><strong>示例：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums = [-1, 0, 1, 2, -1, -4]，</span><br><span class="line"></span><br><span class="line">满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ]</span><br></pre></td></tr></table></figure><p><strong>解答：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">       List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">if</span> (nums.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> list;</span><br><span class="line">       &#125;</span><br><span class="line">       Arrays.sort(nums);</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> list;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">               <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[left] + nums[right];</span><br><span class="line">               <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                   left++;</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                   right--;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   list.add(Arrays.asList(nums[i], nums[left], nums[right]));</span><br><span class="line">                   <span class="keyword">while</span> (left&lt;right&amp;&amp;nums[left+<span class="number">1</span>]==nums[left]) left++;</span><br><span class="line">                   <span class="keyword">while</span> (left&lt;right&amp;&amp;nums[right-<span class="number">1</span>]==nums[right]) right--;</span><br><span class="line"></span><br><span class="line">                   left++;</span><br><span class="line">                   right--;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> list;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>思路：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">首先将数组重新排序，使用双指针从头尾相向逼近，遍历完整个数组，同时进行去重操作</span><br></pre></td></tr></table></figure><h1 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18.  四数之和"></a>18.  四数之和</h1><p><strong>题意：</strong> 给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。 满足要求的四元组集合为： [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ]</span><br></pre></td></tr></table></figure><p><strong>解答：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> j + <span class="number">1</span>, p = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (k &lt; p) &#123;</span><br><span class="line">                <span class="keyword">while</span> (k &gt; j + <span class="number">1</span> &amp;&amp; k &lt; n &amp;&amp; nums[k] == nums[k - <span class="number">1</span>]) k++;</span><br><span class="line">                <span class="keyword">if</span> (k &gt;= p) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[j] + nums[k] + nums[p];</span><br><span class="line">                <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                    ans.add(Arrays.asList(nums[i], nums[j], nums[k], nums[p]));</span><br><span class="line">                    k++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                    p--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                    k++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>思路：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类似三数之和，采用双指针</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://zyanprocess.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/">代码随想录</category>
      
      
      <category domain="http://zyanprocess.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/">哈希表</category>
      
      
      <comments>http://zyanprocess.github.io/2023/07/09/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95Day07%E5%93%88%E5%B8%8C%E8%A1%A8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>代码随想录Day06哈希表</title>
      <link>http://zyanprocess.github.io/2023/07/09/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95Day06%E5%93%88%E5%B8%8C%E8%A1%A8/</link>
      <guid>http://zyanprocess.github.io/2023/07/09/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95Day06%E5%93%88%E5%B8%8C%E8%A1%A8/</guid>
      <pubDate>Sun, 09 Jul 2023 05:57:31 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;哈希表part01&quot;&gt;&lt;a href=&quot;#哈希表part01&quot; class=&quot;headerlink&quot; title=&quot;哈希表part01&quot;&gt;&lt;/a&gt;哈希表part01&lt;/h2&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="哈希表part01"><a href="#哈希表part01" class="headerlink" title="哈希表part01"></a>哈希表part01</h2><span id="more"></span><h1 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242.有效的字母异位词"></a>242.有效的字母异位词</h1><p><strong>题意：</strong> 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot; 输出: true</span><br></pre></td></tr></table></figure><p><strong>解答：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (s.length() != t.length() ) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       HashMap&lt;Character,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">           map.put(c, map.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">char</span> c : t.toCharArray()) &#123;</span><br><span class="line">           <span class="keyword">if</span> (!map.containsKey(c) || map.get(c) == <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           map.put(c, map.get(c) - <span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a>349. 两个数组的交集</h1><p><strong>题意：</strong> 给定两个数组，编写一个函数来计算它们的交集。</p><p><strong>解答：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">       <span class="keyword">if</span> (nums1 == <span class="literal">null</span> || nums1.length == <span class="number">0</span> || nums2 == <span class="literal">null</span> || nums2.length == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i : nums1) &#123;</span><br><span class="line">           set.add(i);</span><br><span class="line">       &#125;</span><br><span class="line">       Set&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;() ;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i : nums2) &#123;</span><br><span class="line">           <span class="keyword">if</span> (set.contains(i)) &#123;</span><br><span class="line">               ans.add(i);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ans.stream().mapToInt(i -&gt; i).toArray();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>思路：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用HashSet的去重属性</span><br></pre></td></tr></table></figure><h1 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a>202. 快乐数</h1><p><strong>题意：</strong> 编写一个算法来判断一个数 n 是不是快乐数。</p><p>「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。</p><p>如果 n 是快乐数就返回 True ；不是，则返回 False 。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：19</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">1^2 + 9^2 = 82</span><br><span class="line">8^2 + 2^2 = 68</span><br><span class="line">6^2 + 8^2 = 100</span><br><span class="line">1^2 + 0^2 + 0^2 = 1</span><br></pre></td></tr></table></figure><p><strong>解答：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">       Set&lt;Integer&gt; record = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">while</span> (n != <span class="number">1</span> &amp;&amp; !record.contains(n)) &#123;</span><br><span class="line">           record.add(n);</span><br><span class="line">           n = getNextNumber(n);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getNextNumber</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> n % <span class="number">10</span>;</span><br><span class="line">           res += temp * temp;</span><br><span class="line">           n = n / <span class="number">10</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h1><p><strong>题意：</strong> 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [2, 7, 11, 15], target = 9</span><br><span class="line"></span><br><span class="line">因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class="line"></span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure><p><strong>解答：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">       HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (map.containsKey(target - nums[i])) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i, map.get(target - nums[i])&#125;;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               map.put(nums[i], i);</span><br><span class="line">           &#125; </span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>思路：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用map记录kv</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://zyanprocess.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/">代码随想录</category>
      
      
      <category domain="http://zyanprocess.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/">哈希表</category>
      
      
      <comments>http://zyanprocess.github.io/2023/07/09/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95Day06%E5%93%88%E5%B8%8C%E8%A1%A8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>代码随想录Day04链表</title>
      <link>http://zyanprocess.github.io/2023/07/09/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95Day04%E9%93%BE%E8%A1%A8/</link>
      <guid>http://zyanprocess.github.io/2023/07/09/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95Day04%E9%93%BE%E8%A1%A8/</guid>
      <pubDate>Sun, 09 Jul 2023 02:32:40 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;链表part02&quot;&gt;&lt;a href=&quot;#链表part02&quot; class=&quot;headerlink&quot; title=&quot;链表part02&quot;&gt;&lt;/a&gt;链表part02&lt;/h2&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="链表part02"><a href="#链表part02" class="headerlink" title="链表part02"></a>链表part02</h2><span id="more"></span><h1 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a>24. 两两交换链表中的节点</h1><p>题意： 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p>解答：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">       dummy.next = head;</span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy, tmp, first, sec;</span><br><span class="line">       <span class="keyword">while</span> (cur.next != <span class="literal">null</span> &amp;&amp; cur.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">           first = cur.next;</span><br><span class="line">           sec = cur.next.next;</span><br><span class="line">           tmp = cur.next.next.next;</span><br><span class="line">           cur.next = sec;</span><br><span class="line">           sec.next = first;</span><br><span class="line">           first.next = tmp;</span><br><span class="line">           cur = first;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dummy.next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>思路：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">引入头节点为当前节点，每隔两个节点使当前节点后的两个节点交换位置。</span><br></pre></td></tr></table></figure><h1 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19.删除链表的倒数第N个节点"></a>19.删除链表的倒数第N个节点</h1><p><strong>题意：</strong> 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p><p><strong>进阶：</strong>你能尝试使用一趟扫描实现吗？</p><p><strong>解答：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">dummyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">       dummyNode.next = head;</span><br><span class="line"></span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">fastIndex</span> <span class="operator">=</span> dummyNode;</span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">slowIndex</span> <span class="operator">=</span> dummyNode;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//只要快慢指针相差 n 个结点即可</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n  ; i++)&#123;</span><br><span class="line">           fastIndex = fastIndex.next;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> (fastIndex.next != <span class="literal">null</span>)&#123;</span><br><span class="line">           fastIndex = fastIndex.next;</span><br><span class="line">           slowIndex = slowIndex.next;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//此时 slowIndex 的位置就是待删除元素的前一个位置。</span></span><br><span class="line">   <span class="comment">//具体情况可自己画一个链表长度为 3 的图来模拟代码来理解</span></span><br><span class="line">       slowIndex.next = slowIndex.next.next;</span><br><span class="line">       <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>思路：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用快慢指针，快指针比慢指针多走n个节点，当慢指针走到链表结尾时，慢指针指向倒数N-1个节点</span><br></pre></td></tr></table></figure><h1 id="160-链表相交"><a href="#160-链表相交" class="headerlink" title="160.链表相交"></a>160.链表相交</h1><p><strong>题意：</strong> 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。</p><p><strong>解答：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">       HashSet&lt;ListNode&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">node1</span> <span class="operator">=</span> headA, node2 = headB;</span><br><span class="line">       <span class="keyword">while</span> (node1 != <span class="literal">null</span>) &#123;</span><br><span class="line">           set.add(node1);</span><br><span class="line">           node1 = node1.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span> (node2 != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (set.contains(node2)) &#123;</span><br><span class="line">               <span class="keyword">return</span> node2;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               node2 = node2.next;</span><br><span class="line">           &#125; </span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>思路：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用HashSet的去重特性，把链表A中的节点全部添加进HashSet中。然后遍历链表B，当HashSet中存在相同节点，说明当前节点为相交节点。</span><br></pre></td></tr></table></figure><h1 id="142-环形链表II"><a href="#142-环形链表II" class="headerlink" title="142.环形链表II"></a>142.环形链表II</h1><p><strong>题意：</strong>  给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>为了表示给定链表中的环，使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p><p><strong>解答：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">       dummy.next = head;</span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> dummy, slow = dummy;</span><br><span class="line">       <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">           fast = fast.next.next;</span><br><span class="line">           slow = slow.next;</span><br><span class="line">           <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">               <span class="type">ListNode</span> <span class="variable">index</span> <span class="operator">=</span> dummy;</span><br><span class="line">               <span class="keyword">while</span> (fast != index) &#123;</span><br><span class="line">                   fast = fast.next;</span><br><span class="line">                   index = index.next;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span> index;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>思路：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">使用快慢指针，如果fastNode.next始终不为null，说明当前链表存在环。此时让快指针每步都比慢指针多走一步，这样快指针肯定会和慢指针相遇。</span><br><span class="line">慢指针走了x+y个节点，快指针走了x+y+n(z+y)个节点，同时快指针走的节点数是慢指针的两倍，所以得出方程式：</span><br><span class="line">2(x + y)  = x + y + n(z + y) 通过转换得到</span><br><span class="line">x = (n - 1) (y + z) + z</span><br><span class="line">当n = 1时， x = z，</span><br><span class="line">当n ≥ 2时，快指针在环内经过n圈才和慢指针相遇，和n = 1时是一样的。</span><br></pre></td></tr></table></figure><p><img src="/2023/07/09/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95Day04%E9%93%BE%E8%A1%A8/workSpace\Blog\source_posts\代码随想录Day04链表\01.png"></p>]]></content:encoded>
      
      
      <category domain="http://zyanprocess.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/">代码随想录</category>
      
      
      <category domain="http://zyanprocess.github.io/tags/%E9%93%BE%E8%A1%A8/">链表</category>
      
      
      <comments>http://zyanprocess.github.io/2023/07/09/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95Day04%E9%93%BE%E8%A1%A8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>代码随想录Day03链表</title>
      <link>http://zyanprocess.github.io/2023/07/09/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95Day03%E9%93%BE%E8%A1%A8/</link>
      <guid>http://zyanprocess.github.io/2023/07/09/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95Day03%E9%93%BE%E8%A1%A8/</guid>
      <pubDate>Sun, 09 Jul 2023 01:53:01 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;链表part01&quot;&gt;&lt;a href=&quot;#链表part01&quot; class=&quot;headerlink&quot; title=&quot;链表part01&quot;&gt;&lt;/a&gt;链表part01&lt;/h2&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="链表part01"><a href="#链表part01" class="headerlink" title="链表part01"></a>链表part01</h2><span id="more"></span><h1 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203.移除链表元素"></a>203.移除链表元素</h1><p>题意：删除链表中等于给定值 val 的所有节点。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,6,3,4,5,6], val = 6 输出：[1,2,3,4,5]</span><br></pre></td></tr></table></figure><p>解答：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>, head);</span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummy;</span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">       <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (cur.val == val) &#123;</span><br><span class="line">               pre.next = cur.next;</span><br><span class="line">               cur = cur.next;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               cur = cur.next;</span><br><span class="line">               pre = pre.next;</span><br><span class="line">           &#125; </span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dummy.next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707.设计链表"></a>707.设计链表</h1><p>题意：</p><p>在链表类中实现这些功能：</p><ul><li>get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。</li><li>addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。</li><li>addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。</li><li>addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。</li><li>deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。</li></ul><p>解答：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    ListNode head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= index; i++) &#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        addAtIndex(<span class="number">0</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        addAtIndex(size, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; size) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        node.next = pre.next;</span><br><span class="line">        pre.next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pred</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index ; i++) &#123;</span><br><span class="line">            pred = pred.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pred.next = pred.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h1><p>题意： 反转一个单链表。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure><p>解答：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line">       <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> node.next;</span><br><span class="line">           node.next = cur;</span><br><span class="line">           cur = node;</span><br><span class="line">           node = next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> cur;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://zyanprocess.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/">代码随想录</category>
      
      
      <category domain="http://zyanprocess.github.io/tags/%E9%93%BE%E8%A1%A8/">链表</category>
      
      
      <comments>http://zyanprocess.github.io/2023/07/09/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95Day03%E9%93%BE%E8%A1%A8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>代码随想录Day02数组</title>
      <link>http://zyanprocess.github.io/2023/06/29/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95Day02%E6%95%B0%E7%BB%84/</link>
      <guid>http://zyanprocess.github.io/2023/06/29/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95Day02%E6%95%B0%E7%BB%84/</guid>
      <pubDate>Thu, 29 Jun 2023 13:26:05 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;数组part02&quot;&gt;&lt;a href=&quot;#数组part02&quot; class=&quot;headerlink&quot; title=&quot;数组part02&quot;&gt;&lt;/a&gt;数组part02&lt;/h2&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="数组part02"><a href="#数组part02" class="headerlink" title="数组part02"></a>数组part02</h2><span id="more"></span><h1 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209.长度最小的子数组"></a>209.长度最小的子数组</h1><p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入：s = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span><br></pre></td></tr></table></figure><p>解答：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>, len = Integer.MAX_VALUE;</span><br><span class="line">       <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">           sum += nums[i];</span><br><span class="line">           <span class="keyword">while</span> (sum &gt;= target) &#123;</span><br><span class="line">               len = Math.min(len, i - j + <span class="number">1</span>);</span><br><span class="line">               sum -= nums[j++];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> len == Integer.MAX_VALUE ? <span class="number">0</span> : len;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977.有序数组的平方"></a>977.有序数组的平方</h1><p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]</span><br></pre></td></tr></table></figure><p>解答：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">       <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">       <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> res.length - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">           <span class="keyword">if</span> (nums[left] * nums[left] &lt; nums[right] * nums[right]) &#123;</span><br><span class="line">               res[index--] = nums[right] * nums[right];</span><br><span class="line">               right--;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               res[index--] = nums[left] * nums[left];</span><br><span class="line">               left++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>思路：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">数组其实是有序的， 只不过负数平方之后可能成为最大数了。</span><br><span class="line"></span><br><span class="line">那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。</span><br><span class="line"></span><br><span class="line">此时可以考虑双指针法了，i指向起始位置，j指向终止位置。</span><br><span class="line"></span><br><span class="line">定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。</span><br><span class="line"></span><br><span class="line">如果A[i] * A[i] &lt; A[j] * A[j] 那么result[k--] = A[j] * A[j]; 。</span><br><span class="line"></span><br><span class="line">如果A[i] * A[i] &gt;= A[j] * A[j] 那么result[k--] = A[i] * A[i]; 。</span><br></pre></td></tr></table></figure><h1 id="59-螺旋矩阵II"><a href="#59-螺旋矩阵II" class="headerlink" title="59.螺旋矩阵II"></a>59.螺旋矩阵II</h1><p>给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]</span><br></pre></td></tr></table></figure><p>解答：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">       <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">       <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">       <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;  </span><br><span class="line">       <span class="type">int</span> i, j;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> (loop++ &lt; n / <span class="number">2</span>) &#123; </span><br><span class="line">           <span class="keyword">for</span> (j = start; j &lt; n - loop; j++) &#123;</span><br><span class="line">               res[start][j] = count++;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">for</span> (i = start; i &lt; n - loop; i++) &#123;</span><br><span class="line">               res[i][j] = count++;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">for</span> (; j &gt;= loop; j--) &#123;</span><br><span class="line">               res[i][j] = count++;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">for</span> (; i &gt;= loop; i--) &#123;</span><br><span class="line">               res[i][j] = count++;</span><br><span class="line">           &#125;</span><br><span class="line">           start++;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">           res[start][start] = count;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>思路：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">注意边界值</span><br><span class="line">模拟顺时针画矩阵的过程:</span><br><span class="line">填充上行从左到右</span><br><span class="line">填充右列从上到下</span><br><span class="line">填充下行从右到左</span><br><span class="line">填充左列从下到上</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://zyanprocess.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/">代码随想录</category>
      
      
      <category domain="http://zyanprocess.github.io/tags/%E6%95%B0%E7%BB%84/">数组</category>
      
      
      <comments>http://zyanprocess.github.io/2023/06/29/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95Day02%E6%95%B0%E7%BB%84/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>代码随想录Day01数组</title>
      <link>http://zyanprocess.github.io/2023/06/28/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95Day01/</link>
      <guid>http://zyanprocess.github.io/2023/06/28/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95Day01/</guid>
      <pubDate>Wed, 28 Jun 2023 15:47:57 GMT</pubDate>
      
      <description>&lt;p&gt;开始正式刷代码随想录的算法题，希望自己的算法能力迅速提高！！！&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>开始正式刷代码随想录的算法题，希望自己的算法能力迅速提高！！！</p><span id="more"></span><h1 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a>704. 二分查找</h1><p><em><strong>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</strong></em></p><p>示例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 9     </span><br><span class="line">输出: 4       </span><br><span class="line">解释: 9 出现在 nums 中并且下标为 4  </span><br></pre></td></tr></table></figure><p>解答：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (target &lt; nums[<span class="number">0</span>] || target &gt; nums[nums.length - <span class="number">1</span>]) &#123;</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>, end = nums.length - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> start + ((end - start) / <span class="number">2</span>);</span><br><span class="line">           <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">               end = mid - <span class="number">1</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">               start = mid + <span class="number">1</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> mid;</span><br><span class="line">           &#125; </span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35.搜索插入位置"></a>35.搜索插入位置</h1><p><em><strong>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</strong></em></p><p>示例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 5</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p>解答：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>, end = nums.length - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> start + ((end - start) / <span class="number">2</span>);</span><br><span class="line">           <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">               end = mid - <span class="number">1</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">               start = mid + <span class="number">1</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> mid;</span><br><span class="line">           &#125; </span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> start;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a>34. 在排序数组中查找元素的第一个和最后一个位置</h1><p><em><strong>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</strong></em></p><p><em><strong>如果数组中不存在目标值 target，返回 [-1, -1]。</strong></em></p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">输出：[3,4]</span><br></pre></td></tr></table></figure><p>解答：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> search(nums, target);</span><br><span class="line">       <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span> (index == -<span class="number">1</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = index;</span><br><span class="line">            right = index;</span><br><span class="line">           <span class="keyword">while</span> (right + <span class="number">1</span> &lt;= nums.length - <span class="number">1</span> &amp;&amp; nums[right + <span class="number">1</span>] == target) &#123;</span><br><span class="line">               right++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">while</span> (left - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; nums[left - <span class="number">1</span>] == target) &#123;</span><br><span class="line">               left--;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;left, right&#125;;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>, end = nums.length - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> start + ((end - start) / <span class="number">2</span>);</span><br><span class="line">           <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">               end = mid - <span class="number">1</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">               start = mid + <span class="number">1</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> mid;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>先通过二分查找判断数组中是否存在目标值，如果不存在返回[-1,-1]，如果存在的话依次寻找左右边界值。</p><h1 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a>27. 移除元素</h1><p><em><strong>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</strong></em></p><p><em><strong>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。</strong></em></p><p><em><strong>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</strong></em></p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p>解答：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">       <span class="comment">// 快慢指针</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">slowIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">fastIndex</span> <span class="operator">=</span> <span class="number">0</span>; fastIndex &lt; nums.length; fastIndex++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (nums[fastIndex] != val) &#123;</span><br><span class="line">               nums[slowIndex] = nums[fastIndex];</span><br><span class="line">               slowIndex++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> slowIndex;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相向双指针法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(right &gt;= <span class="number">0</span> &amp;&amp; nums[right] == val) right--; <span class="comment">//将right移到从右数第一个值不为val的位置</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[left] == val) &#123; <span class="comment">//left位置的元素需要移除</span></span><br><span class="line">                <span class="comment">//将right位置的元素移到left（覆盖），right位置移除</span></span><br><span class="line">                nums[left] = nums[right];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">while</span>(right &gt;= <span class="number">0</span> &amp;&amp; nums[right] == val) right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://zyanprocess.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/">代码随想录</category>
      
      
      <category domain="http://zyanprocess.github.io/tags/%E6%95%B0%E7%BB%84/">数组</category>
      
      
      <comments>http://zyanprocess.github.io/2023/06/28/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95Day01/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>线程池复用</title>
      <link>http://zyanprocess.github.io/2023/04/12/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%8D%E7%94%A8/</link>
      <guid>http://zyanprocess.github.io/2023/04/12/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%8D%E7%94%A8/</guid>
      <pubDate>Wed, 12 Apr 2023 07:51:46 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;Worker执行任务模型&quot;&gt;&lt;a href=&quot;#Worker执行任务模型&quot; class=&quot;headerlink&quot; title=&quot;Worker执行任务模型&quot;&gt;&lt;/a&gt;Worker执行任务模型&lt;/h1&gt;&lt;p&gt;主要执行任务的三个角色&lt;/p&gt;
&lt;p&gt;Worker –&amp;gt; WorkQueue –&amp;gt; Thread&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="Worker执行任务模型"><a href="#Worker执行任务模型" class="headerlink" title="Worker执行任务模型"></a>Worker执行任务模型</h1><p>主要执行任务的三个角色</p><p>Worker –&gt; WorkQueue –&gt; Thread</p><span id="more"></span><p><img src="/2023/04/12/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%8D%E7%94%A8/1.png"></p><h1 id="Worker线程如何增加"><a href="#Worker线程如何增加" class="headerlink" title="Worker线程如何增加"></a>Worker线程如何增加</h1><p>涉及参数：</p><table><thead><tr><th>名称</th><th>含义</th></tr></thead><tbody><tr><td>core</td><td>如果为true，则与 corePoolSize 绑定。为false，则与 maximumPoolSize 绑定</td></tr><tr><td>firstTask</td><td>新线程首先要执行的任务，若没有则传null</td></tr></tbody></table><p>addWorker源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">addWorker</span><span class="params">(Runnable firstTask, <span class="type">boolean</span> core)</span> &#123;</span><br><span class="line">    retry:</span><br><span class="line">        <span class="comment">//检测当前线程池状态</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//包含线程池状态和线程中有效线程数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="comment">//通过高三位获取线程池状态</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程池不处于RUNNABLE状态且现在状态为关闭状态，未传入新任务，阻塞队列不为空 返回false</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//通过低29位计算线程池内有效线程的数量</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);</span><br><span class="line">            <span class="comment">//超过size，则返回false</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//增加工作线程数    </span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            <span class="comment">//再次获取线程池状态和线程中有效线程数量</span></span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerStarted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerAdded</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">Worker</span> <span class="variable">w</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个Worker对象，将新任务放入Worker</span></span><br><span class="line">        w = <span class="keyword">new</span> <span class="title class_">Worker</span>(firstTask);</span><br><span class="line">        <span class="comment">//实例化一个线程</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//加锁</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="comment">//再次检查线程池运行状态</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(ctl.get());</span><br><span class="line">                <span class="comment">//线程池运行状态为RUNNABLE 或者 为已关闭且无新任务</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="literal">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">//检测是否处于活动</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line">                    <span class="comment">//将新任务放入set数组中    </span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    <span class="comment">//添加任务工程    </span></span><br><span class="line">                    workerAdded = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//释放锁</span></span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//启动任务</span></span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//添加失败则加入失败队列</span></span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>addWorker总结：</strong></li></ul><ol><li>检查线程池状态</li><li>新建线程，使用Worker进行包装，放入HashSet数组中，最终真正执行任务的线程就放在Worker，所以新增一个addWorker就是新增一个线程。主要实现复用就是Worker类中的runWorker(this)</li><li>启动线程Start()</li><li>添加失败操作，移除Worker,减少WorkerCount</li></ol><ul><li><strong>worker源码</strong></li></ul><p>worker实际的实现也是Runnbale，通过继承AbstractQueuedSynchronizer,来获取独占锁，所以上面调用start(),实际上也是执行Worker中的run方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Worker</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">        <span class="built_in">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="built_in">this</span>.thread = getThreadFactory().newThread(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Delegates main run loop to outer runWorker  */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        runWorker(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><h1 id="Worker线程执行任务"><a href="#Worker线程执行任务" class="headerlink" title="Worker线程执行任务"></a>Worker线程执行任务</h1><p><img src="/2023/04/12/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%8D%E7%94%A8/2.png"></p><ol><li><strong>runWorker</strong>源码</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">runWorker</span><span class="params">(Worker w)</span> &#123;</span><br><span class="line">    <span class="comment">//获取当前的线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">wt</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">//从Worker中取出新任务</span></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> w.firstTask;</span><br><span class="line">    <span class="comment">//释放Worker</span></span><br><span class="line">    w.firstTask = <span class="literal">null</span>;</span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">completedAbruptly</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//任务不为空</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//上锁，避免被其他线程中断</span></span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="comment">//检查状态如果线程池状态处于中断，则中断线程</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                <span class="comment">//中断当前线程</span></span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//执行beforeExecute</span></span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                <span class="type">Throwable</span> <span class="variable">thrown</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//执行任务</span></span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="literal">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//worker回收</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使线程池复用的核心方法，getTask() 只要不返回null，就会一直执行</p><ol start="2"><li><strong>getTask</strong>源码</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Runnable <span class="title function_">getTask</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">timedOut</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//获取线程池运行状态和线程池内中有效线程池</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="comment">//获取运行状态</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="comment">// 线程不处于RUNNABLE 且（已关闭 或 worker队列为空）</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="comment">//减少工作线程数</span></span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取线程池内有效线程池数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="comment">// 1.allowCoreThreadTimeOut变量默认是false,核心线程即使空闲也不会被销毁</span></span><br><span class="line">        <span class="comment">// 如果为true,核心线程在keepAliveTime内仍空闲则会被销毁。</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">timed</span> <span class="operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">        <span class="comment">//如果运行线程数超过了最大线程数，但是缓存队列已经空了，这时递减worker数量。 </span></span><br><span class="line">　　　　 <span class="comment">// 如果有设置允许线程超时或者线程数量超过了核心线程数量，</span></span><br><span class="line">        <span class="comment">// 并且线程在规定时间内均未poll到任务且队列为空则递减worker数量</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//如果为true，则调用poll方法获取任务，超过keepAliveTime，则会返回null</span></span><br><span class="line">            <span class="comment">//如果为false，则直接调用take方法获取任务，workQueue.offer(command) ,当任务加入时，再被唤醒，返回任务</span></span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>addWorkerFailed源码</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//回滚创建</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addWorkerFailed</span><span class="params">(Worker w)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//新任务不为空</span></span><br><span class="line">        <span class="keyword">if</span> (w != <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">//移除新任务</span></span><br><span class="line">            workers.remove(w);</span><br><span class="line">       <span class="comment">//减少WorkerCount     </span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">        <span class="comment">//其他状态为Terminate</span></span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>tryTerminate源码</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">tryTerminate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//获取线程池状态和线程池中有效线程数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="comment">// 正在运行 或 任务都已经终止 或 处于关闭状态且池和队列不为空 提前退出</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) ||</span><br><span class="line">            runStateAtLeast(c, TIDYING) ||</span><br><span class="line">            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">//工作线程数不为0，则中断空闲的worker</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123; <span class="comment">// Eligible to terminate</span></span><br><span class="line">            interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//获取对象锁</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    terminated();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));</span><br><span class="line">                    termination.signalAll();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else retry on failed CAS</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="原理总结"><a href="#原理总结" class="headerlink" title="原理总结"></a>原理总结</h1><ol><li><p>线程池的优点就是提高对线程的管理，提高资源的利用率，控制线程的数量。</p></li><li><p>在线程池中，线程可以从阻塞队列 中不断 getTask() 新任务来执行，其核心原理在于线程池用Worker对Thread进行了封装，每调用一个 addWorker 就是等于新开一个线程，并不是每次执行任务都会调用 Thread.start() 来创建新线程，而是让每个线程去轮询，在这个轮询中，不停地检查是否还有任务等待被执行，如果有则直接去执行这个任务，也就是调用任务的 run() 方法，把 run() 方法当作和普通方法一样的地位去调用，相当于把每个任务的 run() 方法串联了起来，所以线程数量并不增加。</p></li></ol><ul><li>线程如何复用</li></ul><p>ThreadPoolExecutor 在创建线程时，会将线程封装成工作线程 Worker ,并放入工作线程组中，然后这个 Worker 反复从阻塞队列中拿任务去执行。</p><p>通过取 Worker 的 firstTask 或者通过 getTask 方法从 workQueue 中获取待执行的任务。<br>直接调用 task 的 run 方法来执行具体的任务（而不是新建线程）</p><ul><li>线程如何回收</li></ul><ol><li>获取不到任务时，回收自己</li><li>将worker移出线程池</li><li>线程池状态置为TERMINATED</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  processWorkerExit(w, completedAbruptly);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processWorkerExit</span><span class="params">(Worker w, <span class="type">boolean</span> completedAbruptly)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn&#x27;t adjusted</span></span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">...</span><br><span class="line">        <span class="comment">//将worker移出线程池</span></span><br><span class="line">            completedTaskCount += w.completedTasks;</span><br><span class="line">            workers.remove(w);</span><br><span class="line"><span class="comment">//修改线程池状态</span></span><br><span class="line">        tryTerminate();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">                <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                    min = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                    <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">            &#125;</span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://zyanprocess.github.io/categories/Java/">Java</category>
      
      
      <category domain="http://zyanprocess.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/">线程池</category>
      
      
      <comments>http://zyanprocess.github.io/2023/04/12/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%8D%E7%94%A8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>常用限流算法及其实现</title>
      <link>http://zyanprocess.github.io/2023/04/12/%E5%B8%B8%E7%94%A8%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/</link>
      <guid>http://zyanprocess.github.io/2023/04/12/%E5%B8%B8%E7%94%A8%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/</guid>
      <pubDate>Wed, 12 Apr 2023 06:08:28 GMT</pubDate>
      
      <description>&lt;p&gt;在分布式系统中，应对高并发访问时，缓存、限流、降级是保护系统正常运行的常用方法。当请求量突发暴涨时，如果不加以限制访问，则可能导致整个系统崩溃，服务不可用。同时有一些业务场景，比如短信验证码，或者其它第三方API调用，也需要提供必要的访问限制支持。&lt;/p&gt;
&lt;p&gt;常见的限流算法有令牌桶算法，漏桶算法，与计数器算法。本文主要对三个算法的基本原理及Google Guava包中令牌桶算法的实现&lt;code&gt;RateLimiter&lt;/code&gt;进行介绍，并实现以&lt;code&gt;RateLimiter&lt;/code&gt;为参考的分布式限流实现及计数器限流实现。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>在分布式系统中，应对高并发访问时，缓存、限流、降级是保护系统正常运行的常用方法。当请求量突发暴涨时，如果不加以限制访问，则可能导致整个系统崩溃，服务不可用。同时有一些业务场景，比如短信验证码，或者其它第三方API调用，也需要提供必要的访问限制支持。</p><p>常见的限流算法有令牌桶算法，漏桶算法，与计数器算法。本文主要对三个算法的基本原理及Google Guava包中令牌桶算法的实现<code>RateLimiter</code>进行介绍，并实现以<code>RateLimiter</code>为参考的分布式限流实现及计数器限流实现。</p><span id="more"></span><h1 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h1><p>令牌桶算法的原理就是以一个恒定的速度往桶里放入令牌，每一个请求的处理都需要从桶里先获取一个令牌，当桶里没有令牌时，则请求不会被处理，要么排队等待，要么降级处理，要么直接拒绝服务。当桶里令牌满时，新添加的令牌会被丢弃或拒绝。</p><p>令牌桶算法的处理示意图如下</p><p><img src="/2023/04/12/%E5%B8%B8%E7%94%A8%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/%E5%B8%B8%E7%94%A8%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%5Cv2-1118c1c9455d923d4b3c70291b689f7b_720w.png"></p><p>令牌桶算法主要是可以控制请求的平均处理速率，它允许预消费，即可以提前消费令牌，以应对突发请求，但是后面的请求需要为预消费买单（等待更长的时间），以满足请求处理的平均速率是一定的。</p><h1 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h1><p>漏桶算法的原理是水（请求）先进入漏桶中，漏桶以一定的速度出水（处理请求），当水流入速度大于流出速度导致水在桶内逐渐堆积直到桶满时，水会溢出（请求被拒绝）。</p><p>漏桶算法的处理示意图如下</p><p><img src="/2023/04/12/%E5%B8%B8%E7%94%A8%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/%E5%B8%B8%E7%94%A8%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%5Cv2-0736dde059726d7fb463c72afdc350e1_720w.png"></p><p>漏桶算法主要是控制请求的处理速率，平滑网络上的突发流量，请求可以以任意速度进入漏桶中，但请求的处理则以恒定的速度进行。</p><h1 id="计数器算法"><a href="#计数器算法" class="headerlink" title="计数器算法"></a>计数器算法</h1><p>计数器算法是限流算法中最简单的一种算法，限制在一个时间窗口内，至多处理多少个请求。比如每分钟最多处理10个请求，则从第一个请求进来的时间为起点，60s的时间窗口内只允许最多处理10个请求。下一个时间窗口又以前一时间窗口过后第一个请求进来的时间为起点。常见的比如一分钟内只能获取一次短信验证码的功能可以通过计数器算法来实现。</p><h1 id="Guava-RateLimiter解析"><a href="#Guava-RateLimiter解析" class="headerlink" title="Guava RateLimiter解析"></a>Guava RateLimiter解析</h1><p>Guava是Google开源的一个工具包，其中的<code>RateLimiter</code>是实现了令牌桶算法的一个限流工具类。在<code>pom.xml</code>中添加guava依赖，即可使用<code>RateLimiter</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>29.0-jre<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如下测试代码示例了<code>RateLimiter</code>的用法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">RateLimiter</span> <span class="variable">rateLimiter</span> <span class="operator">=</span> RateLimiter.create(<span class="number">1</span>); <span class="comment">//创建一个每秒产生一个令牌的令牌桶</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++) &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">waitTime</span> <span class="operator">=</span> rateLimiter.acquire(i); <span class="comment">//一次获取i个令牌</span></span><br><span class="line">        System.out.println(<span class="string">&quot;acquire:&quot;</span> + i + <span class="string">&quot; waitTime:&quot;</span> + waitTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后，输出如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">acquire:1 waitTime:0.0</span><br><span class="line">acquire:2 waitTime:0.997729</span><br><span class="line">acquire:3 waitTime:1.998076</span><br><span class="line">acquire:4 waitTime:3.000303</span><br><span class="line">acquire:5 waitTime:4.000223</span><br></pre></td></tr></table></figure><p>第一次获取一个令牌时，等待0s立即可获取到（这里之所以不需要等待是因为令牌桶的预消费特性），第二次获取两个令牌，等待时间1s，这个1s就是前面获取一个令牌时因为预消费没有等待延到这次来等待的时间，这次获取两个又是预消费，所以下一次获取（取3个时）就要等待这次预消费需要的2s了，依此类推。可见预消费不需要等待的时间都由下一次来买单，以保障一定的平均处理速率（上例为1s一次）。</p><p><code>RateLimiter</code>有两种实现：</p><ol><li>SmoothBursty： 令牌的生成速度恒定。使用 <code>RateLimiter.create(double permitsPerSecond)</code> 创建的是 SmoothBursty 实例。</li><li>SmoothWarmingUp：令牌的生成速度持续提升，直到达到一个稳定的值。WarmingUp，顾名思义就是有一个热身的过程。使用 <code>RateLimiter.create(double permitsPerSecond, long warmupPeriod, TimeUnit unit)</code> 时创建就是 SmoothWarmingUp 实例，其中 warmupPeriod 就是热身达到稳定速度的时间。</li></ol><p>关键属性及方法解析（以 SmoothBursty 为例）</p><ol><li>关键属性</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 桶中当前拥有的令牌数. */</span></span><br><span class="line"><span class="type">double</span> storedPermits;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 桶中最多可以保存多少秒存入的令牌数 */</span></span><br><span class="line"><span class="type">double</span> maxBurstSeconds;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 桶中能存储的最大令牌数，等于storedPermits*maxBurstSeconds. */</span></span><br><span class="line"><span class="type">double</span> maxPermits;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 放入令牌的时间间隔*/</span></span><br><span class="line"><span class="type">double</span> stableIntervalMicros;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 下次可获取令牌的时间点，可以是过去也可以是将来的时间点*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="variable">nextFreeTicketMicros</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br></pre></td></tr></table></figure><ol start="2"><li>关键方法</li></ol><p>调用 <code>RateLimiter.create(double permitsPerSecond)</code> 方法时，创建的是 SmoothBursty 实例，默认设置 maxBurstSeconds 为1s。SleepingStopwatch 是guava中的一个时钟类实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line"><span class="keyword">static</span> RateLimiter <span class="title function_">create</span><span class="params">(<span class="type">double</span> permitsPerSecond, SleepingStopwatch stopwatch)</span> &#123;</span><br><span class="line">        <span class="type">RateLimiter</span> <span class="variable">rateLimiter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmoothBursty</span>(stopwatch, <span class="number">1.0</span> <span class="comment">/* maxBurstSeconds */</span>);</span><br><span class="line">        rateLimiter.setRate(permitsPerSecond);</span><br><span class="line">        <span class="keyword">return</span> rateLimiter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SmoothBursty(SleepingStopwatch stopwatch, <span class="type">double</span> maxBurstSeconds) &#123;</span><br><span class="line">    <span class="built_in">super</span>(stopwatch);</span><br><span class="line">    <span class="built_in">this</span>.maxBurstSeconds = maxBurstSeconds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并通过调用 <code>SmoothBursty.doSetRate(double, long)</code> 方法进行初始化，该方法中:</p><ol><li>调用 <code>resync(nowMicros)</code> 对 storedPermits 与 nextFreeTicketMicros 进行了调整——如果当前时间晚于 nextFreeTicketMicros，则计算这段时间内产生的令牌数，累加到 storedPermits 上，并更新下次可获取令牌时间 nextFreeTicketMicros 为当前时间。</li><li>计算 stableIntervalMicros 的值，1/permitsPerSecond。</li><li>调用 <code>doSetRate(double, double)</code> 方法计算 maxPermits 值（maxBurstSeconds*permitsPerSecond），并根据旧的 maxPermits 值对 storedPermits 进行调整。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">doSetRate</span><span class="params">(<span class="type">double</span> permitsPerSecond, <span class="type">long</span> nowMicros)</span> &#123;</span><br><span class="line">        resync(nowMicros);</span><br><span class="line">        <span class="type">double</span> <span class="variable">stableIntervalMicros</span> <span class="operator">=</span> SECONDS.toMicros(<span class="number">1L</span>) / permitsPerSecond;</span><br><span class="line">        <span class="built_in">this</span>.stableIntervalMicros = stableIntervalMicros;</span><br><span class="line">        doSetRate(permitsPerSecond, stableIntervalMicros);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Updates &#123;<span class="doctag">@code</span> storedPermits&#125; and &#123;<span class="doctag">@code</span> nextFreeTicketMicros&#125; based on the current time. */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">resync</span><span class="params">(<span class="type">long</span> nowMicros)</span> &#123;</span><br><span class="line">        <span class="comment">// if nextFreeTicket is in the past, resync to now</span></span><br><span class="line">        <span class="keyword">if</span> (nowMicros &gt; nextFreeTicketMicros) &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">newPermits</span> <span class="operator">=</span> (nowMicros - nextFreeTicketMicros) / coolDownIntervalMicros();</span><br><span class="line">        storedPermits = min(maxPermits, storedPermits + newPermits);</span><br><span class="line">        nextFreeTicketMicros = nowMicros;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">doSetRate</span><span class="params">(<span class="type">double</span> permitsPerSecond, <span class="type">double</span> stableIntervalMicros)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">oldMaxPermits</span> <span class="operator">=</span> <span class="built_in">this</span>.maxPermits;</span><br><span class="line">        maxPermits = maxBurstSeconds * permitsPerSecond;</span><br><span class="line">        <span class="keyword">if</span> (oldMaxPermits == Double.POSITIVE_INFINITY) &#123;</span><br><span class="line">                <span class="comment">// if we don&#x27;t special-case this, we would get storedPermits == NaN, below</span></span><br><span class="line">                storedPermits = maxPermits;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                storedPermits =</span><br><span class="line">                        (oldMaxPermits == <span class="number">0.0</span>)</span><br><span class="line">                                ? <span class="number">0.0</span> <span class="comment">// initial state</span></span><br><span class="line">                                : storedPermits * maxPermits / oldMaxPermits;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 <code>acquire(int)</code> 方法获取指定数量的令牌时，</p><ol><li>调用 <code>reserve(int)</code> 方法，该方法最终调用 <code>reserveEarliestAvailable(int, long)</code> 来更新下次可取令牌时间点与当前存储的令牌数，并返回本次可取令牌的时间点，根据该时间点计算需要等待的时间</li><li>阻塞等待1中返回的等待时间</li><li>返回等待的时间（秒）</li></ol><p>源码如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 获取指定数量（permits）的令牌，阻塞直到获取到令牌，返回等待的时间*/</span></span><br><span class="line"><span class="meta">@CanIgnoreReturnValue</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">microsToWait</span> <span class="operator">=</span> reserve(<span class="keyword">permits</span>);</span><br><span class="line">        stopwatch.sleepMicrosUninterruptibly(microsToWait);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span> * microsToWait / SECONDS.toMicros(<span class="number">1L</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="title function_">reserve</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>)</span> &#123;</span><br><span class="line">        checkPermits(<span class="keyword">permits</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (mutex()) &#123;</span><br><span class="line">                <span class="keyword">return</span> reserveAndGetWaitLength(<span class="keyword">permits</span>, stopwatch.readMicros());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 返回需要等待的时间*/</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="title function_">reserveAndGetWaitLength</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>, <span class="type">long</span> nowMicros)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">momentAvailable</span> <span class="operator">=</span> reserveEarliestAvailable(<span class="keyword">permits</span>, nowMicros);</span><br><span class="line">        <span class="keyword">return</span> max(momentAvailable - nowMicros, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 针对此次需要获取的令牌数更新下次可取令牌时间点与存储的令牌数，返回本次可取令牌的时间点*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="title function_">reserveEarliestAvailable</span><span class="params">(<span class="type">int</span> requiredPermits, <span class="type">long</span> nowMicros)</span> &#123;</span><br><span class="line">        resync(nowMicros); <span class="comment">// 更新当前数据</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">returnValue</span> <span class="operator">=</span> nextFreeTicketMicros;</span><br><span class="line">        <span class="type">double</span> <span class="variable">storedPermitsToSpend</span> <span class="operator">=</span> min(requiredPermits, <span class="built_in">this</span>.storedPermits); <span class="comment">// 本次可消费的令牌数</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">freshPermits</span> <span class="operator">=</span> requiredPermits - storedPermitsToSpend; <span class="comment">// 需要新增的令牌数</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">waitMicros</span> <span class="operator">=</span></span><br><span class="line">                storedPermitsToWaitTime(<span class="built_in">this</span>.storedPermits, storedPermitsToSpend)</span><br><span class="line">                        + (<span class="type">long</span>) (freshPermits * stableIntervalMicros); <span class="comment">// 需要等待的时间</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.nextFreeTicketMicros = LongMath.saturatedAdd(nextFreeTicketMicros, waitMicros); <span class="comment">// 更新下次可取令牌的时间点</span></span><br><span class="line">        <span class="built_in">this</span>.storedPermits -= storedPermitsToSpend; <span class="comment">// 更新当前存储的令牌数</span></span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>acquire(int)</code> 方法是获取不到令牌时一直阻塞，直到获取到令牌，<code>tryAcquire(int,long,TimeUnit)</code> 方法则是在指定超时时间内尝试获取令牌，如果获取到或超时时间到则返回是否获取成功</p><ol><li>先判断是否能在指定超时时间内获取到令牌，通过 <code>nextFreeTicketMicros &lt;= timeoutMicros + nowMicros</code> 是否为true来判断，即可取令牌时间早于当前时间加超时时间则可取（预消费的特性），否则不可获取。</li><li>如果不可获取，立即返回false。</li><li>如果可获取，则调用 <code>reserveAndGetWaitLength(permits, nowMicros)</code> 来更新下次可取令牌时间点与当前存储的令牌数，返回等待时间（逻辑与前面相同），并阻塞等待相应的时间，返回true。</li></ol><p>源码如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>, <span class="type">long</span> timeout, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">timeoutMicros</span> <span class="operator">=</span> max(unit.toMicros(timeout), <span class="number">0</span>);</span><br><span class="line">        checkPermits(<span class="keyword">permits</span>);</span><br><span class="line">        <span class="type">long</span> microsToWait;</span><br><span class="line">        <span class="keyword">synchronized</span> (mutex()) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">nowMicros</span> <span class="operator">=</span> stopwatch.readMicros();</span><br><span class="line">                <span class="keyword">if</span> (!canAcquire(nowMicros, timeoutMicros)) &#123; <span class="comment">//判断是否能在超时时间内获取指定数量的令牌</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        microsToWait = reserveAndGetWaitLength(<span class="keyword">permits</span>, nowMicros);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stopwatch.sleepMicrosUninterruptibly(microsToWait);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">canAcquire</span><span class="params">(<span class="type">long</span> nowMicros, <span class="type">long</span> timeoutMicros)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queryEarliestAvailable(nowMicros) - timeoutMicros &lt;= nowMicros; <span class="comment">//只要可取时间小于当前时间+超时时间，则可获取（可预消费的特性！）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="title function_">queryEarliestAvailable</span><span class="params">(<span class="type">long</span> nowMicros)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nextFreeTicketMicros;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是 SmoothBursty 实现的基本处理流程。注意两点：</p><ol><li>RateLimiter 通过限制后面请求的等待时间，来支持一定程度的突发请求——预消费的特性。</li><li>RateLimiter 令牌桶的实现并不是起一个线程不断往桶里放令牌，而是以一种延迟计算的方式（参考<code>resync</code>函数），在每次获取令牌之前计算该段时间内可以产生多少令牌，将产生的令牌加入令牌桶中并更新数据来实现，比起一个线程来不断往桶里放令牌高效得多。（想想如果需要针对每个用户限制某个接口的访问，则针对每个用户都得创建一个RateLimiter，并起一个线程来控制令牌存放的话，如果在线用户数有几十上百万，起线程来控制是一件多么恐怖的事情）</li></ol><p>Guava 的 RateLimiter 是令牌桶算法的一种实现，但 RateLimiter 只适用于单机应用，在分布式环境下就不适用了。</p><h1 id="限速控制"><a href="#限速控制" class="headerlink" title="限速控制"></a>限速控制</h1><h2 id="令牌桶模型"><a href="#令牌桶模型" class="headerlink" title="令牌桶模型"></a>令牌桶模型</h2><p>首先定义令牌桶模型，与RateLimiter中类似，包括几个关键属性与关键方法。其中关键属性定义如下，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisPermits</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大存储令牌数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> maxPermits;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前存储令牌数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> storedPermits;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加令牌时间间隔/毫秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> intervalMillis;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下次请求可以获取令牌的时间，可以是过去（令牌积累）也可以是将来的时间（令牌预消费）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> nextFreeTicketMillis;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisPermits</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键方法定义与RateLimiter也大同小异</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建Redis令牌数据模型</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> permitsPerSecond     每秒放入的令牌数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maxBurstSeconds      maxPermits由此字段计算，最大存储maxBurstSeconds秒生成的令牌</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nextFreeTicketMillis 下次请求可以获取令牌的起始时间，默认当前系统时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">RedisPermits</span><span class="params">(<span class="type">double</span> permitsPerSecond, <span class="type">double</span> maxBurstSeconds, Long nextFreeTicketMillis)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.maxPermits = permitsPerSecond * maxBurstSeconds;</span><br><span class="line">    <span class="built_in">this</span>.storedPermits = maxPermits;</span><br><span class="line">    <span class="built_in">this</span>.intervalMillis = TimeUnit.SECONDS.toMillis(<span class="number">1</span>) / permitsPerSecond;</span><br><span class="line">    <span class="built_in">this</span>.nextFreeTicketMillis = nextFreeTicketMillis;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于当前时间，若当前时间晚于nextFreeTicketMicros，则计算该段时间内可以生成多少令牌，将生成的令牌加入令牌桶中并更新数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">resync</span><span class="params">(<span class="type">long</span> nowMillis)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nowMillis &gt; nextFreeTicketMillis) &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">newPermits</span> <span class="operator">=</span> (nowMillis - nextFreeTicketMillis) / intervalMillis;</span><br><span class="line">        storedPermits = Math.min(maxPermits, storedPermits + newPermits);</span><br><span class="line">        nextFreeTicketMillis = nowMillis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">reserveAndGetWaitLength</span><span class="params">(<span class="type">long</span> nowMillis, <span class="type">int</span> <span class="keyword">permits</span>)</span> &#123;</span><br><span class="line">    resync(nowMillis);</span><br><span class="line">    <span class="type">double</span> <span class="variable">storedPermitsToSpend</span> <span class="operator">=</span> Math.min(<span class="keyword">permits</span>, storedPermits); <span class="comment">// 可以消耗的令牌数</span></span><br><span class="line">    <span class="type">double</span> <span class="variable">freshPermits</span> <span class="operator">=</span> <span class="keyword">permits</span> - storedPermitsToSpend; <span class="comment">// 需要等待的令牌数</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">waitMillis</span> <span class="operator">=</span> (<span class="type">long</span>) (freshPermits * intervalMillis); <span class="comment">// 需要等待的时间</span></span><br><span class="line"></span><br><span class="line">    nextFreeTicketMillis = LongMath.saturatedAdd(nextFreeTicketMillis, waitMillis);</span><br><span class="line">    storedPermits -= storedPermitsToSpend;</span><br><span class="line">    <span class="keyword">return</span> waitMillis;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canAcquire</span><span class="params">(<span class="type">long</span> nowMillis, <span class="type">int</span> <span class="keyword">permits</span>, <span class="type">long</span> timeoutMillis)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> queryEarliestAvailable(nowMillis, <span class="keyword">permits</span>) &lt;= timeoutMillis;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定数量令牌数可用的等待时间</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> permits 需保留的令牌数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定数量令牌可用的等待时间，如果为0或负数，表述当前可用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="title function_">queryEarliestAvailable</span><span class="params">(<span class="type">long</span> nowMillis, <span class="type">int</span> <span class="keyword">permits</span>)</span> &#123;</span><br><span class="line">    resync(nowMillis);</span><br><span class="line">    <span class="type">double</span> <span class="variable">storedPermitsToSpend</span> <span class="operator">=</span> Math.min(<span class="keyword">permits</span>, storedPermits); <span class="comment">// 可以消耗的令牌数</span></span><br><span class="line">    <span class="type">double</span> <span class="variable">freshPermits</span> <span class="operator">=</span> <span class="keyword">permits</span> - storedPermitsToSpend; <span class="comment">// 需要等待的令牌数</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">waitMillis</span> <span class="operator">=</span> (<span class="type">long</span>) (freshPermits * intervalMillis); <span class="comment">// 需要等待的时间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> LongMath.saturatedAdd(nextFreeTicketMillis - nowMillis, waitMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="令牌控制类"><a href="#令牌控制类" class="headerlink" title="令牌控制类"></a>令牌控制类</h2><p>Guava RateLimiter中的控制都在RateLimiter及其子类中（如SmoothBursty），本处涉及到分布式环境下的同步，因此将其解耦，令牌桶模型存储于Redis中，对其同步操作的控制放置在如下控制类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 限速控制</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> ronwxy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/6/24 17:41</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisRateLimiter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOCK_KEY_SUFFIX</span> <span class="operator">=</span> <span class="string">&quot;:lock&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PermitsRedisTemplate permitsRedisTemplate;</span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="keyword">private</span> DistributedLock lock;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> permitsPerSecond;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> maxBurstSeconds;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> expire;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisRateLimiter</span><span class="params">(PermitsRedisTemplate permitsRedisTemplate, StringRedisTemplate stringRedisTemplate, DistributedLock lock, <span class="type">double</span> permitsPerSecond,</span></span><br><span class="line"><span class="params">                            <span class="type">double</span> maxBurstSeconds, <span class="type">long</span> expire)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.permitsRedisTemplate = permitsRedisTemplate;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">        <span class="built_in">this</span>.lock = lock;</span><br><span class="line">        <span class="built_in">this</span>.permitsPerSecond = permitsPerSecond;</span><br><span class="line">        <span class="built_in">this</span>.maxBurstSeconds = maxBurstSeconds;</span><br><span class="line">        <span class="built_in">this</span>.expire = expire;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取一个令牌，阻塞一直到获取令牌，返回阻塞等待时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> time 阻塞等待时间/毫秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">acquire</span><span class="params">(String key)</span> <span class="keyword">throws</span> IllegalArgumentException &#123;</span><br><span class="line">        <span class="keyword">return</span> acquire(key, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定数量的令牌，如果令牌数不够，则一直阻塞，返回阻塞等待的时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> permits 需要获取的令牌数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> time 等待的时间/毫秒</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException tokens值不能为负数或零</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">acquire</span><span class="params">(String key, <span class="type">int</span> <span class="keyword">permits</span>)</span> <span class="keyword">throws</span> IllegalArgumentException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">millisToWait</span> <span class="operator">=</span> reserve(key, <span class="keyword">permits</span>);</span><br><span class="line">        log.info(<span class="string">&quot;acquire &#123;&#125; permits for key[&#123;&#125;], waiting for &#123;&#125;ms&quot;</span>, <span class="keyword">permits</span>, key, millisToWait);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(millisToWait);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;Interrupted when trying to acquire &#123;&#125; permits for key[&#123;&#125;]&quot;</span>, <span class="keyword">permits</span>, key, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> millisToWait;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在指定时间内获取一个令牌，如果获取不到则一直阻塞，直到超时</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout 最大等待时间（超时时间），为0则不等待立即返回</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit    时间单元</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 获取到令牌则true，否则false</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(String key, <span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> IllegalArgumentException &#123;</span><br><span class="line">        <span class="keyword">return</span> tryAcquire(key, <span class="number">1</span>, timeout, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在指定时间内获取指定数量的令牌，如果在指定时间内获取不到指定数量的令牌，则直接返回false，</span></span><br><span class="line"><span class="comment">     * 否则阻塞直到能获取到指定数量的令牌</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> permits 需要获取的令牌数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout 最大等待时间（超时时间）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit    时间单元</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果在指定时间内能获取到指定令牌数，则true,否则false</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException tokens为负数或零，抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(String key, <span class="type">int</span> <span class="keyword">permits</span>, <span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> IllegalArgumentException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">timeoutMillis</span> <span class="operator">=</span> Math.max(unit.toMillis(timeout), <span class="number">0</span>);</span><br><span class="line">        checkPermits(<span class="keyword">permits</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> millisToWait;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">locked</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            locked = lock.lock(key + LOCK_KEY_SUFFIX, WebUtil.getRequestId(), <span class="number">60</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span> (locked) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">nowMillis</span> <span class="operator">=</span> getNowMillis();</span><br><span class="line">                <span class="type">RedisPermits</span> <span class="variable">permit</span> <span class="operator">=</span> getPermits(key, nowMillis);</span><br><span class="line">                <span class="keyword">if</span> (!permit.canAcquire(nowMillis, <span class="keyword">permits</span>, timeoutMillis)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    millisToWait = permit.reserveAndGetWaitLength(nowMillis, <span class="keyword">permits</span>);</span><br><span class="line">                    permitsRedisTemplate.opsForValue().set(key, permit, expire, TimeUnit.SECONDS);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//超时获取不到锁，也返回false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (locked) &#123;</span><br><span class="line">                lock.unLock(key + LOCK_KEY_SUFFIX, WebUtil.getRequestId());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (millisToWait &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(millisToWait);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保留指定的令牌数待用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> permits 需保留的令牌数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> time 令牌可用的等待时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException tokens不能为负数或零</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">reserve</span><span class="params">(String key, <span class="type">int</span> <span class="keyword">permits</span>)</span> <span class="keyword">throws</span> IllegalArgumentException &#123;</span><br><span class="line">        checkPermits(<span class="keyword">permits</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock(key + LOCK_KEY_SUFFIX, WebUtil.getRequestId(), <span class="number">60</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="type">long</span> <span class="variable">nowMillis</span> <span class="operator">=</span> getNowMillis();</span><br><span class="line">            <span class="type">RedisPermits</span> <span class="variable">permit</span> <span class="operator">=</span> getPermits(key, nowMillis);</span><br><span class="line">            <span class="type">long</span> <span class="variable">waitMillis</span> <span class="operator">=</span> permit.reserveAndGetWaitLength(nowMillis, <span class="keyword">permits</span>);</span><br><span class="line">            permitsRedisTemplate.opsForValue().set(key, permit, expire, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">return</span> waitMillis;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unLock(key + LOCK_KEY_SUFFIX, WebUtil.getRequestId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取令牌桶</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> RedisPermits <span class="title function_">getPermits</span><span class="params">(String key, <span class="type">long</span> nowMillis)</span> &#123;</span><br><span class="line">        <span class="type">RedisPermits</span> <span class="variable">permit</span> <span class="operator">=</span> permitsRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="keyword">if</span> (permit == <span class="literal">null</span>) &#123;</span><br><span class="line">            permit = <span class="keyword">new</span> <span class="title class_">RedisPermits</span>(permitsPerSecond, maxBurstSeconds, nowMillis);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> permit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取redis服务器时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">getNowMillis</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">luaScript</span> <span class="operator">=</span> <span class="string">&quot;return redis.call(&#x27;time&#x27;)&quot;</span>; <span class="comment">//&quot;TIME&quot;;</span></span><br><span class="line">        DefaultRedisScript&lt;List&gt; redisScript = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;(luaScript, List.class);</span><br><span class="line">        List&lt;String&gt; now = (List&lt;String&gt;)stringRedisTemplate.execute(redisScript, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span> now == <span class="literal">null</span> ? System.currentTimeMillis() : Long.valueOf(now.get(<span class="number">0</span>))*<span class="number">1000</span>+Long.valueOf(now.get(<span class="number">1</span>))/<span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(Locale.ROOT, <span class="string">&quot;RateLimiter[rate=%3.1fqps]&quot;</span>, permitsPerSecond);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkPermits</span><span class="params">(<span class="type">long</span> <span class="keyword">permits</span>)</span> <span class="keyword">throws</span> IllegalArgumentException &#123;</span><br><span class="line">        Preconditions.checkArgument(<span class="keyword">permits</span> &gt; <span class="number">0</span>, <span class="string">&quot;Requested permits (%s) must be positive: &quot;</span>, <span class="keyword">permits</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ol><li>acquire 是阻塞方法，如果没有可用的令牌，则一直阻塞直到获取到令牌。</li><li>tryAcquire 则是非阻塞方法，如果在指定超时时间内获取不到指定数量的令牌，则直接返回false，不阻塞等待。</li><li>getNowMillis 获取Redis服务器时间，避免业务服务器时间不一致导致的问题，如果业务服务器能保障时间同步，则可从本地获取提高效率。</li></ol><h2 id="令牌桶控制工厂类"><a href="#令牌桶控制工厂类" class="headerlink" title="令牌桶控制工厂类"></a>令牌桶控制工厂类</h2><p>工厂类负责管理令牌桶控制类，将其缓存在本地，这里使用了Guava中的Cache，一方面避免每次都新建控制类提高效率，另一方面通过控制缓存的最大容量来避免像用户粒度的限流占用过多的内存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisRateLimiterFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PermitsRedisTemplate permitsRedisTemplate;</span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="keyword">private</span> DistributedLock distributedLock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Cache&lt;String, RedisRateLimiter&gt; cache = CacheBuilder.newBuilder()</span><br><span class="line">            .initialCapacity(<span class="number">100</span>)  <span class="comment">//初始大小</span></span><br><span class="line">            .maximumSize(<span class="number">10000</span>) <span class="comment">// 缓存的最大容量</span></span><br><span class="line">            .expireAfterAccess(<span class="number">5</span>, TimeUnit.MINUTES) <span class="comment">// 缓存在最后一次访问多久之后失效</span></span><br><span class="line">            .concurrencyLevel(Runtime.getRuntime().availableProcessors()) <span class="comment">// 设置并发级别</span></span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisRateLimiterFactory</span><span class="params">(PermitsRedisTemplate permitsRedisTemplate, StringRedisTemplate stringRedisTemplate, DistributedLock distributedLock)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.permitsRedisTemplate = permitsRedisTemplate;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">        <span class="built_in">this</span>.distributedLock = distributedLock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建RateLimiter</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key              Redis key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> permitsPerSecond 每秒放入的令牌数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxBurstSeconds  最大存储maxBurstSeconds秒生成的令牌</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expire           该令牌桶的redis tty/秒</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> RateLimiter</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> RedisRateLimiter <span class="title function_">build</span><span class="params">(String key, <span class="type">double</span> permitsPerSecond, <span class="type">double</span> maxBurstSeconds, <span class="type">int</span> expire)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cache.getIfPresent(key) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cache.getIfPresent(key) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    cache.put(key, <span class="keyword">new</span> <span class="title class_">RedisRateLimiter</span>(permitsRedisTemplate, stringRedisTemplate, distributedLock, permitsPerSecond,</span><br><span class="line">                            maxBurstSeconds, expire));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cache.getIfPresent(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注解支持"><a href="#注解支持" class="headerlink" title="注解支持"></a>注解支持</h2><p>定义注解 @RateLimit 如下，表示以每秒rate的速率放置令牌，最多保留burst秒的令牌，取令牌的超时时间为timeout，limitType用于控制key类型，目前支持：</p><ol><li>IP, 根据客户端IP限流</li><li>USER, 根据用户限流，对于Spring Security可从SecurityContextHolder中获取当前用户信息，如userId</li><li>METHOD, 根据方法名全局限流，className.methodName，注意避免同时对同一个类中的同名方法做限流控制，否则需要修改获取key的逻辑</li><li>CUSTOM，自定义，支持表达式解析，如#{id}, #{user.id}</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RateLimit &#123;</span><br><span class="line">    String <span class="title function_">key</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    String <span class="title function_">prefix</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;rateLimit:&quot;</span>; <span class="comment">//key前缀</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">expire</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">60</span>; <span class="comment">// 表示令牌桶模型RedisPermits redis key的过期时间/秒</span></span><br><span class="line">    <span class="type">double</span> <span class="title function_">rate</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">1.0</span>; <span class="comment">// permitsPerSecond值</span></span><br><span class="line">    <span class="type">double</span> <span class="title function_">burst</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">1.0</span>; <span class="comment">// maxBurstSeconds值</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">timeout</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>; <span class="comment">// 超时时间/秒</span></span><br><span class="line">    LimitType <span class="title function_">limitType</span><span class="params">()</span> <span class="keyword">default</span> LimitType.METHOD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过切面的前置增强来为添加了 @RateLimit 注解的方法提供限流控制，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisLimitAspect</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LIMIT_MESSAGE</span> <span class="operator">=</span> <span class="string">&quot;您的访问过于频繁，请稍后重试&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RedisCountLimiter redisCountLimiter;</span><br><span class="line">    <span class="keyword">private</span> RedisRateLimiterFactory redisRateLimiterFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisLimitAspect</span><span class="params">(RedisCountLimiter redisCountLimiter, RedisRateLimiterFactory redisRateLimiterFactory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.redisCountLimiter = redisCountLimiter;</span><br><span class="line">        <span class="built_in">this</span>.redisRateLimiterFactory = redisRateLimiterFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(value = &quot;@annotation(rateLimit)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rateLimit</span><span class="params">(JoinPoint  point, RateLimit rateLimit)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> getKey(point, rateLimit.limitType(), rateLimit.key(), rateLimit.prefix());</span><br><span class="line">        <span class="type">RedisRateLimiter</span> <span class="variable">redisRateLimiter</span> <span class="operator">=</span> redisRateLimiterFactory.build(key, rateLimit.rate(), rateLimit.burst(), rateLimit.expire());</span><br><span class="line">        <span class="keyword">if</span>(!redisRateLimiter.tryAcquire(key, rateLimit.timeout(), TimeUnit.SECONDS))&#123;</span><br><span class="line">            ExceptionUtil.rethrowClientSideException(LIMIT_MESSAGE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getKey</span><span class="params">(JoinPoint  point, LimitType limitType, String originKey, String prefix)</span> &#123;</span><br><span class="line">        String key;</span><br><span class="line">        <span class="keyword">switch</span> (limitType) &#123;</span><br><span class="line">            <span class="keyword">case</span> IP:</span><br><span class="line">                key = WebUtil.getIP();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> USER:</span><br><span class="line">                <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> SecurityUtil.getUserId();</span><br><span class="line">                <span class="keyword">if</span>(userId == <span class="literal">null</span>) &#123;</span><br><span class="line">                    ExceptionUtil.rethrowClientSideException(<span class="string">&quot;获取不到用户信息&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                key = String.valueOf(userId);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> METHOD:</span><br><span class="line">                key = ((Class) point.getTarget()).getName() + <span class="string">&quot;:&quot;</span> + ((MethodSignature) point.getSignature()).getMethod().getName();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CUSTOM:</span><br><span class="line">                key = String.valueOf(resolve(point, originKey));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                key = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(key)) &#123;</span><br><span class="line">            ExceptionUtil.rethrowClientSideException(<span class="string">&quot;Key不能为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prefix + key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">resolve</span><span class="params">(JoinPoint joinPoint, String placeholder)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(placeholder)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (placeholder.matches(<span class="string">&quot;#\\&#123;\\D*\\&#125;&quot;</span>)) &#123;<span class="comment">// 匹配上#&#123;&#125;,则把内容当作变量</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">param</span> <span class="operator">=</span> placeholder.replaceAll(<span class="string">&quot;#\\&#123;&quot;</span>, <span class="string">&quot;&quot;</span>).replaceAll(<span class="string">&quot;\\&#125;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (param.contains(<span class="string">&quot;.&quot;</span>)) &#123; <span class="comment">// 多层引用</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    value = complexResolve(joinPoint, param);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;fail to resolve value for &#123;&#125;&quot;</span>, param, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                value = simpleResolve(joinPoint, param);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            value = placeholder;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 多层引用参数解析值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> placeholder</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object <span class="title function_">complexResolve</span><span class="params">(JoinPoint joinPoint, String placeholder)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">MethodSignature</span> <span class="variable">methodSignature</span> <span class="operator">=</span> (MethodSignature) joinPoint.getSignature();</span><br><span class="line">        String[] names = methodSignature.getParameterNames();</span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        String[] params = placeholder.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; names.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (params[<span class="number">0</span>].equals(names[i])) &#123;</span><br><span class="line">                <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> args[i];</span><br><span class="line">                <span class="type">Method</span> <span class="variable">getMethod</span> <span class="operator">=</span> obj.getClass().getDeclaredMethod(getMethodName(params[<span class="number">1</span>]), <span class="literal">null</span>);</span><br><span class="line">                <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> getMethod.invoke(args[i]);</span><br><span class="line">                <span class="keyword">return</span> getValue(value, <span class="number">1</span>, params);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 简单参数获取值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> placeholder</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object <span class="title function_">simpleResolve</span><span class="params">(JoinPoint joinPoint, String placeholder)</span> &#123;</span><br><span class="line">        <span class="type">MethodSignature</span> <span class="variable">methodSignature</span> <span class="operator">=</span> (MethodSignature) joinPoint.getSignature();</span><br><span class="line">        String[] names = methodSignature.getParameterNames();</span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; names.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (placeholder.equals(names[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> args[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object <span class="title function_">getValue</span><span class="params">(Object obj, <span class="type">int</span> index, String[] params)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="literal">null</span> &amp;&amp; index &lt; params.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> obj.getClass().getDeclaredMethod(getMethodName(params[index + <span class="number">1</span>]), <span class="literal">null</span>);</span><br><span class="line">            obj = method.invoke(obj);</span><br><span class="line">            getValue(obj, index + <span class="number">1</span>, params);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getMethodName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;get&quot;</span> + StringUtils.capitalize(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="限量控制"><a href="#限量控制" class="headerlink" title="限量控制"></a>限量控制</h1><h2 id="限量控制类"><a href="#限量控制类" class="headerlink" title="限量控制类"></a>限量控制类</h2><p>限制一个时间窗口内的访问量，可使用计数器算法，借助Lua脚本执行的原子性来实现。</p><p>Lua脚本逻辑：</p><ol><li>以需要控制的对象为key（如方法，用户ID，或IP等），当前访问次数为Value，时间窗口值为缓存的过期时间</li><li>如果key存在则将其增1，判断当前值是否大于访问量限制值，如果大于则返回0，表示该时间窗口内已达访问量上限，如果小于则返回1表示允许访问</li><li>如果key不存在，则将其初始化为1，并设置过期时间，返回1表示允许访问</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisCountLimiter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LUA_SCRIPT</span> <span class="operator">=</span> <span class="string">&quot;local c \nc = redis.call(&#x27;get&#x27;,KEYS[1]) \nif c and redis.call(&#x27;incr&#x27;,KEYS[1]) &gt; tonumber(ARGV[1]) then return 0 end&quot;</span></span><br><span class="line">            + <span class="string">&quot; \nif c then return 1 else \nredis.call(&#x27;set&#x27;, KEYS[1], 1) \nredis.call(&#x27;expire&#x27;, KEYS[1], tonumber(ARGV[2])) \nreturn 1 end&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SUCCESS_RESULT</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">FAIL_RESULT</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisCountLimiter</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否允许访问</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key redis key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> limit 限制次数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expire 时间段/秒</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 获取成功true，否则false</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(String key, <span class="type">int</span> limit, <span class="type">int</span> expire)</span> <span class="keyword">throws</span> IllegalArgumentException &#123;</span><br><span class="line">        RedisScript&lt;Number&gt; redisScript = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;(LUA_SCRIPT, Number.class);</span><br><span class="line">        <span class="type">Number</span> <span class="variable">result</span> <span class="operator">=</span> stringRedisTemplate.execute(redisScript, Collections.singletonList(key), String.valueOf(limit), String.valueOf(expire));</span><br><span class="line">        <span class="keyword">if</span>(result != <span class="literal">null</span> &amp;&amp; result.intValue() == SUCCESS_RESULT) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注解支持-1"><a href="#注解支持-1" class="headerlink" title="注解支持"></a>注解支持</h2><p>定义注解 @CountLimit 如下，表示在period时间窗口内，最多允许访问limit次，limitType用于控制key类型，取值与 @RateLimit 同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CountLimit &#123;</span><br><span class="line">    String <span class="title function_">key</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    String <span class="title function_">prefix</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;countLimit:&quot;</span>; <span class="comment">//key前缀</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">limit</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">1</span>;  <span class="comment">// expire时间段内限制访问次数</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">period</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">1</span>; <span class="comment">// 表示时间段/秒</span></span><br><span class="line">    LimitType <span class="title function_">limitType</span><span class="params">()</span> <span class="keyword">default</span> LimitType.METHOD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样采用前值增强来为添加了 @CountLimit 注解的方法提供限流控制，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(value = &quot;@annotation(countLimit)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countLimit</span><span class="params">(JoinPoint  point, CountLimit countLimit)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> getKey(point, countLimit.limitType(), countLimit.key(), countLimit.prefix());</span><br><span class="line">    <span class="keyword">if</span> (!redisCountLimiter.tryAcquire(key, countLimit.limit(), countLimit.period())) &#123;</span><br><span class="line">        ExceptionUtil.rethrowClientSideException(LIMIT_MESSAGE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://zyanprocess.github.io/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/">后端开发</category>
      
      
      <category domain="http://zyanprocess.github.io/tags/%E9%99%90%E6%B5%81/">限流</category>
      
      
      <comments>http://zyanprocess.github.io/2023/04/12/%E5%B8%B8%E7%94%A8%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Nginx</title>
      <link>http://zyanprocess.github.io/2023/04/10/Nginx/</link>
      <guid>http://zyanprocess.github.io/2023/04/10/Nginx/</guid>
      <pubDate>Mon, 10 Apr 2023 07:48:08 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;什么是Nginx&quot;&gt;&lt;a href=&quot;#什么是Nginx&quot; class=&quot;headerlink&quot; title=&quot;什么是Nginx&quot;&gt;&lt;/a&gt;什么是Nginx&lt;/h1&gt;&lt;p&gt;Nginx同Apache一样都是Web服务器，但是Nginx更加轻量级，它的内存占用少，启动快，并发能力强。Nginx可以作为反向代理服务器使用，支持IMAP/POP3/SMTP服务。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="什么是Nginx"><a href="#什么是Nginx" class="headerlink" title="什么是Nginx"></a>什么是Nginx</h1><p>Nginx同Apache一样都是Web服务器，但是Nginx更加轻量级，它的内存占用少，启动快，并发能力强。Nginx可以作为反向代理服务器使用，支持IMAP/POP3/SMTP服务。</p><span id="more"></span><h1 id="Nginx特点"><a href="#Nginx特点" class="headerlink" title="Nginx特点"></a>Nginx特点</h1><ol><li><strong>内存占用少</strong>：10000个非活跃的HTTP Keep-Alive连接在Nginx中仅损耗2.5MB内存。</li><li><strong>高并发</strong>：单机支持10万以上的并发连接。</li><li><strong>跨平台</strong></li><li><strong>扩展性好</strong></li><li><strong>安装使用简单</strong></li></ol><h1 id="Nginx的功能"><a href="#Nginx的功能" class="headerlink" title="Nginx的功能"></a>Nginx的功能</h1><h2 id="静态资源服务器"><a href="#静态资源服务器" class="headerlink" title="静态资源服务器"></a>静态资源服务器</h2><p>Nginx可以将服务器上的静态文件缓存下来，通过HTTP协议展现给客户端。因此，我们可以使用Nginx搭建静态资源服务器。使用gzip压缩静态资源减少网络传输。</p><p>当客户端第一次请求静态资源的时候，会从服务器直接返回，Nginx同时也会缓存一份静态资源。如果后续客户端请求同样的静态资源，只要对应的缓存未被清理并且没有过期，就可以直接从Nginx缓存中取出返回给客户端。</p><p><img src="/2023/04/10/Nginx/1.png"></p><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>客户端将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器，获取数据后再返回给客户端。对外暴露的是反向代理服务器地址，隐藏了真实服务器IP地址。反向代理的是目标服务器，这一过程对于客户端而言是透明的。</p><p>举例：公司内网部署了3台服务器，客户端请求直接经过代理服务器，由代理服务器将请求转发到内网服务器并最终决定哪一台服务器处理客户端请求。</p><p><img src="/2023/04/10/Nginx/2.png"></p><p>反向代理隐藏了真实的服务器，为服务器收发请求，使真实服务器对客户端不可见。一般在处理跨域请求的时候比较常用。</p><h2 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h2><p>客户端通过正向代理服务器访问目标服务器。正向代理客户端，目标服务器不知道客户端是谁，也就是说客户端对目标服务器的这次访问是透明的。</p><p>为了实现正向代理，客户端需要设置正向代理服务器的IP地址，以及代理程序的端口。</p><p>举例：我们无法直接访问外网，但是可以借助VPN来访问。VPN会把访问目标服务器的客户端请求代理到一个可以直接访问外网的代理服务器上。代理服务器会把外网服务器返回的内容再转发给客户端。</p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>如果一台服务器处理用户请求处理不过来，一个简单的办法就是增加多台服务器，部署相同的服务来处理用户请求。</p><p>Nginx可以将接收到的客户端请求以一定的规则均匀地分配到这个服务器集群中所有地服务器上。Nginx在其中充当的就是反向代理服务器地作用，负载均衡是Nginx作为反向代理服务器最常见的一个应用。</p><p>除此之外，Nginx还带有健康检查功能，会定期轮询向集群里所有地服务器发送健康检查请求，来检查集群中是否有服务器处于异常状态。</p><p><img src="/2023/04/10/Nginx/3.png"></p><h1 id="Nginx为什么适合做负载均衡"><a href="#Nginx为什么适合做负载均衡" class="headerlink" title="Nginx为什么适合做负载均衡"></a>Nginx为什么适合做负载均衡</h1><p>Nginx工作在网络地第七层（应用层），可以针对HTTP应用本身来做分流策略，支持HTTP、HTTPS协议地负载均衡。在工作中，我们通常可以使用Nginx来做七层负载均衡。</p><ul><li>Nginx属于软件负载均衡，相比于硬件负载均衡来说，价格非常低。</li><li>Nginx使用简单。</li><li>Nginx自带健康检查。</li><li>Nginx支持热部署。</li></ul><h1 id="Nginx负载均衡策略"><a href="#Nginx负载均衡策略" class="headerlink" title="Nginx负载均衡策略"></a>Nginx负载均衡策略</h1><h2 id="轮询（默认）"><a href="#轮询（默认）" class="headerlink" title="轮询（默认）"></a>轮询（默认）</h2><p>轮询为负载均衡中较为基础的算法，如果没有配置权重的话，每个请求就按时间顺序逐一分配到不同的服务器处理。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> backserver&#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">172.27.26.174:8099</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">172.27.26.175:8099</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">172.27.26.176:8099</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果配置权重的话，权重越高的服务器被访问的概率越大。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> backserver&#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">172.27.26.174:8099</span> weight=<span class="number">6</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">172.27.26.175:8099</span> weight=<span class="number">2</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">172.27.26.176:8099</span> weight=<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>未加权重的轮询算法适合于服务器性能相近的集群，其中每个服务器承载相同的负载。加权轮询算法适合于服务器性能不等的集群。</p><h2 id="IP哈希"><a href="#IP哈希" class="headerlink" title="IP哈希"></a>IP哈希</h2><p>根据发出请求的客户端IP的hash值来分配服务器，可以保证同IP发出来的请求映射到同一台服务器，或者具有相同hash值的不同IP映射到同一台服务器。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> backserver&#123;</span><br><span class="line">    ip_hash;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">172.27.26.174:8099</span> ;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">172.27.26.175:8099</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">172.27.26.176:8099</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和轮询一样，IP哈希也可以配置权重，如果有两个活动连接数相同的服务器，权重大的被访问的概率越大。</p><h2 id="最小连接数"><a href="#最小连接数" class="headerlink" title="最小连接数"></a>最小连接数</h2><p>当有新的请求出现时，遍历服务器节点列表，并选取其中活动连接数最小的一台服务器来响应当前请求。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> backserver&#123;</span><br><span class="line">    least_conn;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">172.27.26.174:8099</span> ;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">172.27.26.175:8099</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">172.27.26.176:8099</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Nginx-常用命令"><a href="#Nginx-常用命令" class="headerlink" title="Nginx 常用命令"></a>Nginx 常用命令</h1><ul><li><code>nginx</code>：启动</li><li><code>nignx -s stop</code>： 停止</li><li><code>./sbin/nginx -s reload</code>：重载配置（平滑重启） <code>service nginx reload</code></li><li><code>.nginx -c /usr/local/nginx/conf/nginx.conf</code>：重载指定配置文件</li><li><code>nginx -v</code>：查看nginx版本</li><li><code>nginx -t</code>：查看配置文件是否正确</li><li><code>nginx -h</code>：显示帮助信息</li></ul><h1 id="Nginx性能优化常见方式"><a href="#Nginx性能优化常见方式" class="headerlink" title="Nginx性能优化常见方式"></a>Nginx性能优化常见方式</h1><ul><li><strong>设置Nginx运行工作进程个数</strong>：Cpu的核心数或者核心数x2</li><li><strong>开启Gzip压缩</strong></li><li><strong>设置单个worker进程允许客户端最大连接数</strong></li><li><strong>连接超时时间设置</strong></li></ul><h1 id="Nginx工作模式和进程模型"><a href="#Nginx工作模式和进程模型" class="headerlink" title="Nginx工作模式和进程模型"></a>Nginx工作模式和进程模型</h1><h2 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h2><ol><li>Nginx 启动后，会产生一个 master 主进程，主进程执行一系列的工作后会产生一个或者多个工作进程 worker</li><li>在客户端请求动态站点的过程中，Nginx 服务器还涉及和后端服务器的通信。Nginx 将接收到的 Web 请求通过代理转发到后端服务器，由后端服务器进行数据处理和组织；</li><li>Nginx 为了提高对请求的响应效率，降低网络压力，采用了缓存机制，将历史应答数据缓存到本地。保障对缓存文件的快速访问</li></ol><h2 id="进程模型"><a href="#进程模型" class="headerlink" title="进程模型"></a>进程模型</h2><p><img src="/2023/04/10/Nginx/Nginx%5CgVfCciWSaq.png"></p><h3 id="master-进程"><a href="#master-进程" class="headerlink" title="master 进程"></a>master 进程</h3><p>主要用来管理 worker 进程，master 进程会接收来自外界发来的信号，再根据信号做不同的事情。所以我们要控制 nginx，只需要通过 kill 向 master 进程发送信号就行了。</p><p>具体包括以下主要功能:</p><ul><li>接收来自外界的信号</li><li>向各 worker 进程发送信号</li><li>监控 worker 进程的运行状态，当 worker 进程退出后 (异常情况下)，会自动重新启动新的 worker 进程</li></ul><h3 id="worker进程"><a href="#worker进程" class="headerlink" title="worker进程"></a>worker进程</h3><p>主要任务是完成具体的任务逻辑。其主要关注点是与客户端或后端真实服务器 (此时 worker 作为中间代理) 之间的数据可读 / 可写等 I/O 交互事件。具体包括以下主要功能:</p><p>接收客户端请求；</p><ul><li><p>将请求一次送入各个功能模块进行过滤处理；</p></li><li><p>与后端服务器通信，接收后端服务器处理结果；</p></li><li><p>数据缓存 proxy_cache 模块</p></li><li><p>响应客户端请求</p><p>（一个请求，完全由 worker 进程来处理，而且只在一个 worker 进程中处理。）</p></li></ul><h3 id="worker进程是如何处理请求？"><a href="#worker进程是如何处理请求？" class="headerlink" title="worker进程是如何处理请求？"></a>worker进程是如何处理请求？</h3><p>首先，worker 进程之间是平等的，每个 worker 进程都是从 master 进程 fork 过来，在 master 进程里面，先建立好需要 listen 的 socket（listenfd）之后，然后再 fork 出多个 worker 进程。每个 worker 进程，处理请求的机会也是一样的。当一个连接请求过来，每个进程都有可能处理这个连接，怎么做的呢？</p><p>所有 worker 进程的 listenfd 会在新连接到来时变得可读，为保证只有一个进程处理该连接，所有 worker 进程在注册 listenfd 读事件前抢 accept_mutex，抢到互斥锁的那个 worker 进程注册 listenfd 读事件，在读事件里调用 accept 接受该连接。</p><p>当一个 worker 进程在 accept 这个连接之后，就开始读取请求，解析请求，处理请求，产生数据后，再返回给客户端，最后断开连接，这样就是一个完整的请求就是这样的了。</p><p>我们可以了解到一个请求，完全由 worker 进程来处理，且只在一个 worker 进程中处理。</p><h2 id="Nginx采用IO多路复用模型"><a href="#Nginx采用IO多路复用模型" class="headerlink" title="Nginx采用IO多路复用模型"></a>Nginx采用IO多路复用模型</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IO 多路复用是指内核一旦发现进程指定的一个或者多个 IO 条件准备读取，它就通知该进程，目前支持 I/O 多路复用的系统调用有 select ， poll ， epoll ，I/O 多路复用就是通过一种机制，一个进程可以监视多个描述符 (socket)，一旦某个描述符就绪 (一般是读就绪或者写就绪)，能够通知程序进行相应的读 写操作。</span><br></pre></td></tr></table></figure><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p><strong>基本原理</strong></p><p>select 函数监视的文件描述符分 3 类，分别是 writefds、readfds、和 exceptfds。调用后 select 函数会阻塞，直到有描述符就绪（有数据 可读、可写、或者有 except），或者超时（timeout 指定等待时间，如果立即返回设为 null 即可），函数返回。当 select 函数返回后，可以通过遍历 fdset，来找到就绪的描述符。</p><p><strong>缺点</strong></p><p>select 本质上是通过设置或者检查存放 fd 标志位的数据结构来进行下一步处理。这样所带来的缺点是：</p><ul><li>select 最大的缺陷就是单个进程所打开的 FD 是有一定限制的，它由 FD_SETSIZE 设置，默认值是 1024。（一般来说这个数目和系统内存关系很大，具体数目可以 cat /proc/sys/fs/file-max 查看。32 位机默认是 1024 个。64 位机默认是 2048）</li><li>对 socket 进行扫描时是线性扫描，即采用轮询的方法，效率较低。（当套接字比较多的时候，每次 select () 都要通过遍历 FD_SETSIZE 个 Socket 来完成调度，不管哪个 Socket 是活跃的，都遍历一遍。这会浪费很多 CPU 时间。如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询，这正是 epoll 与 kqueue 做的）</li><li>需要维护一个用来存放大量 fd 的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大。</li></ul><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p><strong>基本原理</strong></p><p>poll 本质上和 select 没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个 fd 对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有 fd 后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历 fd。这个过程经历了多次无谓的遍历。</p><p><strong>优点</strong></p><ul><li>它没有最大连接数的限制，原因是它是基于链表来存储的。</li></ul><p><strong>缺点</strong></p><ul><li>大量的 fd 的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义。</li><li>poll 还有一个特点是 “水平触发”，如果报告了 fd 后，没有被处理，那么下次 poll 时会再次报告该 fd。</li></ul><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>epoll 是在 2.6 内核中提出的，是之前的 select 和 poll 的增强版本。相对于 select 和 poll 来说，epoll 更加灵活，没有描述符限制。epoll 使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的 copy 只需一次。</p><p><strong>基本原理</strong></p><p>epoll 支持水平触发和边缘触发，最大的特点在于边缘触发，它只告诉进程哪些 fd 刚刚变为就绪态，并且只会通知一次。还有一个特点是，epoll 使用 “事件” 的就绪通知方式，通过 epoll_ctl 注册 fd，一旦该 fd 就绪，内核就会采用类似 callback 的回调机制来激活该 fd，epoll_wait 便可以收到通知。</p><p><strong>epoll 对文件描述符的操作有两种模式</strong></p><p>LT（level trigger）和 ET（edge trigger）。LT 模式是默认模式，两者区别如下：</p><ul><li>LT 模式：当 epoll_wait 检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用 epoll_wait 时，会再次响应应用程序并通知此事件。</li><li>ET 模式：当 epoll_wait 检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用 epoll_wait 时，不会再次响应应用程序并通知此事件。</li></ul><p><strong>优点</strong></p><ul><li>没有最大并发连接的限制，能打开的 FD 的上限远大于 1024（1G 的内存上能监听约 10 万个端口）。</li><li>效率提升，不是轮询的方式，不会随着 FD 数目的增加效率下降。<br>只有活跃可用的 FD 才会调用 callback 函数；即 Epoll 最大的优点就在于它只管你 “活跃” 的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll 的效率就会远远高于 select 和 poll。</li><li>内存拷贝，利用 mmap () 文件映射内存加速与内核空间的消息传递；即 epoll 使用 mmap 减少复制开销。</li></ul><h1 id="Nginx处理HTTP头部过程"><a href="#Nginx处理HTTP头部过程" class="headerlink" title="Nginx处理HTTP头部过程"></a>Nginx处理HTTP头部过程</h1><p>Nginx 在处理 HTTP 请求之前，首先需要 Nginx 的框架先和客户端建立好连接，然后接收用户发来的 HTTP 的请求行，比如方法、URL 等，然后接收所有的 Header，根据这些 Header 信息，才能决定由哪些 HTTP 模块处理请求。下面这张图，解释了 Nginx 在处理 HTTP 请求之前，所经历的一系列流程，强烈建议收藏保存。下面针对每个部分单独讲解一下。</p><p><img src="/2023/04/10/Nginx/Nginx%5C123.png"></p><h2 id="接受请求事件模块"><a href="#接受请求事件模块" class="headerlink" title="接受请求事件模块"></a>接受请求事件模块</h2><p><img src="/2023/04/10/Nginx/Nginx%5C321.png"></p><p>首先是三次握手，当客户端发来 ACK 之后，由操作系统内核回一个 SYN+ACK，紧接着客户端 ACK 之后，连接建立成功。同时可能有很多 worker 进程都在监听 80 或 443 端口，由操作系统的负载均衡算法，选取一个 worker 进程来处理，这个 worker 进程会通过 <code>epoll_wait</code> 方法，返回一个建立连接的句柄。拿到了监听的句柄之后，这实际上是一个读事件（因为是从操作系统中读取到了一个请求），调用 <code>accept</code> 方法，分配连接内存池。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">内存池主要分为连接内存池和请求内存池。</span><br></pre></td></tr></table></figure><p>连接内存池大小的配置是 <code>connection_pool_size</code>，到了这一步之后，Nginx 会为已经建立的连接分配一个 512 字节大小的连接内存池。分配完内存池，建立好连接之后，HTTP 模块会从事件模块手里接入请求处理的过程，HTTP 模块在启动时，会调用 <code>ngx_http_init_connection</code> 方法来设置回调方法，这个时候会把新建立连接的读事件通过 <code>epoll_ctl</code> 函数添加到 epoll 中，然后加一个超时定时器 <code>client_header_timeout: 60s</code>，这个定时器的作用是，如果超过 60s 还没有接收到客户端发来的请求，那么就会断开连接。这一部分走完之后，Nginx 的事件模块可能就会切换到其他的句柄去处理了。</p><p><img src="/2023/04/10/Nginx/Nginx%5CbVbFVZN.png"></p><p>当用户真的把请求发来之后，操作系统会回复一个 ACK，同时事件模块的 <code>epoll_wait</code> 也拿到了这个请求，这个时候会调用设置的回调方法 <code>ngx_http_wait_request_handler</code>，将接收到的用户请求读到用户态中，而读取到用户态中需要操作系统分配内存，那么这段内存分配多大？从哪里分配呢？</p><p>这段内存是从连接内存池分配的，初始虽然分配了 512 字节，但是内存池可以扩展，由 <code>client_header_buffer_size: 1k</code> 分配 1k 内存，内存池并不是越大越好，因为用户即使发送了 1 个字节，也会分配出 1k 的内存出来。当 URL 超过 1k 后，应该怎么办呢？</p><h2 id="接收请求HTTP模块"><a href="#接收请求HTTP模块" class="headerlink" title="接收请求HTTP模块"></a>接收请求HTTP模块</h2><p><img src="/2023/04/10/Nginx/Nginx%5CbVbFVZO.png"></p><p>处理请求和处理连接是不一样的，处理请求只需要放到 Nginx 内存中就行了，但是处理请求还需要做大量的上下文分析，所以要分配一个请求内存池 <code>request_pool_size: 4k</code>。分配完以后，状态机开始解析请求行，如果这时候发现 URL 大于 4k，那么就会再分配一个大内存，也就是 <code>large_client_header_buffers: 4 8k</code>，这个配置的意思是说，最多分配 4 个 8k，它并不是一次性分配 32k，而是先分配 8k 然后再去解析请求行，如果依然大于 8k，那么就会再分配 8k 的内存。</p><p>Nginx 有很多变量，这些变量都是指针，其中可以用来标识 URI，标识完成之后，就开始处理 header。状态机解析 header 的时候，如果发现内存不够，也就是假如 URL 已经用掉了 <code>large_client_header_buffers: 4 8k</code> 中的 2 个 8k，这时候最多也只能分配 8k，请求行和 header 是公用 4 个 8k的。</p><p>分配完大内存之后，就开始标识 header，确定哪一个 server 块去处理请求，然后移除超时定时器，接下来，就开始核心的 11 个阶段 HTTP 请求处理请求。</p><p>这里需要注意以下几个地方：</p><ul><li>连接内存池：初始大小 512 字节<ul><li><code>client_header_buffer_size: 1k</code> 从连接内存池中分配</li><li><code>large_client_header_buffers: 4 8k</code> 也是从连接内存池中分配</li></ul></li><li>请求内存池：<code>request_pool_size: 4k</code></li></ul>]]></content:encoded>
      
      
      <category domain="http://zyanprocess.github.io/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/">后端开发</category>
      
      
      <category domain="http://zyanprocess.github.io/tags/Nginx/">Nginx</category>
      
      
      <comments>http://zyanprocess.github.io/2023/04/10/Nginx/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
